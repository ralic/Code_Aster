# MODIF  DATE 09/01/2012   AUTEUR CORUS M.CORUS 
# TITRE TEST INFORMATIQUE QZ ET SORENSEN NON SYMETRIQUES
# sdll123b.para = tps_job 60 mem_job 32Mo ncpus 1 liste_test R
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# ======================================================================
# CAS TEST INFORMATIQUE DE VALIDATION DES SOLVEURS MODAUX SORENSEN ET QZ
# EN GENERALISE ET QUADRATIQUE NON SYMETRIQUES (EN STRUCTURE ET EN 
# VALEURS NUMERIQUES)
# ON TESTE LES 3 APPROCHES DE SORENSEN EN QUADRATIQUE
# PERIMETRE: MATRICES K, M (ET C EN QUAD) REELLES ET NON SYMETRIQUES
#
# CAS TEST DOUBLONS DU SDLL123A EXPLOITANT LE CARACTERE NON SYMETRIQUE
# DES MATRICES ISSUES DU CALCUL ELEMENTAIRE 'MECA_GYRO'
# SUR LES VALEURS PROPRES: ON COMPARE QZ ET SORENSEN A PYTHON/LAPACK
#
# DETAILS:
# CE CAS-TEST EST INSTRUMENTE POUR JOUER SUR:
#   - CONSTRUCTION DE PBS MODAUX SYM, NON SYM STRUCTUREL AVEC VALEURS
#     SYM ET AVEC VALEURS NON SYM.
#   - TECHNIQUE DE REDUCTION LINEAIRE POUR PASSAGE ASTER/PYTHON
#   - EN QUADRATIQUE, VARIANTES DE SORENSEN
# ======================================================================

import numpy as NP
import numpy.linalg as LA

DEBUT( CODE=_F(NOM='SDLL123B', NIV_PUB_WEB='INTERNET'),
       PAR_LOT='NON')
aster.matfpe(-1)

nddl=19*6-4-4

MAIL=LIRE_MAILLAGE()

MODELE=AFFE_MODELE(MAILLAGE=MAIL,
                   AFFE=(_F(GROUP_MA='ROTOR',
                           PHENOMENE='MECANIQUE',
                           MODELISATION='POU_D_E',),
                         _F(GROUP_MA=('DISQUES'),
                           PHENOMENE='MECANIQUE',
                           MODELISATION='DIS_TR',),
                         )
                       )

ACIER=DEFI_MATERIAU(ELAS=_F(E=2.06E11,
                            NU=0.0,
                            RHO=7800.0,),);



CHMAT=AFFE_MATERIAU(MAILLAGE=MAIL,
                    AFFE=(_F(GROUP_MA='ROTOR',
                            MATER=ACIER,),))

CARELEM=AFFE_CARA_ELEM(MODELE=MODELE,
                       POUTRE=(_F(GROUP_MA='ROTOR',
                                 SECTION='CERCLE',
                                 CARA='R',
                                 VALE=(.025),),),
                        DISCRET=(
                                   _F(GROUP_MA='DISQUES',
                                     CARA='M_TR_D_N',
                                     VALE=(0.03829,3.000E-6,1.8000E-6,1.8000E-6,0.,0.,0.,0.,0.,0.),),
                                   _F(GROUP_MA='DISQUES',
                                     CARA='K_TR_D_N',
                                     VALE=(0.,0.,0.,0.,0.,0.,), ),
                                   _F(GROUP_MA='DISQUES',
                                     CARA='A_TR_D_N',
                                     VALE=(0.,0.,0.,0.,0.,0.,), )
                        )
                        )
                                 
                                 

BLOQUAGE=AFFE_CHAR_MECA(MODELE=MODELE,
                               DDL_IMPO=(
                                 _F(GROUP_NO=('PALIER_A','PALIER_B'),
                                     DX=0, DY=0, DZ=0,
                                     DRX=0,
                                     ),
                          ))
                                    

MACRO_MATR_ASSE(MODELE=MODELE,
                CHAM_MATER=CHMAT,
                CARA_ELEM=CARELEM,
                CHARGE=BLOQUAGE,
                NUME_DDL=CO('NUMEDDL'),
                MATR_ASSE=(_F(MATRICE=CO('RIGIDITE'),
                              OPTION='RIGI_MECA',),
                           _F(MATRICE=CO('MASSE'),
                              OPTION='MASS_MECA',),
                           _F(MATRICE=CO('GYASS'),
                              OPTION='MECA_GYRO',),
                           _F(MATRICE=CO('AMOR'),
                              OPTION='AMOR_MECA',),),);



######################################                    
# TEST GENERALISE REEL SYM ET NON SYM
######################################
sym='oui'
sym='non'
if (sym=='oui') :
# TEST SORENSEN + QZ + PYTHON EN GENERALISE REEL SYM
  option=1
  MATK=RIGIDITE
  MATM=MASSE
else:
# TEST SORENSEN + QZ + PYTHON EN GENERALISE REEL NON SYM
  option=2
  MATK=COMB_MATR_ASSE(COMB_R=(_F(MATR_ASSE=GYASS,    COEF_R=100.,),
                              _F(MATR_ASSE=RIGIDITE, COEF_R=1.,),))

  MATM=COMB_MATR_ASSE(COMB_R=(_F(MATR_ASSE=GYASS,    COEF_R=10.,),
                              _F(MATR_ASSE=MASSE,    COEF_R=1.,),))


# CALCUL VIA SORENSEN                          
MG_SO=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK,
                       MATR_B=MATM,
                       METHODE='SORENSEN',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10),
                        )
# CALCUL VIA QZ
MG_QZ=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK,
                       MATR_B=MATM,
                       METHODE='QZ',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10),
                        )

# CALCUL VIA PYTHON
rigF=MATK.EXTR_MATR()
masF=MATM.EXTR_MATR()

#-----------------------------------------------------#
#--                                                 --#
#-- Elimination des degres de libertes de Lagranges --#
#--                                                 --#
#--        c.f. doc R4.06.02   - section 2.5        --#
#--        + commentaires dans sdll123a.comm        --#
#--                                                 --#
#-----------------------------------------------------#

nom_nume='NUMEDDL'
Nume=aster.getvectjev(nom_nume.ljust(8)+'      .NUME.DELG        ' )
ind_lag1=[]
ind_nolag=[]

for i1 in range(len(Nume)) :
  if Nume[i1] > -0.5 :
    ind_nolag.append(i1)
  if (Nume[i1] < -0.5) & (Nume[i1] > -1.5):
    ind_lag1.append(i1)

nlag1=len(ind_lag1)
nnolag=len(ind_nolag)

Z=NP.zeros((nnolag-nlag1,nnolag))
C=NP.vstack((rigF[ind_lag1][:,ind_nolag],Z))
Q,R = NP.linalg.qr(NP.transpose(C))

dR=[]
for i1 in range(len(R)) :
  dR.append(NP.abs(R[i1,i1]))

mdR=NP.max(dR)
indz=[]
for i1 in range(len(R)) :
  if NP.abs(R[i1,i1]) <= mdR*1.e-16 :
    indz.append(i1)

mas=NP.dot(NP.transpose(Q[:][:,indz]),NP.dot(masF[ind_nolag][:,ind_nolag],Q[:][:,indz]))
rig=NP.dot(NP.transpose(Q[:][:,indz]),NP.dot(rigF[ind_nolag][:,ind_nolag],Q[:][:,indz]))

#-- Fin elimination

variante=2
# variante 1: K-1*M U = 1/lambda  * U
if (variante==1) :
  masI=LA.inv(rig)
  HPRIME=NP.dot(masI,mas)
  frequence=LA.eigvals(HPRIME)
  fr=list(frequence)
  i=0
  for vp in fr:
     i=i+1
     if (abs(vp)==0) :
       print i,'infinity'
     else       :
       vp1=(1/vp)
       if (sym=='oui') :
         vp1r=NP.sqrt(abs(vp1))/2/NP.pi
         print i,vp1r
       else :
         vp1r=NP.sqrt(abs(vp1.real))/2/NP.pi
         vp1i=0.5*vp1.imag/vp1.real
         print i,vp1r,vp1i

else :
# variante 2 : M-1*K U = lambda * U
  masI=LA.inv(mas)
  HPRIME=NP.dot(masI,rig)
  frequence=LA.eigvals(HPRIME)
  fr=list(frequence)
  i=0
  for vp in fr:
     i=i+1
     if (abs(vp)==0) :
       print i,'zero'
     else       :
       vp1=vp
       if (sym=='oui') :
         vp1r=sqrt(abs(vp1))/2/pi
         print i,vp1r
       else :
         vp1r=sqrt(abs(vp1.real))/2/pi
         vp1i=0.5*vp1.imag/vp1.real
         print i,vp1r,vp1i

TEST_RESU(RESU=(
# POUR SORENSEN
          _F( RESULTAT = MG_SO, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.2414153990951E+02,REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_SO, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.8933070326089E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_SO, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 4.9260572017935E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_SO, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 7.6259398235487E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_SO, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 9,  VALE = 2.019974939820E+03, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_SO, PARA = 'AMOR_REDUIT',
                CRITERE = 'ABSOLU', PRECISION = 1.E-4,
                NUME_ORDRE = 9,  VALE = 0.0E+00, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
# POUR QZ
          _F( RESULTAT = MG_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.2414153991024E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.8933070322205E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 4.9260572017924E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 7.6259398235344E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 9,  VALE = 2.019974939820E+03, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MG_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'ABSOLU', PRECISION = 1.E-4,
                NUME_ORDRE = 9,  VALE = 0.0E+00, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
            ),)
######################################                    
# TEST QUADRATIQUE REEL SYM ET NON SYM
######################################
sym='oui'
sym='non'
if (sym=='oui') :
# TEST SORENSEN + QZ + PYTHON EN QUADRATIQUE REEL SYM
  option=1
  MATK1=RIGIDITE
  MATM1=MASSE
  MATC1=GYASS
else:
# TEST SORENSEN + QZ + PYTHON EN QUADRATIQUE REEL NON SYM
  option=2
  MATK1=COMB_MATR_ASSE(COMB_R=(_F(MATR_ASSE=GYASS,    COEF_R=100.,),
                              _F(MATR_ASSE=RIGIDITE, COEF_R=1.,),))

  MATM1=COMB_MATR_ASSE(COMB_R=(_F(MATR_ASSE=GYASS,    COEF_R=10.,),
                              _F(MATR_ASSE=MASSE,    COEF_R=1.,),))
  MATC1=GYASS

# CALCUL VIA SORENSEN (APPROCHE COMPLEXE, REELLE ET IMAGINAIRE)
MQ_SO=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK1,
                       MATR_B=MATM1,
                       MATR_C=MATC1,
                       METHODE='SORENSEN',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10,
                       APPROCHE='COMPLEXE',),
                        )
MQ_SOR=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK1,
                       MATR_B=MATM1,
                       MATR_C=MATC1,
                       METHODE='SORENSEN',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10,
                       APPROCHE='REEL',),
                       VERI_MODE=_F(SEUIL=1.E-04),
                        )
MQ_SOI=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK1,
                       MATR_B=MATM1,
                       MATR_C=MATC1,
                       METHODE='SORENSEN',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10,
                       APPROCHE='IMAG',),
                        )                                                     
# CALCUL VIA QZ
MQ_QZ=MODE_ITER_SIMULT( INFO=1,
                       MATR_A=MATK1,
                       MATR_B=MATM1,
                       MATR_C=MATC1,
                       METHODE='QZ',
                       CALC_FREQ=_F(OPTION='CENTRE',FREQ=1000.,NMAX_FREQ=10,),
                       VERI_MODE=_F(SEUIL=1.E-04),
                        )

# CALCUL VIA PYTHON
rigF=MATK1.EXTR_MATR()
masF=MATM1.EXTR_MATR()
amorF=MATC1.EXTR_MATR()

#-----------------------------------------------------#
#--                                                 --#
#-- Elimination des degres de libertes de Lagranges --#
#--                                                 --#
#-----------------------------------------------------#

nom_nume='NUMEDDL'
Nume=aster.getvectjev(nom_nume.ljust(8)+'      .NUME.DELG        ' )
ind_lag1=[]
ind_nolag=[]

for i1 in range(len(Nume)) :
  if Nume[i1] > -0.5 :
    ind_nolag.append(i1)
  if (Nume[i1] < -0.5) & (Nume[i1] > -1.5):
    ind_lag1.append(i1)

nlag1=len(ind_lag1)
nnolag=len(ind_nolag)

Z=NP.zeros((nnolag-nlag1,nnolag))
C=NP.vstack((rigF[ind_lag1][:,ind_nolag],Z))
Q,R = NP.linalg.qr(NP.transpose(C))

dR=[]
for i1 in range(len(R)) :
  dR.append(NP.abs(R[i1,i1]))

mdR=NP.max(dR)
indz=[]
for i1 in range(len(R)) :
  if NP.abs(R[i1,i1]) <= mdR*1.e-16 :
    indz.append(i1)

mas=NP.dot(NP.transpose(Q[:][:,indz]),NP.dot(masF[ind_nolag][:,ind_nolag],Q[:][:,indz]))
rig=NP.dot(NP.transpose(Q[:][:,indz]),NP.dot(rigF[ind_nolag][:,ind_nolag],Q[:][:,indz]))
amor=NP.dot(NP.transpose(Q[:][:,indz]),NP.dot(amorF[ind_nolag][:,ind_nolag],Q[:][:,indz]))

#-- Fin elimination

variante=1
if (variante==1) :
  masI=LA.inv(mas)
  HPRIME=NP.zeros((nddl*2,nddl*2))
  HPRIME[0:nddl,0:nddl]=NP.dot(amor,masI)
  HPRIME[0:nddl,nddl:2*nddl]=NP.dot(rig,masI)
  HPRIME[nddl:2*nddl,0:nddl]=-NP.identity(nddl)
  frequence=LA.eigvals(HPRIME)
  fr=list(frequence)
  i=0
  for vp in fr:
     i=i+1
     if (abs(vp)==0) :
       print i,'zero'
     else       :       
       vp1r=vp.real
       vp1i=vp.imag/2/pi
       print i,vp1i,-vp1r/abs(vp)

aster.matfpe(+1)

TEST_RESU(RESU=(
# POUR SORENSEN APPROCHE COMPLEXE
          _F( RESULTAT = MQ_SO, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.2416347900468E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SO, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.8922853711594E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SO, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 4.9402662017179E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SO, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 7.5603808282835E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
# POUR SORENSEN APPROCHE REELLE
          _F( RESULTAT = MQ_SOR, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 4.9402662040152E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOR, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 7.5603807827126E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOR, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 1.0732061056200E+03, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOR, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 1.6349405212033E-01, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
# POUR SORENSEN APPROCHE IMAGINAIRE
          _F( RESULTAT = MQ_SOI, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 4.9402662017181E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOI, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 7.5603808282853E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOI, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 1.0732061057100E+03, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_SOI, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 1.6349405220253E-01, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
# POUR QZ
          _F( RESULTAT = MQ_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.2416347940866E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 1,  VALE = 1.8922850338749E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 4.9402661647037E+02, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 3,  VALE = 7.5603827111568E-02, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_QZ, PARA = 'FREQ',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 10,  VALE = 2.4598045634288E+03, REFERENCE='NON_REGRESSION',),
          _F( RESULTAT = MQ_QZ, PARA = 'AMOR_REDUIT',
                CRITERE = 'RELATIF', PRECISION = 1.E-6,
                NUME_ORDRE = 10,  VALE = 3.7000877864494E-01, VALE_ABS = 'OUI', REFERENCE='NON_REGRESSION',),
                ),)
FIN()

