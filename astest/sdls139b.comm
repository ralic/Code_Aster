# MODIF  DATE 03/11/2008   AUTEUR BODEL C.BODEL 
# TITRE IDENTIFICATION D EFFORTS FLUIDES SUR UNE STRUCTURE FILAIRE
# sdls139b.para = tps_job 600 mem_job 512Mo mem_aster 40 ncpus 1 liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2008  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

DEBUT( CODE = _F( NOM = 'SDLS139B',
                  NIV_PUB_WEB = 'INTRANET',
                  VISU_EFICAS = 'NON',),
     );


#***************************************************************************************#
#                                                                                       #
#      CREATION DU MODELE NUMERIQUE DE BASE : UN CRAYON COMBUSTIBLE ACCROCHE AU         #
#       NIVEAU DES GRILLE A UN GUIDE REPRESENTANT L'INERTIE DES AUTRES CRAYONS          #
#                                                                                       #
#***************************************************************************************#

#==================================
#IMPORTATION DU MAILLAGE DE MESURES
#==================================

MAINUM=LIRE_MAILLAGE(FORMAT='ASTER',UNITE=20);

MAINUM = DEFI_GROUP( reuse = MAINUM, MAILLAGE = MAINUM,
                     CREA_GROUP_NO = _F( NOM = 'GRILLES', NOEUD = ('N12','N28','N52','N68'),),);


#=================================================
#AFFECTATION DES PROPRIETES AU MODELE ELEMTS FINIS
#=================================================

MODELNUM = AFFE_MODELE( MAILLAGE = MAINUM,
                        VERIF = 'MAILLE',
                        AFFE = ( _F( GROUP_NO = ( 'GRILLES'),
                                     PHENOMENE='MECANIQUE',
                                     MODELISATION='DIS_TR',),
                                 _F( GROUP_MA = ('MCRAY',),
                                     PHENOMENE = 'MECANIQUE',
                                     MODELISATION = 'POU_D_T',),),);



MATCRAY = DEFI_MATERIAU( ELAS = _F( E = 9.84E10,
                                    NU = 0.3,
                                    RHO = 1.581E4,
                                   ),);


CARANUM = AFFE_CARA_ELEM( MODELE=MODELNUM,
                          POUTRE = _F( GROUP_MA = 'MCRAY',
                                       SECTION = 'CERCLE',
                                       CARA = ('EP','R',),
                                       VALE = (0.0005,0.0095,),),
                          DISCRET = _F( GROUP_NO = ('GRILLES',),
                                        CARA = 'K_TR_D_N',
                                        VALE = (1000000.0,1000000.0,1000000.0,100.0,100.0,100.0),),);

MATNUM = AFFE_MATERIAU( MAILLAGE = MAINUM,
                        MODELE=MODELNUM,
                        AFFE = _F( GROUP_MA = 'MCRAY',
                                   MATER = MATCRAY,),);

#==================================
#CONDITIONS LIMITES DE LA STRUCTURE 
#==================================

# Blocage des DDL : on etudie le mouvement de la poutre que dans la
# direction DX. On empeche aussi la torsion
CL = AFFE_CHAR_MECA( MODELE = MODELNUM,
                     DDL_IMPO = ( _F( NOEUD = ('N1','N2',),
                                      DX=0.0,
                                      DY=0.0,
                                      DZ=0.0,
                                      DRX=0.0,
                                      DRY=0.0,
                                      DRZ=0.0,),
                                  _F( GROUP_NO = 'NCRAY',
                                      DZ=0.0,
                                      DRX=0.0,
                                      DRY=0.0,
                               ),),);


#===========================================================================                
#CONSTRUCTION ET ASSEMBLAGE DES MATRICES ET VECTEURS ELEMENTAIRES ET GLOBAUX
#===========================================================================


KELNUM=CALC_MATR_ELEM(OPTION='RIGI_MECA',
                      MODELE=MODELNUM,
                      CHAM_MATER=MATNUM,
                      CARA_ELEM=CARANUM,
                      CHARGE=CL,);

MELNUM=CALC_MATR_ELEM(OPTION='MASS_MECA',
                      MODELE=MODELNUM,
                      CHAM_MATER=MATNUM,
                      CARA_ELEM=CARANUM,
                      CHARGE=CL,);

NUMENUM=NUME_DDL(MATR_RIGI=KELNUM,);

KASNUM=ASSE_MATRICE(MATR_ELEM=KELNUM,
                    NUME_DDL=NUMENUM,);

MASNUM=ASSE_MATRICE(MATR_ELEM=MELNUM,
                    NUME_DDL=NUMENUM,);


#=============================================                
#ANALYSE MODALE EN AIR, NORMALISATION EN MASSE
#=============================================

##MODEAIR1 est utilise pour  CALC_FLU_STRU uniquement
#MODEAIR1 = MODE_ITER_SIMULT( MATR_A = KASNUM,
#                             MATR_B = MASNUM,
#                             METHODE = 'SORENSEN',
#                             TYPE_RESU = 'DYNAMIQUE',
#                             OPTION = 'SANS',
#                             CALC_FREQ = _F(
#                                             OPTION='PLUS_PETITE',
#                                             APPROCHE='REEL',
#                                             NMAX_FREQ=15,
#                                             SEUIL_FREQ=10.0,
#                                            ),
#                             VERI_MODE = _F( STOP_ERREUR = 'NON',
#                                             SEUIL = 1e-03,),);
#
#
#MODEAIR1 = NORM_MODE( reuse = MODEAIR1,
#                      MODE = MODEAIR1,
#                      NORME = 'MASS_GENE',)
#
#
#
# MODEAIR = MODEAIR1 avec des amortissements modaux en plus
MODEAIR = LIRE_RESU(TYPE_RESU='MODE_MECA',
                    FORMAT='IDEAS',
                    MODELE=MODELNUM,
                    UNITE=30,
                    NOM_CHAM='DEPL',
                    MATR_A =KASNUM,
                    MATR_B =MASNUM,
                    FORMAT_IDEAS=_F(NOM_CHAM='DEPL',
                                    NUME_DATASET=55,
                                    RECORD_6=(1,2,3,8,2,6,),
                                    POSI_ORDRE=(7,4,),
                                    POSI_NUME_MODE=(7,4),
                                    POSI_FREQ=(8,1,),
                                    POSI_MASS_GENE=(8,2),
                                    POSI_AMOR_GENE=(8,3),
                                    NOM_CMP=('DX','DY','DZ','DRX','DRY','DRZ'),
                                    ),
                    TOUT_ORDRE='OUI',
                    )



##=============================================                           
##COUPLAGE AVEC LE FLUIDE SOUS ECOULEMENT AXIAL
##=============================================
##les parametres definis sont supposes constants le long du crayon
#
#rhoEXT = FORMULE( VALE = '1000', NOM_PARA='X',);
#
#rhoINT = FORMULE( VALE = '1000', NOM_PARA='X',);
#
#visc = FORMULE( VALE = '0.00001', NOM_PARA='X',);
#
#profilV = FORMULE( VALE = '100', NOM_PARA='X',);
#
#FLUX1 = DEFI_FLUI_STRU( FAISCEAU_AXIAL=_F( GROUP_MA = 'MCRAY',
#                                           VECT_X = (0.00000000E+0,1.0,0.00000000E+0,),
#                                           PROF_RHO_FLUI = rhoEXT,
#                                           PROF_VISC_CINE = visc,
#                                           RAYON_TUBE = 4.75E-03,
#                                           COOR_TUBE = (0.00000000E+0,0.00000000E+0,),
#                                           RUGO_TUBE = 1.E-5,
#                                           CARA_PAROI = ('YC','ZC','HY','HZ',),
#                                           VALE_PAROI = (0.00000000E+0,0.00000000E+0,10.0,10.0,),
#                                           ANGL_VRIL = 0.00000000E+0,),
#                        INFO=1,);
#
#CALC1 = CALC_FLUI_STRU( VITE_FLUI = _F( VITE_MIN = 0.0,
#                                        VITE_MAX = 50.0,
#                                        NB_POIN = 2,),
#                        BASE_MODALE = _F( MODE_MECA = MODEAIR1,
#                                          NUME_ORDRE = (1,2,3,4,5,6,7,8,9,10,11,12),
#                                          AMOR_UNIF = 0.020000000E+0,),
#                        TYPE_FLUI_STRU = FLUX1,
#                       );
#
#
#
##==============================================                           
##CONSTRUCTION D UNE BASE MODALE SOUS ECOULEMENT
##==============================================
## On fabrique deux bases modales : une au repos, 
## une en ecoulement
#
## Base modale en eau au repos
#MODFLURt = MODI_BASE_MODALE( BASE = MODEAIR1,
#                             BASE_ELAS_FLUI = CALC1,
#                             NUME_VITE_FLUI = 1,);
#
## Base modale en ecoulement, V= 10 m/s
#MODFLUEt = MODI_BASE_MODALE( BASE = MODEAIR1,
#                             BASE_ELAS_FLUI = CALC1,
#                             NUME_VITE_FLUI = 2,);
#
## Normalisation
#MODFLURE=NORM_MODE(MODE=MODFLURt,
#                   NORME='MASS_GENE',)
#
#MODFLUEC=NORM_MODE(MODE=MODFLUEt,
#                   NORME='MASS_GENE',)
#
#
#DETRUIRE(CONCEPT=_F(NOM=(MODFLURt,MODFLUEt,MODEAIR1)), INFO=1)



#*************************************************************#
#                                                             #
#  SIMULATION D'UN EFFORT APPLIQUE EN UN POINT DU TUBE :      #
#  SPECTRE INSIPRE DE LA DOC R4.07.02 SUR LA DEFINITION DES   #
#   SPECTRES D'EFFORTS TURBULENTS                             #
#                                                             #
#*************************************************************#

# fonction python
def spectr(freq):
    beta = 8
    eps = 0.7
    fc= 20
    return 1./((1-(freq/fc)**beta/2)**2+4*eps**2*(freq/fc)**beta/2)

liste = DEFI_LIST_REEL( DEBUT = 0.0,
                        INTERVALLE = _F( JUSQU_A = 60.0,
                                         PAS     = 1),);


tmp1 = FORMULE( NOM_PARA = 'FREQ',
                VALE     = 'spectr(FREQ)')

tmp2 = CALC_FONC_INTERP( FONCTION  = tmp1,
                         LIST_PARA = liste,
                         NOM_PARA  = 'FREQ',);


FONC1 = CALC_FONCTION( COMB_C = _F( FONCTION = tmp2 , COEF_C= 2.0E12*complex(1,0)) )



INTESP = DEFI_INTE_SPEC( DIMENSION = 1,
                         PAR_FONCTION = _F( NUME_ORDRE_I = 1, NUME_ORDRE_J = 1, FONCTION = FONC1));


#=========================================                                  
# CALCUL DES INTER-SPECTRES DE DEPLACEMENT 
#=========================================


DYN = DYNA_ALEA_MODAL( BASE_MODALE = _F( MODE_MECA = MODEAIR,
                                         BANDE = (0.0,60.0,),
                                         AMOR_UNIF = 0.02,),
                       EXCIT = _F( INTE_SPEC = INTESP,
                                   NUME_ORDRE_I = 1,
                                   NUME_ORDRE_J = 1,
                                   NOEUD = 'N60',
                                   NOM_CMP = 'DX',
                                   GRANDEUR = 'EFFO',),
                      );


# Restitution de la mesure sur 19 capteurs

#capteurs = ('N1','N2','N8','N12','N16','N20','N24','N28','N32','N36',
#            'N40','N44','N48','N52','N56','N60','N64','N68','N72')

# Restitution de la mesure sur 1 capteurs
capteurs = ('N40')

nb_capt = len(capteurs)
print "nb_capt = ",nb_capt 

nb_fonc = nb_capt*(nb_capt + 1)/2
cmp = tuple(['DX']*nb_capt)
print "cmp = ", cmp
SPECTR1 = REST_SPEC_PHYS( MODE_MECA = MODEAIR,
                           BANDE = (0.0,60.0,),
                           INTE_SPEC_GENE = DYN,
                           NOEUD = capteurs,
                           NOM_CMP = ('DX'),
                           NOM_CHAM = 'DEPL',
                           OPTION = 'TOUT_TOUT',);
       


DETRUIRE(CONCEPT=_F(NOM=(DYN,INTESP)), INFO=1)

## Phase de verification : on verifie que les inter-spectres resultats sont 
## sont bien un mouvement sur un mode (le premier).
#IMPR_TABLE( TABLE = SPECTR19, UNITE = 8)
#FONC = [None]*nb_fonc
#ind = 0
#for jj in range(nb_capt):
#    for ii in range(jj+1):
#        FONC[ind] = RECU_FONCTION( TABLE = SPECTR19,
#                                   NOM_PARA_TABL = 'FONCTION_C', 
#                                   FILTRE = (_F( NOM_PARA = 'NOEUD_I',
#                                                 VALE_K = capteurs[ii] ),
#                                             _F( NOM_PARA = 'NOEUD_J',
#                                                 VALE_K = capteurs[jj] )))
#
#        IMPR_FONCTION ( FORMAT = 'XMGRACE',
#                        PILOTE = 'INTERACTIF',
#                        COURBE = _F( FONCTION = FONC[ind] ))
          
       
#***************************************************************************************
#
#                CREATION DU MODELE EXPERIMENTAL - MODES EXPERIMENTAUX
#
#***************************************************************************************


MAIEXP=CREA_MAILLAGE(MAILLAGE=MAINUM,
                     CREA_POI1=_F(NOM_GROUP_MA='CAPTEURS',
                                  NOEUD=('N40',),
                                  ),);


MODELEXP=AFFE_MODELE(MAILLAGE=MAIEXP,
                     AFFE=_F(GROUP_MA='CAPTEURS',
                             PHENOMENE='MECANIQUE',
                             MODELISATION='DIS_T',),);

CAREXP=AFFE_CARA_ELEM(MODELE=MODELEXP,
                      DISCRET=_F(GROUP_MA='CAPTEURS',
                                 REPERE='GLOBAL',
                                 CARA='K_T_D_N',
                                 VALE=(1000.0,1000.0,1000.0,),
                      ),);

MATEXP=AFFE_MATERIAU(MAILLAGE=MAIEXP,
                     MODELE=MODELEXP,
                     AFFE=_F(TOUT='OUI',
                             MATER=MATCRAY,),);

KELEXP=CALC_MATR_ELEM(OPTION     = 'RIGI_MECA',
                      MODELE     = MODELEXP,
                      CHAM_MATER = MATEXP,
                      CARA_ELEM  = CAREXP,);

# la fabrication du NUME_DDL est obligatoire pour fabriquer le concept "observe"
# (avec la macro OBSERVATION, en interactif ou non interactif).
# Amelioration possible : les etapes CAREXP, MATEXP et KELEXP pourraient etre 
# effectuees automatiquement pour un modele experimental...
NUMEXP=NUME_DDL(MATR_RIGI = KELEXP,);



OBS = OBSERVATION( RESULTAT = MODEAIR,
                   MODELE_1 = MODELNUM,
                   MODELE_2 = MODELEXP,
                   PROJECTION = 'OUI',
                   TOUT_ORDRE = 'OUI',
                   NUME_DDL = NUMEXP,
                   NOM_CHAM = 'DEPL',
                   FILTRE = _F( GROUP_MA = 'CAPTEURS',
                                DDL_ACTIF = ('DX')
                           ),
                  );



interactif = 0
if interactif:
# Pour lancer Meidee en interactif, on peut ecrire :
    CALC_ESSAI( INTERACTIF = 'OUI',
                RESU_TURBULENT = _F(FONCTION = CO("FONC_S0")),
               );

else:
    CALC_ESSAI( INTERACTIF = 'NON',
                MEIDEE_TURBULENT = _F( INTE_SPEC = SPECTR1,
                                       NUME_MODE_DECONV = (1,),
                                       NUME_MODE_LOCAL = (2,3),
                                       BASE = MODEAIR,
                                       MESURE = OBS),               
                RESU_TURBULENT  = _F(FONCTION = CO("FONC_S0"))
               );


NORM = INFO_FONCTION( RMS= _F(FONCTION = FONC_S0))

vale_refe = 7.055156E+15

TEST_TABLE( TABLE     = NORM,
            NOM_PARA  = 'RMS',
            TYPE_TEST = 'MAX',
            VALE      = vale_refe,
            PRECISION = 0.2,
            REFERENCE = 'NON_REGRESSION')


FIN();
