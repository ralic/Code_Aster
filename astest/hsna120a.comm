# MODIF  DATE 24/10/2006   AUTEUR PABHHHH N.TARDIEU 
# TITRE Propagation d'un reseau de fissures en fatigue thermomecanique 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

#############################################################################
#       Test de modelisation de la propagation d'un reseau de fissures
#       en fatigue thermomecanique  
#       Les longueurs initiales des fissures : 
#           F1=0.98, F2=0.70, F3=0.08, F4=0.69
#       M.SEYEDI    15/04/03
#       Calcul de KI se fait en utilisant la methode d'extrapolation de 
#       sauts de deplacements (la commande POST_K1_K2_K3)
#       Chargement thermique : T varie entre 20 et 120 C
#       Contrainte moyenne : 60 MPa, constante dans l'epaisseur
#        

DEBUT ( CODE=_F( NOM = 'HSNA120A',
        NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),
        PAR_LOT='NON' ) ;
#
#############################################################################

import os
import string
import copy
import aster
#

chemin_outils=aster.repout()
gmsh=chemin_outils+'gmsh'

#  Fichiers de maillages
#
old_mesh = open('fort.60','r')
ini_mesh = old_mesh.readlines()
old_mesh.close()
#
#  Fichier de sortie
#
results = open('fort.80','w')
#
LIST=DEFI_LIST_REEL(INTERVALLE=(_F(JUSQU_A=10.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=20.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=30.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=40.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=50.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=60.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=70.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=80.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=90.0,
                                   NOMBRE=10,),
                                _F(JUSQU_A=100.0,
                                   NOMBRE=10,)),
                    DEBUT=0.0,);
#

TEP_F = FORMULE(NOM_PARA='INST',
                VALE='(70.-50.*cos((pi/5.)*INST)) ')

TEMP_F=CALC_FONC_INTERP(FONCTION=TEP_F,    LIST_PARA=LIST,
                           NOM_PARA='INST',
                           NOM_RESU='TEMP',
                           PROL_GAUCHE='EXCLU',  PROL_DROITE='EXCLU',
                           INTERPOL='LIN', 
                               )

#
# 1. Initialisations
#
#   nb_cycles_total = nombre total de cycles de chargement.
#
#   nb_calc_total = nombre total des etapes de calcul.
#
#   nb_de_fissures = nombre de fissures.
#                         La premiere fissure est numerotee 0, le dernier nb_position_du_fond-1.
#   num_fiss               = Numero de la fissure
#
#
nb_de_fissures = 4
#
nb_cycles_total = 10**8
#
nb_calc_total = 3
#
nb_mail_total = 0
#
#
nb_calc_total_plus_1 =nb_calc_total  + 1
#
nb_de_fissures_plus_1 =nb_de_fissures  + 1
#
MAIL    = [None]*nb_calc_total_plus_1
MAI1    = [None]*nb_calc_total_plus_1
MOD_G   = [None]*nb_calc_total_plus_1
MATER   = [None]*nb_calc_total_plus_1
CHAR1   = [None]*nb_calc_total_plus_1
CONT   = [None]*nb_calc_total_plus_1
CHARM   = [None]*nb_calc_total_plus_1
CHART   = [None]*nb_calc_total_plus_1
RESU    = [None]*nb_calc_total_plus_1
REPR    = [None]*nb_calc_total_plus_1
CHPR    = [None]*nb_calc_total_plus_1
NETAP   = [None]*nb_calc_total_plus_1
longa   = [None]*nb_calc_total_plus_1
MOTH    = [None]*nb_calc_total_plus_1
CMTH    = [None]*nb_calc_total_plus_1
CHTH    = [None]*nb_calc_total_plus_1
TEMPT   = [None]*nb_calc_total_plus_1
#############################################################################
F       = [None]*nb_de_fissures_plus_1
levt    = [None]*nb_de_fissures_plus_1
levb    = [None]*nb_de_fissures_plus_1
#############################################################################
#        On introduit toutes les variables a deux parametres dans un vecteur
#        pour Aster
AK1     = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
AK2     = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
LEVS    = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
LEVI    = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
DEPT    = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
DEPB    = [None]*nb_calc_total_plus_1*nb_de_fissures_plus_1
#        Variables a deux parametres
#
import Numeric
T      =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
K1_min =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
K1_max =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
K2_min =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
K2_max =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
KI1    =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
KI2    =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
DELTAK =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
NCYCL  =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
DELTA  =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
R      =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
Kmin   =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
Kmax   =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
gdr    =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
KEFF   =Numeric.zeros([nb_de_fissures_plus_1,nb_calc_total_plus_1],Numeric.Float)
#       
#############################################################################
#       
# 2. Definitions generales
#
#
LIST_BD=DEFI_LIST_REEL(INTERVALLE=_F(JUSQU_A=1.0,
                                     NOMBRE=1,),
                       DEBUT=0.0,);
#
# 2.1 Materiau
#
#
#              Proprietes thermiques
# rho=8E-6 Kg/mm3

AC_THER = DEFI_MATERIAU ( THER      = _F( RHO_CP     = 1.8E-3, 
                                     LAMBDA = 14.0E-3,),);    # W/mm C

ACIER=DEFI_MATERIAU(ELAS=_F(NU=0.3,
                            ALPHA=1.5E-05,
                            E=2.10000E5,),);
#
# 2.2.1 La loi de Paris
#
COEFC=9.34E-4
COEFM=2.5575
KIC=65.83
KTH=4.
MR=0.37
#
# 2.2.2 Increment de propagation de fissures
#
DELTA0 = 0.1
#
#
# 2.2.3 Longueurs des fissures
#

lnga = [0., 0.68, 0.70, 0.08, 0.69]


#############################################################################
# 3. Boucle avec l indice num_calc sur les nb_aclc_total qui montre 
#   le nombre total des etapes de calcul
#############################################################################
cycle_passe = 0
#
for num_calc in range(1,nb_calc_total_plus_1) :
#
#
#
   if num_calc == 1 :
      os.system ('cp fort.60 mesh.geo')
      os.system (gmsh+' -2  -algo aniso mesh.geo -o fort.19')

   PRE_GMSH()

   MAI1[num_calc]=LIRE_MAILLAGE()

   MAIL[num_calc]=CREA_MAILLAGE( MAILLAGE  = MAI1[num_calc],
                    LINE_QUAD = _F(TOUT='OUI'))

#
#              Definition des groupes de noeuds
#                                  
   MAIL[num_calc]=DEFI_GROUP(reuse =MAIL[num_calc],
                CREA_GROUP_NO=(_F(GROUP_MA='GM61',
                                  NOM='F1',),
                               _F(GROUP_MA=('GM62'),
                                  NOM='F2',),
                               _F(GROUP_MA=('GM63'),
                                  NOM='F3',),
                               _F(GROUP_MA=('GM64'),
                                  NOM='F4',),
                               _F(GROUP_MA=('GM59'),
                                  NOM='PDX',),
                                  ),
                MAILLAGE=MAIL[num_calc],);
#
#
#              Definition des groupes de mailles
#                                  

   MAIL[num_calc]=DEFI_GROUP(reuse =MAIL[num_calc],
                CREA_GROUP_MA=(_F(GROUP_MA='GM84',
                                  NOM='top',),
                               _F(GROUP_MA='GM81',
                                  NOM='bot',),
                               _F(UNION=('GM39', 'GM40', 'GM45'
                               ,'GM50', 'GM55', 'GM80', 'GM85'),
                                  NOM='hot',),
                               _F(UNION=('GM37', 'GM43', 'GM48'
                               ,'GM53', 'GM57', 'GM82', 'GM83'),
                                  NOM='cold',),),
                MAILLAGE=MAIL[num_calc],);

#
#             Definition des levres des fissures
#                                  

   MAIL[num_calc]=DEFI_GROUP(reuse =MAIL[num_calc],
#
#              La levre superieure des fissures 
#                                  
                CREA_GROUP_MA=(_F(GROUP_MA='GM35',
                                  NOM='levt1',),
                               _F(GROUP_MA='GM41', 
                                  NOM='levt2',),
                               _F(GROUP_MA='GM46', 
                                  NOM='levt3',),
                               _F(GROUP_MA='GM51',
                                  NOM='levt4',),
#
#              La levre inferieure des fissures 
#                                  
                               _F(GROUP_MA='GM44',
                                  NOM='levb1',),
                               _F(GROUP_MA='GM49',
                                  NOM='levb2',),
                               _F(GROUP_MA='GM54',
                                  NOM='levb3',),
                               _F(GROUP_MA='GM58',
                                  NOM='levb4',),),
                MAILLAGE=MAIL[num_calc],);
#
#
   MAIL[num_calc]=DEFI_GROUP(reuse =MAIL[num_calc],
                CREA_GROUP_MA=_F(UNION=('GM35','GM36', 'GM37',
                'GM38', 'GM39','GM40', 'GM41', 'GM42',
                'GM43', 'GM44','GM45', 'GM46','GM47', 'GM48',
                'GM49', 'GM50','GM51','GM52','GM53','GM54',
                'GM55', 'GM56','GM57','GM58','GM65','GM66',
                'GM67','GM68','GM69','GM80','GM81','GM82','GM83',
                'GM84','GM85','levt1','levt2','levt3','levt4'
                ,'levb1','levb2','levb3','levb4',),
                                 NOM='PLAQUE',),
                MAILLAGE=MAIL[num_calc],);

#
# -------------------------------------------------------------- #
#                       DEBUT DU THERMIQUE                       #
# -------------------------------------------------------------- #

   MOTH[num_calc] = AFFE_MODELE ( MAILLAGE    =   MAIL[num_calc],
                     AFFE        = _F( TOUT         = 'OUI',
                                       PHENOMENE    = 'THERMIQUE',
                                       MODELISATION = 'AXIS',), );

   CMTH[num_calc] = AFFE_MATERIAU ( MAILLAGE    = MAIL[num_calc],
                       AFFE        = _F( TOUT  = 'OUI',
                                         MATER = AC_THER ,), );

   CHTH[num_calc] = AFFE_CHAR_THER_F( MODELE     = MOTH[num_calc],
                       TEMP_IMPO  = _F(GROUP_MA = 'hot',
                                       TEMP = TEMP_F, ),
                        );


   TEMPT[num_calc]=THER_LINEAIRE(   MODELE = MOTH[num_calc],
                     CHAM_MATER = CMTH[num_calc],
                     EXCIT = _F(CHARGE = CHTH[num_calc],),
                     TEMP_INIT = _F( VALE = 20.,),                               
                     INCREMENT = _F( LIST_INST = LIST, NUME_FIN = 100),
                     );
                     
                     
# -------------------------------------------------------------- #
#                       FIN DU THERMIQUE                         #
# -------------------------------------------------------------- #
#
# 3.1. Variables associes au maillage
#
#
# 3.1.1. Les modeles
#
#
   MOD_G[num_calc]=AFFE_MODELE(AFFE=_F(#GROUP_MA='PLAQUE',
                             TOUT='OUI',
                          PHENOMENE='MECANIQUE',
                          MODELISATION='AXIS',),
                          MAILLAGE=MAIL[num_calc],);
#
# 3.1.2 Mise en place des materiaux
#
   MATER[num_calc]=AFFE_MATERIAU(AFFE=_F(MATER=ACIER,
                             TOUT='OUI',
                             TEMP_REF=20.,),
#                             GROUP_MA='PLAQUE',),
                             MAILLAGE=MAIL[num_calc],);
#
# 3.1.3 Chargements
#
   CHAR1[num_calc]=AFFE_CHAR_MECA(DDL_IMPO=(_F(DY=0.0,
                                  GROUP_MA='bot',),
                               _F(DX=0.0,
                                  GROUP_NO='PDX',),
                                  ),
                     MODELE=MOD_G[num_calc],
                                 );
#
   CONT[num_calc]=AFFE_CHAR_MECA(MODELE=MOD_G[num_calc],
                     CONTACT=(_F(GROUP_MA_MAIT='levt1',
                                 SANS_GROUP_NO='F1',
                                 APPARIEMENT='MAIT_ESCL',
                                 GROUP_MA_ESCL='levb1',
                                 ),
                              _F(GROUP_MA_MAIT='levt2',
                                 SANS_GROUP_NO=('F2'),
                                 APPARIEMENT='MAIT_ESCL',
                                 GROUP_MA_ESCL='levb2',
                                 ),
                              _F(GROUP_MA_MAIT='levt3',
                                 SANS_GROUP_NO=('F3'),
                                 APPARIEMENT='MAIT_ESCL',
                                 GROUP_MA_ESCL='levb3',
                                 ),
                              _F(GROUP_MA_MAIT='levt4',
                                 SANS_GROUP_NO=('F4'),
                                 APPARIEMENT='MAIT_ESCL',
                                 GROUP_MA_ESCL='levb4',
                                 ),
                                 ),
                                 );
#
   CHARM[num_calc]=AFFE_CHAR_MECA(MODELE=MOD_G[num_calc],
                       FORCE_CONTOUR=(_F(GROUP_MA='top',
                                         FY=60.,)),
                                         );

   CHART[num_calc]=AFFE_CHAR_MECA(MODELE=MOD_G[num_calc],
                       TEMP_CALCULEE = TEMPT[num_calc],
                                         );

#
# 3.2 RESOLUTION
#
#
#
   RESU[num_calc]=STAT_NON_LINE(CHAM_MATER=MATER[num_calc],
                   MODELE=MOD_G[num_calc],
                   CONVERGENCE=_F(ITER_GLOB_MAXI=30,
                                  RESI_GLOB_RELA=1.E-06,),
                   COMP_INCR=_F(RELATION='ELAS',PARM_THETA=0.57,),
                   INCREMENT=_F(#NUME_INST_INIT=1,
                                LIST_INST=LIST,
                                NUME_INST_FIN =100),
                   NEWTON=_F(REAC_INCR=0,
                             MATRICE='TANGENTE',),
                   EXCIT=(_F(CHARGE=CHAR1[num_calc],),
                          _F(CHARGE=CONT[num_calc],),
                          _F(CHARGE=CHARM[num_calc],),
                          _F(CHARGE=CHART[num_calc],),),
                   ARCHIVAGE=_F(INST=(90,95,100)),
                           );
#
# 5.2.6. CALCULS COMPLEMENTAIRES
#
   RESU[num_calc]=CALC_ELEM(reuse =RESU[num_calc],
               RESULTAT=RESU[num_calc],
               CHAM_MATER=MATER[num_calc],
               MODELE=MOD_G[num_calc],
               OPTION=('SIEF_ELNO_ELGA','EQUI_ELNO_SIGM'),
               TOUT_ORDRE='OUI',);
#
   RESU[num_calc]=CALC_NO(reuse =RESU[num_calc],
             RESULTAT=RESU[num_calc],
             CHAM_MATER=MATER[num_calc],
             OPTION=('SIEF_NOEU_ELGA'),
             TOUT_ORDRE='OUI',);

#      
# 4. CALCUL DE LA FISSURE
#
# 4.1. On boucle sur toutes les fissures pour trouver la valeur de Netape
#
#     On met le nombre total des Cycles pour Netape et on compare Ncycle chaque fissure
#     avec Netape et on cherche le minimum de Ncycle       
   NETAP[num_calc]=nb_cycles_total

   for num_fiss in range(1,nb_de_fissures_plus_1) :

      I=(num_calc-1)*nb_de_fissures+num_fiss

      F[num_fiss] = "F%d" %num_fiss
      levt[num_fiss] = "levt%d" %num_fiss
      levb[num_fiss] = "levb%d" %num_fiss
#
#   EXTRACTION DU CHAMP DE DEPLACEMENT POUR LE CALCUL DE K
#
      LEVS[I]=INTE_MAIL_2D(  MAILLAGE=MAIL[num_calc],
                    DEFI_CHEMIN=_F(  GROUP_MA = levt[num_fiss]),
                    GROUP_NO_ORIG=F[num_fiss]
                       )

      LEVI[I]=INTE_MAIL_2D(  MAILLAGE=MAIL[num_calc],
                    DEFI_CHEMIN=_F(  GROUP_MA = levb[num_fiss]),
                    GROUP_NO_ORIG=F[num_fiss]
                       )

      DEPT[I]=POST_RELEVE_T(  ACTION=_F(  INTITULE = 'DEPL_DH',
                                  CHEMIN = LEVS[I],
                                  RESULTAT = RESU[num_calc],
                                  NOM_CHAM = 'DEPL',
                                  TOUT_ORDRE='OUI',
                                  NOM_CMP = ( 'DX',  'DY', ),
                                  OPERATION = 'EXTRACTION')
                       )

      DEPB[I]=POST_RELEVE_T(  ACTION=_F(  INTITULE = 'DEPL_DH',
                                  CHEMIN = LEVI[I],
                                  RESULTAT = RESU[num_calc],
                                  NOM_CHAM = 'DEPL',
                                  TOUT_ORDRE='OUI',
                                  NOM_CMP = ( 'DX',  'DY', ),
                                  OPERATION = 'EXTRACTION')
                       )



      AK1[I]=POST_K1_K2_K3(  MODELISATION='AXIS',
                       INST = 95.,
                       MATER=ACIER,
                       TABL_DEPL_SUP  = DEPT[I],
                       TABL_DEPL_INF  = DEPB[I],
                       ABSC_CURV_MAXI = 0.1,
                       VECT_K1        = ( 0., 1., 0., )
                       )


      K1_min[num_fiss,num_calc]=AK1[I]['K1_MIN',1]/((1000.)**.5)
      K1_max[num_fiss,num_calc]=AK1[I]['K1_MAX',1]/((1000.)**.5)
      KI1[num_fiss,num_calc]=(K1_min[num_fiss,num_calc]+K1_max[num_fiss,num_calc])/2.


      print '================================================'
      print num_fiss
      print K1_min[num_fiss,num_calc]
      print K1_max[num_fiss,num_calc]
      print I
      print num_calc
      print '================================================'


      results.write('===================================================\n')
      results.write('***  Calcul de K par la methode Post_K1_K2_K3  ***\n')
      results.write('Numero de fissure :%i\n'%num_fiss)
      results.write('===================================================\n')
      results.write('K1_min=%.2f\n'%K1_min[num_fiss,num_calc])
      results.write('K1_max=%.2f\n'%K1_max[num_fiss,num_calc])
      results.write('KI1=%.2f\n'%KI1[num_fiss,num_calc])
      results.write('===================================================\n')


      IMPR_TABLE(TABLE=AK1[I],
                 FORMAT='AGRAF', UNITE=8, );

#
#     On met zero pour toutes les valeurs negatives de K1
#    
      if KI1[num_fiss,num_calc] < 0. :
         KI1[num_fiss,num_calc]=0.    
   
      AK2[I]=POST_K1_K2_K3(  MODELISATION='AXIS',
                       INST = 100.,
                       MATER=ACIER,
                       TABL_DEPL_SUP  = DEPT[I],
                       TABL_DEPL_INF  = DEPB[I],
                       ABSC_CURV_MAXI = 0.1,
                       VECT_K1        = ( 0., 1., 0., )
                       )
   
      K2_min[num_fiss,num_calc]=AK2[I]['K1_MIN',1]/((1000.)**.5)
      K2_max[num_fiss,num_calc]=AK2[I]['K1_MAX',1]/((1000.)**.5)
      KI2[num_fiss,num_calc]=(K2_min[num_fiss,num_calc]+K2_max[num_fiss,num_calc])/2.


      print '================================================'
      print num_fiss
      print K2_min[num_fiss,num_calc]
      print K2_max[num_fiss,num_calc]
      print '================================================'


      results.write('===================================================\n')
      results.write('***  Calcul de K par la methode Post_K1_K2_K3  ***\n')
      results.write('Numero de fissure :%i\n'%num_fiss)
      results.write('===================================================\n')
      results.write('K2_min=%.2f\n'%K2_min[num_fiss,num_calc])
      results.write('K2_max=%.2f\n'%K2_max[num_fiss,num_calc])
      results.write('KI2=%.2f\n'%KI2[num_fiss,num_calc])
      results.write('===================================================\n')

      IMPR_TABLE(TABLE=AK2[I],
           FORMAT='AGRAF', UNITE=8, );
#
#     On met zero pour toutes les valeurs negatives de K1
#    
      if KI2[num_fiss,num_calc] < 0. :
         KI2[num_fiss,num_calc]=0.
#
#     On calcul la valeur de DeltaK1 pour la fissure i
#    
      DELTAK[num_fiss,num_calc]=(abs(KI1[num_fiss,num_calc]-KI2[num_fiss,num_calc]))
#
      print "delta KI"
      print DELTAK[num_fiss,num_calc]

#
#     On calcule la valeur de "R" pour la fissure i
#    
      if KI1[num_fiss,num_calc] < KI2[num_fiss,num_calc] :
         Kmin[num_fiss,num_calc]=KI1[num_fiss,num_calc]
         Kmax[num_fiss,num_calc]=KI2[num_fiss,num_calc]
      else :
         Kmin[num_fiss,num_calc]=KI2[num_fiss,num_calc]
         Kmax[num_fiss,num_calc]=KI1[num_fiss,num_calc]
         
      if Kmin[num_fiss,num_calc] == 0.0 :
         R[num_fiss,num_calc]=0.0
      else :
         R[num_fiss,num_calc]=Kmin[num_fiss,num_calc]/Kmax[num_fiss,num_calc]
      
      if R[num_fiss,num_calc] >= 1.0 :
         R[num_fiss,num_calc]=1.0/R[num_fiss,num_calc]
         
      print '===================="R"========================='
      print R[num_fiss,num_calc]
      print '===================="R"========================='
      

#     Calcul de de fonction g(R) [gdr] et Keff
#    
      gdr[num_fiss,num_calc]=(1-R[num_fiss,num_calc])/(1-MR*R[num_fiss,num_calc])
      KEFF[num_fiss,num_calc]=((Kmax[num_fiss,num_calc]*gdr[num_fiss,num_calc])-KTH)/(KIC-(KTH/gdr[num_fiss,num_calc]))

#     Calcul de Netape pour la fissure i
#    
      if KEFF[num_fiss,num_calc] <= 0.0 :
         KEFF[num_fiss,num_calc]=0.
         NCYCL[num_fiss,num_calc]= 1.E12
      else :   
         NCYCL[num_fiss,num_calc]=DELTA0/(COEFC*((KEFF[num_fiss,num_calc])**COEFM))
      if NCYCL[num_fiss,num_calc] < NETAP[num_calc] :
         NETAP[num_calc]=NCYCL[num_fiss,num_calc]

      print "Ncycle"
      print NCYCL[num_fiss,num_calc]
    
      print "Netape"
      print NETAP[num_calc]
    
#
      results.write('===================================================\n')
      results.write('Numero de fissure :%i\n'%num_fiss)
      results.write('===================================================\n')
      results.write('Kmin=%.2f\n'%Kmin[num_fiss,num_calc])
      results.write('Kmax=%.2f\n'%Kmax[num_fiss,num_calc])
      results.write('Delta_K=%.2f\n'%DELTAK[num_fiss,num_calc])
      results.write('Keff=%.4f\n'%KEFF[num_fiss,num_calc])
      results.write('R=%.2f\n'%R[num_fiss,num_calc])
      results.write('         ***         \n')
      results.write('Ncycle=%.2f\n'%NCYCL[num_fiss,num_calc])
      results.write('Netape=%.2f\n'%NETAP[num_calc])

   
#        fin de boucle    
#
# 4.2 On boucle sur toutes les fissures pour calculer l'extension de chaque fissure
#
# 4.2.1 On change la langour des fissures dans le fichier de gibi
#
   file = copy.copy(ini_mesh)
#
   for num_fiss in range(1,nb_de_fissures_plus_1) :

      DELTA[num_fiss,num_calc]=COEFC*NETAP[num_calc]*((KEFF[num_fiss,num_calc])**COEFM)
      lnga[num_fiss]=lnga[num_fiss]+DELTA[num_fiss,num_calc]

      print num_fiss
      print "la nouvelle longueur"
      print lnga[num_fiss]

      results.write('         ***         \n')
      results.write('la nouvelle longueur :%f\n'%lnga[num_fiss])

#            On cherche pour la longuour correspondante

      i = 0 
      while (string.find(file[i],'lf_'+str(num_fiss)) == -1) :
         i = i+1
      file[i] = 'lf_' + str(num_fiss) + '=' + str(lnga[num_fiss]) + ';  \012'
#
#
   new = open('fort.61','w')
   for i in range(len(file)):
#      print file[i]
      new.write(file[i])
   new.close()
    
    
#        fin de boucle    
#
#    5. Remaillage avec GMSH
#           
# 5.1 On relance GMSH afin de refaire le maillage pour les nouvelles positions des fonds des fissuress
   DEFI_FICHIER(ACTION='LIBERER',UNITE=19,)
   DEFI_FICHIER(ACTION='LIBERER',UNITE=20,)
   os.system ('rm fort.19 ')
   os.system ('rm fort.20 ')
   os.system ('cp fort.61 mail.geo')

   print '================================================'
   os.system ('cat mail.geo')
   print '================================================'
   
   
   os.system (gmsh+' -2  -algo aniso mail.geo -o fort.19')

   print 'GMSH est fini'
#
# 6. Memorisation
#
# 6.1 On memorise le numero global du calcul
#
   num_calc_avant = num_calc
   cycle_passe=cycle_passe+NETAP[num_calc]
   
   print 'cycle_passe ='
   print cycle_passe

   results.write('         ***         \n')
   results.write('Nombre de cycles passes=%.2f\n'%cycle_passe)
   results.write('         ***         \n')
 
    
   if cycle_passe >=  nb_cycles_total :
       num_calc=nb_calc_total_plus_1
       print '================================================'
       print 'Le calcul est termine'
       print num_calc
       print '================================================'

   nom_concept = 'RESU_%d' % num_calc
   DETRUIRE(CONCEPT=_F( NOM = nom_concept))
    
#
#
#        On teste les valeurs calculees de keff et da pour 
#        la fissure F1
#

KEFF=DEFI_FONCTION(    NOM_PARA='X',   NOM_RESU='keff',
                            VALE=(1, KEFF[4,1], 2, KEFF[4,2], 3, KEFF[4,3],),
                            PROL_DROITE='LINEAIRE',
                            PROL_GAUCHE='LINEAIRE'
                         )

TEST_FONCTION(VALEUR=( _F(  FONCTION = KEFF,   VALE_PARA = 1,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = 0.0513,  
                    PRECISION = .01),  
    _F(  FONCTION = KEFF,   VALE_PARA = 2,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = .0550,  
                    PRECISION = .015),       
    _F(  FONCTION = KEFF,   VALE_PARA = 3,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = .0613,  
                    PRECISION = .015), 
               ));

NETAP=DEFI_FONCTION(    NOM_PARA='X',   NOM_RESU='netap',
                            VALE=(1, NETAP[1], 2, NETAP[2], 3, NETAP[3],),
                            PROL_DROITE='LINEAIRE',
                            PROL_GAUCHE='LINEAIRE'
                         )

TEST_FONCTION(VALEUR=( _F(  FONCTION = NETAP,   VALE_PARA = 1,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = 212900.,  
                    PRECISION = 100.0),  
    _F(  FONCTION = NETAP,   VALE_PARA = 2,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = 178574.,  
                    PRECISION = 100.0),       
    _F(  FONCTION = NETAP,   VALE_PARA = 3,
                    REFERENCE = 'NON_REGRESSION',
                          VALE_REFE = 135107.,  
                    PRECISION = 100), 
               ));



results.close()

FIN();

