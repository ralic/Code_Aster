# MODIF  DATE 26/07/2011   AUTEUR GENIAUT S.GENIAUT 
# TITRE  FISSURE LENTILLE EN TRACTION
# sslv155c.para = tps_job 300 mem_job 1024Mo liste_test S
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

DEBUT(CODE=_F(NOM='SSLV155C',
              NIV_PUB_WEB='INTERNET',
              VISU_EFICAS='OUI'),
      DEBUG=_F(SDVERI='OUI'),
      IGNORE_ALARM=('CALCULEL2_63','MODELISA3_31'))

# MODELISATION C : X-FEM 3D, MAILLAGE LINEAIRE

# on ignore l'alarme MODELISA3_31 qui est emise lors de
# l'application de la pression sur la face EXT, surface exterieure d'un quart de cylindre

# parametres utiles
#------------------

# angle de la lentile
alpha = pi / 4.0

# valeur nominale de la force imposee
sig = 1000000.

# rayon de la fissure
R = 2.

# rayon circulaire de la lentille
a = R * sin(alpha)

# taille des mailles initiales
h0 = 1.

# taille cible des mailles apres raffinement 
hc = 0.06

# nombre de niveau de raffinements
# attention, en python log = ln (logarithme neperien)
n = (log(h0)-log(hc))/log(2)
nb_raff = int(n)+1
print '***INFO*** : nb_raff = ',nb_raff

# taille des mailles apres raffinement
h = h0/(2.**nb_raff)
print '***INFO*** : h = ',h

# on realise en fait une iteration de plus, car Homard a parfois du mal...
nb_iter = nb_raff+1

# rayon du disque de raffinement
r_raff = 6*h

# definition des formules utiles pour le calcul des level sets
Rp = R * tan(alpha)
Yh = R - R/cos(alpha)
LN = FORMULE(NOM_PARA=('X','Y','Z'),VALE='sqrt(X**2+(Y-R)**2+Z**2)-R')
LT = FORMULE(NOM_PARA=('X','Y','Z'),VALE='sqrt(X**2+(Y-Yh)**2+Z**2)-Rp')

# initialisation
MA    = [None]*(nb_iter+1)
MO    = [None]*nb_iter
CHERR = [None]*nb_iter
FISS  = [None]*nb_iter 

i_raff=0   
MA[i_raff]=LIRE_MAILLAGE(FORMAT='MED')

# boucle de raffinements
for i_raff in range(nb_iter) :

   MO[i_raff]=AFFE_MODELE(MAILLAGE=MA[i_raff],
                          AFFE=_F(TOUT='OUI',
                                  PHENOMENE='MECANIQUE',
                                  MODELISATION='3D'))

   FISS[i_raff]=DEFI_FISS_XFEM(MODELE=MO[i_raff],
                               DEFI_FISS=_F(FONC_LT=LT,
                                            FONC_LN=LN),
                               ORIE_FOND=_F(PFON_INI  =(a ,0.,0.),
                                            VECT_ORIE =(0.,1.,0.),
                                            POINT_ORIG=(0.,0.,0.))
                               )
      
   # evaluation de l'erreur       
   CHERR[i_raff]=RAFF_XFEM(FISSURE=FISS[i_raff])
   
   # definition du type du maillage n+1
   MA[i_raff+1]=CO('MA_%d' % (i_raff+1))
   
   # valeur du critere de raffinement
   crit = -max(r_raff , h0/(2.**i_raff) )
   
   MACR_ADAP_MAIL(ADAPTATION         = 'RAFFINEMENT',
                  NIVE_MAX           = nb_raff,
                  CHAM_GD            = CHERR[i_raff],
                  CRIT_RAFF_ABS      = crit,
                  USAGE_CMP          = 'RELATIF', 
                  MAILLAGE_N         = MA[i_raff],
                  MAILLAGE_NP1       = MA[i_raff+1],
                  ELEMENTS_NON_HOMARD= 'IGNORER')

assert(nb_iter == i_raff+1)

# impression du dernier maillage
IMPR_RESU(FORMAT='MED',UNITE=80,RESU=_F(MAILLAGE=MA[nb_iter]))


MA[nb_iter]=MODI_MAILLAGE(reuse =MA[nb_iter],
                          MAILLAGE=MA[nb_iter],
                          ORIE_PEAU_3D=_F(GROUP_MA=('SUP','INF','EXT','LATG','LATD')))

MODE=AFFE_MODELE(MAILLAGE=MA[nb_iter],
                 AFFE=_F(GROUP_MA=('VOL','SUP','INF','EXT','LATG','LATD'),
                         PHENOMENE='MECANIQUE',
                         MODELISATION='3D'))

FISSX=DEFI_FISS_XFEM(MODELE=MODE,
                     DEFI_FISS=_F(FONC_LT=LT,
                                  FONC_LN=LN),
                     ORIE_FOND=_F(PFON_INI  =(a ,0.,0.),
                                  VECT_ORIE =(0.,1.,0.),
                                  POINT_ORIG=(0.,0.,0.))
                               )

MODX=MODI_MODELE_XFEM(MODELE_IN=MODE,
                      FISSURE=FISSX)

ACIER=DEFI_MATERIAU(ELAS=_F(E=210000e6,
                            NU=0.3))

MATE=AFFE_MATERIAU(MAILLAGE=MA[nb_iter],
                   AFFE=_F(TOUT='OUI',
                           MATER=ACIER))

CHAR=AFFE_CHAR_MECA(MODELE=MODX,
                    # mode rigide de translation :
                    DDL_IMPO=_F(GROUP_NO='D',DY=0.),
                    # conditions de symetrie :
                    FACE_IMPO=_F(GROUP_MA=('LATG','LATD'),DNOR=0.),
                    # traction :
                    PRES_REP=_F(GROUP_MA=('SUP','INF','EXT'),PRES=-sig))

CHXFEM=AFFE_CHAR_MECA(MODELE=MODX,
                      LIAISON_XFEM='OUI')

LIST=DEFI_LIST_REEL(DEBUT=0.,
                    INTERVALLE=_F(JUSQU_A=1.,
                                  NOMBRE=1))

RESU=STAT_NON_LINE(MODELE=MODX,
                   CHAM_MATER=MATE,
                   EXCIT=(_F(CHARGE=CHAR,),
                          _F(CHARGE=CHXFEM)),
                   COMP_ELAS=_F(RELATION='ELAS',
                                GROUP_MA='VOL',),
                   INCREMENT=_F(LIST_INST=LIST,))

# visualisation
MA_VISU=POST_MAIL_XFEM(MODELE=MODX)

MO_VISU=AFFE_MODELE(MAILLAGE=MA_VISU,
                    AFFE=_F(TOUT='OUI',
                            PHENOMENE='MECANIQUE',
                            MODELISATION='3D'))

RE_VISU=POST_CHAM_XFEM(MODELE_VISU=MO_VISU,
                       RESULTAT=RESU)

IMPR_RESU(FORMAT='MED',UNITE=81,RESU=_F(RESULTAT=RE_VISU))

# post-traitement en mecanique de la rupture
CGX=CALC_G(THETA=_F(FISSURE=FISSX,
                    NB_POINT_FOND=30,
                    DTAN_ORIG=(cos(alpha),sin(alpha),0          ),
                    DTAN_EXTR=(       0. ,sin(alpha),-cos(alpha)),
                    R_INF=2*h,
                    R_SUP=5*h,),
           RESULTAT=RESU,
           INST=1.,
           OPTION='CALC_K_G',
           LISSAGE=_F(LISSAGE_THETA='LEGENDRE',
                      DEGRE=5,
                      LISSAGE_G='LEGENDRE'),
          )

IMPR_TABLE(TABLE=CGX)

PK=POST_K1_K2_K3(MODELISATION='3D',
                 FISSURE=FISSX,
                 DTAN_ORIG=(cos(alpha),sin(alpha),0          ),
                 DTAN_EXTR=(       0. ,sin(alpha),-cos(alpha)),
                 NB_POINT_FOND=30,
                 MATER=ACIER,
                 RESULTAT=RESU,
                 INST=1.,
                 ABSC_CURV_MAXI=4*h)

IMPR_TABLE(TABLE=PK)

K1ref = 0.877*(2/pi)*sig*sqrt(pi*a)
K2ref = 0.235*(2/pi)*sig*sqrt(pi*a)
K3ref = 0.

# test de la commande CALC_G
#---------------------------

TEST_TABLE(TABLE=CGX,
           TYPE_TEST='MAX',
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.08,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=CGX,
           TYPE_TEST='MIN',
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.02,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=CGX,
           TYPE_TEST='MAX',
           NOM_PARA='K2',
           VALE=-K2ref,
           PRECISION=0.06,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=CGX,
           TYPE_TEST='MIN',
           NOM_PARA='K2',
           VALE=-K2ref,
           PRECISION=0.15,
           REFERENCE='ANALYTIQUE')

# TEST_TABLE(TABLE=CGX,
#            TYPE_TEST='MAX',
#            NOM_PARA='K3',
#            VALE=K3ref,
#            PRECISION=K1ref/1000.,
#            CRITERE='ABSOLU',
#            REFERENCE='ANALYTIQUE')
# 
# TEST_TABLE(TABLE=CGX,
#            TYPE_TEST='MIN',
#            NOM_PARA='K3',
#            VALE=K3ref,
#            PRECISION=K1ref/1000.,
#            CRITERE='ABSOLU',
#            REFERENCE='ANALYTIQUE')

# test de la commande POST_K1_K2_K3
#-----------------------------------

TEST_TABLE(TABLE=PK,
           TYPE_TEST='MAX',
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.10,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=PK,
           TYPE_TEST='MIN',
           NOM_PARA='K1',
           VALE=K1ref,
           PRECISION=0.09,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=PK,
           TYPE_TEST='MAX',
           NOM_PARA='K2',
           VALE=-K2ref,
           PRECISION=0.02,
           REFERENCE='ANALYTIQUE')

TEST_TABLE(TABLE=PK,
           TYPE_TEST='MIN',
           NOM_PARA='K2',
           VALE=-K2ref,
           PRECISION=0.20,
           REFERENCE='ANALYTIQUE')

# TEST_TABLE(TABLE=PK,
#            TYPE_TEST='MAX',
#            NOM_PARA='K3',
#            VALE=K3ref,
#            PRECISION=K1ref/1000.,
#            CRITERE='ABSOLU',
#            REFERENCE='ANALYTIQUE')
# 
# TEST_TABLE(TABLE=PK,
#            TYPE_TEST='MIN',
#            NOM_PARA='K3',
#            VALE=K3ref,
#            PRECISION=K1ref/1000.,
#            CRITERE='ABSOLU',
#            REFERENCE='ANALYTIQUE')
                              
FIN()
