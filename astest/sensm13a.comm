# MODIF  DATE 21/11/2006   AUTEUR COURTOIS M.COURTOIS 
# RESPONSABLE F6BHHBO P.DEBONNIERES
# TITRE ETUDE  : ESSAI TRIAXIAL AVEC LE MODELE DE TYPE (3D)
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
#            CONFIGURATION MANAGEMENT OF EDF VERSION
#
DEBUT(CODE=_F( NOM = 'SENSM13A',NIV_PUB_WEB='INTERNET',VISU_EFICAS='NON'),
          BASE=_F( FICHIER = 'GLOBALE',LONG_REPE = 15000),) 
#
#......................................................................
# ESSAI TRIAXIAL EN 3D
# PLASTICITE DRUCKER-PRAGER
# SENSIBILITE AUX PARAMETRES MATERIAU
#......................................................................
#
#
# 2. Definition du dictionnaire des parametres
#

mot_cle = [ "E", "NU", "ALPHA", "P_ULTM", "SY", "SY_ULTM" ]
sensible = [ 5800.0E6,  0.3,  0.33, 0.01, 2.57E6, 0.57E6 ]

#
# 3. Definition des parametres sensibles
#

n = len(sensible)

PS = [None]*n

for i in range(n):
  PS[i] = DEFI_PARA_SENSI(VALE = sensible[i])


#
# 4. Maillage
#

MAILLAGE = LIRE_MAILLAGE()

#
# 5. Modele
#

MODEMECA = AFFE_MODELE(MAILLAGE = MAILLAGE,
                       AFFE = _F(TOUT = 'OUI',
                                 PHENOMENE = 'MECANIQUE',
                                 MODELISATION = '3D')
                      )

MAILLAGE = MODI_MAILLAGE(reuse = MAILLAGE,
                         MAILLAGE = MAILLAGE,
                         ORIE_PEAU_3D = _F( GROUP_MA = ('HAUT',
                                                        'DEVANT',
                                                        'GAUCHE',
                                                        'BAS',
                                                        'DERRIERE',
                                                        'DROITE')
                                          )
                        )

#
# 6. Mise en place des materiaux
#

MAT = DEFI_MATERIAU(ELAS_FO = _F(E = PS[0],
                                 NU = PS[1]),
                    DRUCK_PRAGER_FO = _F(ECROUISSAGE = 'PARABOLIQUE',
                                         ALPHA = PS[2],
                                         P_ULTM = PS[3],
                                         SY = PS[4],
                                         SY_ULTM = PS[5])
                   );


#
# 7. Affectation des materiaux
#

MATEMAIL = AFFE_MATERIAU(MAILLAGE = MAILLAGE,
                         AFFE = _F(TOUT = 'OUI', MATER = MAT));

#
# 8. Chargements
#

TEMPS1 = DEFI_LIST_REEL(DEBUT = 0.,
                        INTERVALLE = _F(JUSQU_A = 1.0, NOMBRE = 1)
                       )
     
TEMPS2 = DEFI_LIST_REEL(DEBUT = 1.,
                        INTERVALLE = _F(JUSQU_A = 2.0, NOMBRE = 100)
                       )

PR_LATE = AFFE_CHAR_MECA(MODELE = MODEMECA,
                         PRES_REP = _F(GROUP_MA = ( 'DEVANT', 'DROITE'),
                                       PRES = 1.
                                      )
                        )

PR_V = AFFE_CHAR_MECA(MODELE = MODEMECA,
                      PRES_REP=_F(GROUP_MA = 'HAUT', PRES = 1.)
                     )

DEP_SYM = AFFE_CHAR_MECA(MODELE = MODEMECA,FACE_IMPO = (
                               _F(  GROUP_MA = 'BAS',      DZ = 0.,   ),
                               _F(  GROUP_MA = 'DERRIERE', DX = 0.,   ),
                               _F(  GROUP_MA = 'GAUCHE',   DY = 0.,   ))
                            )

DEP_V=AFFE_CHAR_MECA( MODELE    = MODEMECA,
                      FACE_IMPO = _F( GROUP_MA = 'HAUT', DZ = 1., )
                     )

COEF1 = DEFI_FONCTION(NOM_PARA = 'INST',
                      PROL_DROITE = 'CONSTANT',
                      VALE = (0.0, 0.0,
                              1.0, 2.0E6)
                     )

COEF2 = DEFI_FONCTION(NOM_PARA = 'INST',
                      PROL_DROITE = 'LINEAIRE',
                      PROL_GAUCHE = 'CONSTANT',
                      VALE = (1.0,  0.0,
                              2.0, -0.015)
                     )

#
# 9. Calcul
#

RES = STAT_NON_LINE(MODELE = MODEMECA,
                   CHAM_MATER = MATEMAIL,
                   EXCIT = (_F(CHARGE = PR_LATE, FONC_MULT = COEF1),
                            _F( CHARGE = DEP_SYM),
                            _F( CHARGE = DEP_V, FONC_MULT = COEF2)),
                   COMP_INCR = _F(RELATION = 'DRUCKER_PRAGER',
                                    RESI_INTE_RELA = 1.E-6,
                                    ITER_INTE_MAXI = 100,
                                    ITER_INTE_PAS  = -10,),
                   INCREMENT = _F(LIST_INST = TEMPS2),
                   NEWTON = _F(MATRICE = 'TANGENTE',
                               REAC_ITER = 1),
                   CONVERGENCE = _F(RESI_GLOB_RELA = 1.E-6,
                                    ITER_GLOB_MAXI = 100),
                   SENSIBILITE= tuple(PS),
                  )
RES=CALC_ELEM(reuse=RES,RESULTAT=RES,
              OPTION=('SIEF_ELNO_ELGA','VARI_ELNO_ELGA'),)

RES=CALC_ELEM(reuse=RES,RESULTAT=RES,
              OPTION=('SIEF_ELNO_ELGA','VARI_ELNO_ELGA'),
              SENSIBILITE=tuple(PS))

# Extraction de contrainte ZZ et de sa derivee
TSIGN = POST_RELEVE_T(ACTION=_F(INTITULE='SENSIBILITE',
                               NOEUD='NO1',
                               MAILLE='MA1',
                               RESULTAT=RES,
                               NOM_CHAM='SIEF_ELNO_ELGA',
                               NOM_CMP='SIZZ',
                               OPERATION='EXTRACTION',),);

TSIGN = POST_RELEVE_T(reuse=TSIGN,
                     ACTION=_F(INTITULE='SENSIBILITE',
                               NOEUD='NO1',
                               MAILLE='MA1',
                               RESULTAT=RES,
                               NOM_CHAM='SIEF_ELNO_ELGA',
                               NOM_CMP='SIZZ',
                               SENSIBILITE=tuple(PS),
                               OPERATION='EXTRACTION',),);

# Extraction de la 1ere variable interne et de sa derivee
TVARN = POST_RELEVE_T(ACTION=_F(INTITULE='SENSIBILITE',
                               NOEUD='NO1',
                               MAILLE='MA1',
                               RESULTAT=RES,
                               NOM_CHAM='VARI_ELNO_ELGA',
                               NOM_CMP='V1',
                               OPERATION='EXTRACTION',),);

TVARN = POST_RELEVE_T(reuse=TVARN,
                     ACTION=_F(INTITULE='SENSIBILITE',
                               NOEUD='NO1',
                               MAILLE='MA1',
                               RESULTAT=RES,
                               NOM_CHAM='VARI_ELNO_ELGA',
                               NOM_CMP='V1',
                               SENSIBILITE=tuple(PS),
                               OPERATION='EXTRACTION',),);

#
# Verification par differences finies
#

epsilon = 1.E-4
VERIF = [None] * n
DCALC = [None] * n
MAT   = [None] * n
CHMAT = [None] * n
RES   = [None] * n
TSIGP = [None] * n
TVARP = [None] * n
TCS   = [None] * n
TCV   = [None] * n

def ecart(diff, deriv):
   """
      Retourne l'ecart relatif entre les derivees si la reference est non nulle,
      la difference finie sinon.
   """
   if abs(deriv) > 1.e-3:
      res = abs(diff - deriv)/deriv
   else:
      res = deriv
   return res


for i in range(n):
   eps = [1.] * n
   eps[i] = 1.0 + epsilon

   # deux formules pour garder dans la table l'estimation de la derivee
   DCALC[i] = FORMULE(NOM_PARA=('VNOM', 'VPLUS'),
                      VALE='(VPLUS - VNOM)/%f' % (epsilon*sensible[i]))
   
   VERIF[i] = FORMULE(NOM_PARA=('DERIV', 'DCALC'),
                      VALE='ecart(DCALC, DERIV)')
   
   MAT[i]=DEFI_MATERIAU(ELAS=_F(E =sensible[0]*eps[0],
                                NU=sensible[1]*eps[1],),
                        DRUCK_PRAGER=_F(ECROUISSAGE='PARABOLIQUE',
                                        ALPHA      =sensible[2]*eps[2],
                                        P_ULTM     =sensible[3]*eps[3],
                                        SY         =sensible[4]*eps[4],
                                        SY_ULTM    =sensible[5]*eps[5],),)
   
   CHMAT[i]=AFFE_MATERIAU(MAILLAGE=MAILLAGE,
                          AFFE=_F(TOUT='OUI',
                                  MATER=MAT[i],),)
   
   RES[i]=STAT_NON_LINE(MODELE=MODEMECA,
                        CHAM_MATER=CHMAT[i],
                        EXCIT=(_F(CHARGE=PR_LATE,
                                  FONC_MULT=COEF1),
                               _F(CHARGE=DEP_SYM),
                               _F(CHARGE=DEP_V,
                                  FONC_MULT=COEF2),),
                        COMP_INCR=_F(RELATION='DRUCKER_PRAGER',
                                     RESI_INTE_RELA=1.E-6,
                                     ITER_INTE_MAXI=100,
                                     ITER_INTE_PAS=-10,),
                        INCREMENT=_F(LIST_INST=TEMPS2),
                        NEWTON=_F(MATRICE='TANGENTE',
                                  REAC_ITER=1),
                        CONVERGENCE=_F(RESI_GLOB_RELA=1.E-6,
                                       ITER_GLOB_MAXI=100),)
   
   RES[i]=CALC_ELEM(reuse=RES[i],
                    RESULTAT=RES[i],
                    OPTION=('SIEF_ELNO_ELGA','VARI_ELNO_ELGA'),)
   
   # Extraction de la contrainte ZZ avec P + epsilon
   TSIGP[i]=POST_RELEVE_T(ACTION=_F(INTITULE='SENSIBILITE',
                                    NOEUD='NO1',
                                    MAILLE='MA1',
                                    RESULTAT=RES[i],
                                    NOM_CHAM='SIEF_ELNO_ELGA',
                                    NOM_CMP='SIZZ',
                                    OPERATION='EXTRACTION',),)
   
   # table de comparaison pour les contraintes
   # Principe :
   # - On part de la table qui contient la derivee,
   # - on renomme la colonne de la derivee en DERIV,
   # - on fusionne avec la table de la valeur en p+epsilon,
   # - que l'on renomme en VPLUS,
   # - on insere la table avec la valeur nominale,
   # - que l'on renomma en VNOM,
   # - on estime la derivee (VPLUS - VNOM)/deltap = DCALC,
   # - on calcule l'ecart entre DCALC et DERIV (en relatif ou absolu),
   # - on limite les colonnes de la table.
   TCS[i]=CALC_TABLE(TABLE=TSIGN,
                     SENSIBILITE=PS[i],
                     ACTION=(_F(OPERATION='RENOMME',
                                 NOM_PARA=('SIZZ', 'DERIV'),),
                              _F(OPERATION='COMB',
                                 TABLE=TSIGP[i],
                                 NOM_PARA=('NOEUD','INST'),),
                              _F(OPERATION='RENOMME',
                                 NOM_PARA=('SIZZ', 'VPLUS'),),
                              _F(OPERATION='COMB',
                                 TABLE=TSIGN,
                                 NOM_PARA=('NOEUD','INST'),),
                              _F(OPERATION='RENOMME',
                                 NOM_PARA=('SIZZ', 'VNOM'),),
                              _F(OPERATION='OPER',
                                 NOM_PARA='DCALC',
                                 FORMULE=DCALC[i]),
                              _F(OPERATION='OPER',
                                 NOM_PARA='DIFF',
                                 FORMULE=VERIF[i]),
                              _F(OPERATION='EXTR',
                                 NOM_PARA=('NOEUD','INST','VNOM','VPLUS','DCALC','DERIV','DIFF'),),),)
   
   IMPR_TABLE(TABLE=TCS[i])
   
   IMPR_TABLE(TABLE=TCS[i],
              FILTRE=_F(NOM_PARA='DIFF',
                        CRIT_COMP='ABS_MAXI'),
              TITRE="Max de l'ecart")
   
   TEST_TABLE(TABLE=TCS[i],
              NOM_PARA='DIFF',
              FILTRE=_F(NOM_PARA='DIFF',
                        CRIT_COMP='ABS_MAXI'),
              VALE=0.,
              CRITERE='ABSOLU',
              PRECISION=1.e-3,
              REFERENCE='AUTRE_ASTER',)
      
   # Extraction de la 1ere variable interne avec P + epsilon
   TVARP[i]=POST_RELEVE_T(ACTION=_F(INTITULE='SENSIBILITE',
                                    NOEUD='NO1',
                                    MAILLE='MA1',
                                    RESULTAT=RES[i],
                                    NOM_CHAM='VARI_ELNO_ELGA',
                                    NOM_CMP='V1',
                                    OPERATION='EXTRACTION',),)
   
   # table de comparaison pour la 1ere variable interne
   TCV[i]=CALC_TABLE(TABLE=TVARN,
                     SENSIBILITE=PS[i],
                     ACTION=(_F(OPERATION='RENOMME',
                                 NOM_PARA=('V1', 'DERIV'),),
                              _F(OPERATION='COMB',
                                 TABLE=TVARP[i],
                                 NOM_PARA=('NOEUD','INST'),),
                              _F(OPERATION='RENOMME',
                                 NOM_PARA=('V1', 'VPLUS'),),
                              _F(OPERATION='COMB',
                                 TABLE=TVARN,
                                 NOM_PARA=('NOEUD','INST'),),
                              _F(OPERATION='RENOMME',
                                 NOM_PARA=('V1', 'VNOM'),),
                              _F(OPERATION='OPER',
                                 NOM_PARA='DCALC',
                                 FORMULE=DCALC[i]),
                              _F(OPERATION='OPER',
                                 NOM_PARA='DIFF',
                                 FORMULE=VERIF[i]),
                              _F(OPERATION='EXTR',
                                 NOM_PARA=('NOEUD','INST','VNOM','VPLUS','DCALC','DERIV','DIFF'),),),)
   
   IMPR_TABLE(TABLE=TCV[i])
   
   IMPR_TABLE(TABLE=TCV[i],
              FILTRE=_F(NOM_PARA='DIFF',
                        CRIT_COMP='ABS_MAXI'),
              TITRE="Max de l'ecart")
   
   TEST_TABLE(TABLE=TCV[i],
              NOM_PARA='DIFF',
              FILTRE=_F(NOM_PARA='DIFF',
                        CRIT_COMP='ABS_MAXI'),
              VALE=0.,
              CRITERE='ABSOLU',
              PRECISION=1.e-3,
              REFERENCE='AUTRE_ASTER',)
      
FIN()
