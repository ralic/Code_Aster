# MODIF  DATE 18/03/2008   AUTEUR BOYERE E.BOYERE 
# TITRE FREQUENCES D'UNE LIGNE D'ARBRE SIMPLIFIEE (AMORTISSEMENT GYROSCOPIQUE)
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2008  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                    
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================

from Numeric import *
from LinearAlgebra import *

def EXTR_MATR(matrrr) :
# fonction permettant de recuperer les matrices assemblees au format Numerical array
# attention a l'espace memoire

# construction des vecteurs jeveux
                nommatr=matrrr.nom
                lenm=len(nommatr)
                nommatr=nommatr+' '*(8-lenm+1)
                vectrav=nommatr+'          .REFA        '
                nom=aster.getvectjev(vectrav)
                nomnume=nom[1]
                typm=nom[8]
                if(typm[0:2]=='MS'):
                        mult=1
                if(typm[0:2]=='MR'):
                        mult=-1
                lenm=len(nomnume)
                nomnume=nomnume[0:9]

                nvar=nommatr+'          .VALM'
                nadia=nomnume+'     .SMOS.SMDI        '
                nnuml=nomnume+'     .SMOS.SMHC        '
                nrtt=nomnume+'     .NUME.DELG        '
                nrtt2=nomnume+'     .NUME.DEEQ        '

                var=aster.getcolljev(nvar)
                adia=aster.getvectjev(nadia)
                numl=aster.getvectjev(nnuml)
                rtt=aster.getvectjev(nrtt)
                rtt2=aster.getvectjev(nrtt2)

                valr=var[1]

                vc=len(rtt)
                ddltot=0
                nnddl=[0]
                tryy=0

# calc nbre de ddl au total et vect contenant le nbre de ddl pr chaque noeud (ex : barre =3, poutre=6...)
                for jj in range(0,vc):
                        if (rtt2[2*jj+1]==1) and (tryy==1):
                                if (tryy==1):
                                        nnddl=nnddl+[0]
                                        tryy=0
                        if (rtt2[2*jj+1]>0) :
                                ddltot=ddltot+1
                                nnddl[len(nnddl)-1]=nnddl[len(nnddl)-1]+1
                                tryy=1
                nnddl=nnddl+[0]
                ddlag=(vc-ddltot)//2
                ddlphy=ddltot-ddlag
                ddlphy=ddlphy
                indint=[None]*ddlphy

# contruction du vect contenant les indices des ddls non lagr et non nuls
                gg=0
                tt=0
                pp=0
                limm=nnddl[pp]
                vecc=[1]*limm
                ste=limm
                for ii in range(0,vc):
                        if (rtt2[2*ii+1]<0):
                                if (rtt[ii]==-1):
                                        varr=-1*rtt2[2*ii+1]-1
                                        vecc[varr]=0
                                ste=limm
                        if (rtt2[2*ii+1]>0) and (ste==limm):
                                for hh in range(0,limm):
                                        if (vecc[hh]==1):
                                                indint[gg]=ii+hh
                                                gg=gg+1
                                        vecc[hh]=1
                                ste=0                           
                                pp=pp+1
                                limm=nnddl[pp-1]
                                vecc=[1]*limm
                        if (rtt2[2*ii+1]>0) and (ste<limm):
                                ste=ste+1

# construction de la matrice complete ddl lag compris (cette etape peut etre fusionnee avec la suivante mais ca devient complique)
                lon=len(adia)
                valeu=Numeric.zeros([lon,lon],Numeric.Float)
                opi=0
                indc=0
                indl=0
                for ii in range(0,lon):
                        if (ii==0):
                                opi=adia[ii]
                        else:
                                opi=adia[ii]-adia[ii-1]
                        for jj in range(0, opi):
                                if (ii==0):
                                        indc=jj
                                        indd=numl[indc]-1
                                else:
                                        indc=adia[ii-1]+jj
                                        indd=numl[indc]-1
                                valeu[indd][ii]=valr[indc]
                                valeu[ii][indd]=mult*valr[indc]
                matrig=valeu

# elimination des ddl de lagrange et des ddl nuls
                rig11=Numeric.zeros([ddlphy,ddlphy],Numeric.Float)
                for ii in range(0,ddlphy):
                        for jj in range(0,ddlphy):
                                rig11[ii][jj]=matrig[indint[ii]][indint[jj]]

                return rig11



DEBUT(PAR_LOT='NON',
      CODE=_F(NOM='SDLL123A', NIV_PUB_WEB='INTERNET'),)

nddl=19*6-3-3

MAIL=LIRE_MAILLAGE()

MODELE=AFFE_MODELE(MAILLAGE=MAIL,
                   AFFE=(_F(GROUP_MA='ROTOR',
                           PHENOMENE='MECANIQUE',
                           MODELISATION='POU_D_E',),
                         _F(GROUP_MA=('DISQUES'),
                           PHENOMENE='MECANIQUE',
                           MODELISATION='DIS_TR',),
                         )
                       )

ACIER=DEFI_MATERIAU(ELAS=_F(E=2.06E11,
                            NU=0.0,
                            RHO=7800.0,),);



CHMAT=AFFE_MATERIAU(MAILLAGE=MAIL,
                    AFFE=(_F(GROUP_MA='ROTOR',
                            MATER=ACIER,),))

CARELEM=AFFE_CARA_ELEM(MODELE=MODELE,
                       POUTRE=(_F(GROUP_MA='ROTOR',
                                 SECTION='CERCLE',
                                 CARA='R',
                                 VALE=(.025),),),
                        DISCRET=(
				  _F(GROUP_MA='DISQUES',
	                             CARA='M_TR_D_N',
                             VALE=(0.03829,3.000E-6,1.8000E-6,1.8000E-6,0.,0.,0.,0.,0.,0.),
                        )
                        )
                        )
                                 
                                 

BLOQUAGE=AFFE_CHAR_MECA(MODELE=MODELE,
                        DDL_IMPO=(
                                 _F(GROUP_NO=('PALIER_A','PALIER_B'),
                                     DX=0, DY=0, DZ=0,
                                     ),
                          ))
                                    

MACRO_MATR_ASSE(MODELE=MODELE,
                CHAM_MATER=CHMAT,
                CARA_ELEM=CARELEM,
                CHARGE=BLOQUAGE,
                NUME_DDL=CO('NUMEDDL'),
                MATR_ASSE=(_F(MATRICE=CO('RIGIDITE'),
                              OPTION='RIGI_MECA',),
                           _F(MATRICE=CO('MASSE'),
                              OPTION='MASS_MECA',),
                           _F(MATRICE=CO('GYASS'),
                              OPTION='MECA_GYRO',),
                           _F(MATRICE=CO('AMOR'),
                              OPTION='AMOR_MECA',),),);


mas=EXTR_MATR(MASSE)
rig=EXTR_MATR(RIGIDITE)

                    
MODES=MODE_ITER_SIMULT(MATR_A=RIGIDITE,
                       MATR_B=MASSE,
                       CALC_FREQ=_F(OPTION='BANDE',
                       FREQ=(3.,3000.)));

                                  
IMPR_RESU(MODELE=MODELE,
          FORMAT='GMSH',
          UNITE=37,
          RESU=_F(MAILLAGE=MAIL,
                  RESULTAT=MODES,
                  NOM_CHAM='DEPL',),);

OM=10000.*pi/30.

GYOM=COMB_MATR_ASSE(COMB_R=(_F(MATR_ASSE=GYASS, COEF_R=OM,),
                            _F(MATR_ASSE=AMOR, COEF_R=1.,),))


gyro=EXTR_MATR(GYOM)

masI=inverse(mas)
HPRIME=zeros((nddl*2,nddl*2),Float)
HPRIME[0:nddl,0:nddl]=matrixmultiply(gyro,masI)
HPRIME[0:nddl,nddl:2*nddl]=matrixmultiply(rig,masI)
HPRIME[nddl:2*nddl,0:nddl]=-identity(nddl)

print 'valeurs propres primes'
vprime=eigenvalues(HPRIME)/2./pi
vpreal=list(vprime.imag)
vpreal.sort()
i=1
j=0
for vp in vpreal:
 if vp>=0.:
  print "vp %4d : %6.3f" %(i,vp)
  i=i+1
 j=j+1
 dij=j-i


FREQROT=CREA_TABLE(
        LISTE=(
               _F(LISTE_I=(1,2,3,4),PARA='NUME_ORDRE'),
               _F(LISTE_R=(vpreal[3+dij],vpreal[4+dij],vpreal[5+dij],vpreal[6+dij]),PARA='FREQ'),
              ))

IMPR_TABLE(TABLE=FREQROT)

TEST_TABLE(TABLE=FREQROT, NOM_PARA='FREQ', VALE=123.915,
           FILTRE=( _F(  NOM_PARA = 'NUME_ORDRE', VALE_I = 1,),),
           REFERENCE='NON_REGRESSION',)

TEST_TABLE(TABLE=FREQROT, NOM_PARA='FREQ', VALE=124.546,
           FILTRE=( _F(  NOM_PARA = 'NUME_ORDRE', VALE_I = 2,),),
           REFERENCE='NON_REGRESSION',)

TEST_TABLE(TABLE=FREQROT, NOM_PARA='FREQ', VALE=497.033,
           FILTRE=( _F(  NOM_PARA = 'NUME_ORDRE', VALE_I = 3,),),
           REFERENCE='NON_REGRESSION',)

TEST_TABLE(TABLE=FREQROT, NOM_PARA='FREQ', VALE=499.575,
           FILTRE=( _F(  NOM_PARA = 'NUME_ORDRE', VALE_I = 4,),),
           REFERENCE='NON_REGRESSION',)


FIN()

