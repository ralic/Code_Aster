# MODIF  DATE 11/12/2007   AUTEUR GNICOLAS G.NICOLAS 
# TITRE COUPLAGE ASTER_HOMARD - CAS BIDIMENSIONNEL
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS
# Attention :ceci est un test de non regression et non pas d'evaluation
# de l'adaptation de maillage.
# . Information
# . Adaptation dans une boucle python avec arret sur critere de convergence
# . Sans mise a jour de champs
# . Cas 2D
# . Elements SEG2, TRIA3
# . GROUP_NO, GROUP_MA
#
# option PAR_LOT='NON' indispensable pour affecter des valeurs de
# tables dans des variables PYTHON (paragraphe 4.9)
#
DEBUT(CODE=_F(NOM='ZZZZ121A', NIV_PUB_WEB='INTERNET', VISU_EFICAS='NON'), PAR_LOT='NON', DEBUG=_F(SDVERI='OUI'))
# 1. Definition des materiaux
#
MATER1=DEFI_MATERIAU(
           ELAS=_F(  E = 180000., NU = 0.30, ALPHA = 15.E-6, RHO = 7700.,  ) )

MATER2=DEFI_MATERIAU(
           ELAS=_F(  E = 220000., NU = 0.33, ALPHA = 16.E-6, RHO = 8300.,  ) )
#
# 2. Lecture du maillage et test de la macro sur l information
#    Declaration et dimensionnement a 10 du tableau M des concepts maillage
#    On affecte les valeurs a None (peu importe)
#    Initialisation de la premiere valeur M[1]
#
M=[None]*10
#
M[1]=LIRE_MAILLAGE( )
#
MACR_INFO_MAIL(
              VERSION_HOMARD='V8_11',
              MAILLAGE=M[1],
              QUALITE='OUI',
              INTERPENETRATION='OUI',
              CONNEXITE='OUI',
              TAILLE='OUI'
               )
#
# 3. Declaration et dimensionnement a 10 des tableaux des concepts variables
#    Initialisation a zero de la variable PYTHON pop
#    Les tableaux de concepts n existent pas vu d aster a l execution.
#    accas renomme MODE[k] en MODE_k. attention : en cas de reprise, c est
#    le concept MODE_k qui est connu dans la base. De plus, il faut etre
#    vigilant a ne pas depasser les huit caracteres pour le nom du concept,
#    underscore k compris.
#
MODE=[None]*10
MATE=[None]*10
CHAR=[None]*10
RESU=[None]*10
MCG =[None]*10
RELV=[None]*10
pop =0.
#
# 4. Boucle sur k : a chaque iteration, calcul mecanique et raffinement
#                   du maillage. le maillage M[k] produit par HOMARD a la
#                   fin de l iteration k est utilise a l iteration k+1
#    ATTENTION :    en python, il faut indenter les commandes sous la
#                   structure de controle (voir for statement dans PYTHON
#                   REF MANUAL)
#    ATTENTION :    range(1,10) signifie que k varie de 1 a 9
#                   (voir for statement dans PYTHON REF MANUAL)
#
for k in range(1,10):
#
# 4.1. Modele mecanique
#      Les concepts variants d une iteration a l autre peuvent etre
#      entrant ou sortant des commandes
#
   MODE[k]=AFFE_MODELE(    MAILLAGE=M[k],
                           AFFE=_F(  TOUT = 'OUI',   PHENOMENE = 'MECANIQUE',
                                     MODELISATION = 'D_PLAN',   ) )
#
# 4.2. Le MODI_MAILLAGE n'est utile que la premiere fois, car HOMARD conserve
#      les orientations
#
   if k==1:
      M[k]=MODI_MAILLAGE( reuse=M[k],
                          MAILLAGE=M[k],
                          ORIE_PEAU_2D=_F(GROUP_MA=('BORD_GAU','BORD_SUP',),)
                         )
#
# 4.3. MISE EN PLACE DES MATERIAUX
#
   MATE[k]=AFFE_MATERIAU(  MAILLAGE=M[k],
                           AFFE=(
       _F(  GROUP_MA = 'MOITIE1',    MATER = MATER1,    ),
       _F(  GROUP_MA = 'MOITIE2',    MATER = MATER2,    ))
                         )
#
# 4.4. Les grandeurs globales
#
   MCG[k]=POST_ELEM(   MODELE=MODE[k],
                       CHAM_MATER=MATE[k],
      MASS_INER=_F(  GROUP_MA = ( 'MOITIE1', 'MOITIE2', ),   TOUT = 'OUI', ),
      TITRE='MASSE, CENTRE DE GRAVITE ET INERTIE DE LA STRUCTURE'
                    )
#
   IMPR_TABLE( TABLE=MCG[k] )
#
# 4.5. Chargements
#
   CHAR[k]=AFFE_CHAR_MECA(    MODELE=MODE[k],
                   DDL_IMPO=_F(  GROUP_NO = 'ORIGINE',     DY = 0.,),
                   PRES_REP=_F(  GROUP_MA = 'BORD_SUP',    PRES = 1000.,),
                  FACE_IMPO=_F(  GROUP_MA = 'BORD_GAU',    DNOR = 0.,)
                          )
#
# 4.6. Resolution
#
   RESU[k]=MECA_STATIQUE(   MODELE=MODE[k],
                            CHAM_MATER=MATE[k],
                            EXCIT=_F(  CHARGE = CHAR[k],     )
                         )
#
# 4.7. Calcul de l indicateur d erreur
#
   RESU[k]=CALC_ELEM(       reuse=RESU[k],
                            RESULTAT=RESU[k],
                            OPTION=( 'SIGM_ELNO_DEPL',
                                     'ERZ1_ELEM_SIGM', )
                    )
#
# 4.8. IMPRESSIONS POUR CREER LA BASE DU CAS-TEST HOMARD med_2d_carre_d1 A L'ITERATION K
#
###   nomfic="MED_%d" %k
###   DEFI_FICHIER (UNITE=40+k,FICHIER='nomfic');
###   IMPR_RESU ( UNITE=40+k, FORMAT='MED', RESU=_F(
###               RESULTAT=RESU[k], NOM_CHAM='ERZ1_ELEM_SIGM', NOM_CMP='ERREST'  ) ) ;
#
# 4.9. Extraction du deplacement au noeud "OPPOSE" dans une table
#
   RELV[k]=POST_RELEVE_T(
       ACTION=_F(  RESULTAT = RESU[k],
                   INTITULE = 'DEPLACEMENT',
                   NOM_CHAM = 'DEPL',
                   TOUT_ORDRE = 'OUI',
                   OPERATION = 'EXTRACTION',
                   GROUP_NO = 'OPPOSE',
                   NOM_CMP = ( 'DX',  'DY',),
                 )
                      )
#
   IMPR_TABLE( TABLE=RELV[k] )
#
# 4.10. Affectation du reel contenu dans la table RELV
#     (ligne 'DX', colonne 1) dans la variable python pop
#
   pom=pop
   pop=RELV[k]['DX',1]
#
# 4.11. Le critere d arret des iterations porte sur la variation du
#      deplacement "DX" du noeud "OPPOSE" entre k et k+1
#      ATTENTION : comme pour "FOR", decalage de l identation sous
#                  la structure de controle "IF"
#      ATTENTION : sortie de la boucle sur k avec "BREAK", on reprend
#                  en 5. avec les TEST_RESU
#                  (voir break statement dans PYTHON REF MANUAL)
#
###   print "Iterations  : iteration numero",k," ",abs(pop-pom)
###   print "DX(",k,")=",pom,"   DX(",k-1,")=",pop
   if abs(pop-pom)<1.0e-6:
     print "arret des iterations  : iteration numero",k
     print "DX(",k,")=",pom,"   DX(",k-1,")=",pop
     break
#
# 4.12. Adaptation du maillage de k vers k+1
#       ATTENTION : on est dans le cas particulier d une macro commande
#       avec un concept sortant nomme derriere un mot cle simple
#       ( MAILLAGE_NP1 ). Or les tableaux de concepts n existent pas vu
#       d aster a l execution. Accas renomme M[k] en M_k. Il faut donc
#       evaluer la chaine de caractere CO('M_i') avec i=k+1
#       Le format %d indique qu il doit evaluer l entier k+1 donne
#       derriere le deuxieme % (FORMAT C++)
#
   M[k+1]=CO('M_%d' % (k+1))
#
   MACR_ADAP_MAIL(
              VERSION_HOMARD='V8_11',
              ADAPTATION='RAFFINEMENT',
              MAILLAGE_N = M[k],
              MAILLAGE_NP1 = M[k+1],
              RESULTAT_N = RESU[k],
              INDICATEUR = 'ERZ1_ELEM_SIGM',
              NOM_CMP_INDICA='ERREST',
              CRIT_RAFF_PE = 0.10,
              NIVE_MAX = 5,
              QUALITE='OUI',
              INTERPENETRATION='NON'
                 )
#
# 5. fin de la boucle sur k
#
   TCPU=INFO_EXEC_ASTER(LISTE_INFO='CPU_RESTANT')
   valcpu=TCPU['CPU_RESTANT',1]
   print "valcpu=",valcpu

   IMPR_TABLE(TABLE=TCPU);

   DETRUIRE(CONCEPT=(_F(NOM=TCPU),))

   TUL=INFO_EXEC_ASTER(LISTE_INFO='UNITE_LIBRE')
   valul=TUL['UNITE_LIBRE',1]
   print "ul=",valul

   IMPR_TABLE(TABLE=TUL);

   TEST_TABLE( TABLE=TUL,REFERENCE = 'NON_REGRESSION', VERSION = '7.01.01',
            NOM_PARA='UNITE_LIBRE', VALE_I=99  )

   DETRUIRE(CONCEPT=(_F(NOM=TUL),))

   if valcpu< 5.0:
     break

#
# 6. fin de la boucle sur k
#
TEST_RESU(RESU=(
       _F(  RESULTAT = RESU[4],   NUME_ORDRE = 1,
            NOM_CHAM = 'DEPL',    GROUP_NO = 'OPPOSE',
            CRITERE = 'RELATIF',  PRECISION = 1.E-6,
            NOM_CMP = 'DX',       VALE = 5.093375E-03,
            REFERENCE = 'NON_REGRESSION', VERSION = '7.01.01' ),
       _F(  RESULTAT = RESU[4],   NUME_ORDRE = 1,
            NOM_CHAM = 'DEPL',    GROUP_NO = 'OPPOSE',
            CRITERE = 'RELATIF',  PRECISION = 1.E-6,
            NOM_CMP = 'DY',       VALE = -2.7634976E-02,
            REFERENCE = 'NON_REGRESSION', VERSION = '7.01.01' ))
          )
#
TEST_RESU(RESU=(
       _F(  RESULTAT = RESU[5],   NUME_ORDRE = 1,
            NOM_CHAM = 'DEPL',    GROUP_NO = 'OPPOSE',
            CRITERE = 'RELATIF',  PRECISION = 1.E-6,
            NOM_CMP = 'DX',       VALE = 5.0939774E-03,
            REFERENCE = 'NON_REGRESSION', VERSION = '7.01.01' ),
       _F(  RESULTAT = RESU[5],   NUME_ORDRE = 1,
            NOM_CHAM = 'DEPL',    GROUP_NO = 'OPPOSE',
            CRITERE = 'RELATIF',  PRECISION = 1.E-6,
            NOM_CMP = 'DY',       VALE = -3.158715E-02,
            REFERENCE = 'NON_REGRESSION', VERSION = '7.01.01' ))
          )
#

FIN( )
