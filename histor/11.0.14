

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 07/04/2011 - 04:32:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 017189 DU 2011-06-23 10:44:06
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.12, les cas-tests ssnv182a,g, ssnv209b, d,e et k sont NOOK sur Aster4, Rocks et Calibre5.
FONCTIONNALITE
   Probleme
   ========
   
   Bug introduit lors de l'archivage du VALE_CONT dans le cas XFEM.
   
   Pour construire VALE_CONT, on a besoin de savoir si une quantité a déjà été calculée sur
   un noeud donné.
   Pour tester ça, on utilisait le LOGICAL du CHAM_NO qu'on archivait.
   Or, depuis la 11.0.11, ce LOGICAL est forcément .TRUE. (nécessaire car on a rempli le
   CHAM_NO à zéro pour l'instant initial)
   Donc le test faisait croire que l'on avait calculé les valeurs pour ce noeud, ce qui était
   faux.
   
   Solution
   ========
   
   On utilise un vecteur _local_ lors du calcul de VALE_CONT et non le CHAM_NO lui-même pour
   vérifier si la valeur a déjà été calculée au noeud 
   Correction xmmres.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    les cas-tests casses
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017191 DU 2011-06-23 11:00:30
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.12, les cas-tests hsna100a, b, d et e et ssnl126b s'arretent en erreur fatale sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   HSNA100*
   
   
   La routine NMARPR devait permettre l'écrasement des valeurs précédentes dans l'archivage
   (avec l'activation DETR_NUME_SUIVI)
   
   Malheureusement la routine utilitaire qui recherchait l'instant à écraser était écrite
   n'importe comment: au lieu de chercher le numéro d'ordre dans la SD EVOL_NOLI qui
   correspond à la valeur de l'instant à écraser, on cherchait ... dans la liste d'instants !
   On trouvait donc toujours 1 !
   
    N'importe quoi !
   
   On modifie NMTTCH pour chercher dans la liste des instants stocké dans la SD EVOL_NOLI
   (routine RSLIPA)
   
   Il faut modifier les cas-tests car on fait des TEST_RESU sur des numéros d'ordre, qui ont
   bougé, par définition.
   
   Lors du chantier sur l'ARCHIVAGE (en 10.3.14), j'avais décalé tous les test_resu de douze
   numéros d'ordre.
   C'était une erreur: ça révélait le bug de DETR_NUME_SUIV. Je n'ai pas été assez rigoureux.
   On redécale de douze dans l'autre sens.
   
   SSNL126*
   
   Cas particulier d'archivage qui n'avait pas été prévu: le champ n'existe pas toujours.
   Typiquement, pour le flambement, parfois le calcul ne donne rien (pas de mode critique
   détecté ou on est dans l'état initial). On teste l'existence du champ avant d'essayer de
   le stocker.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    les cas-tests casses
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017192 DU 2011-06-23 11:08:47
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    En NEW11.0.12, les cas-tests erreu07a et zzzz258a xc3xa9chouent sur sur Aster4, Rocks et Calibre 5.
FONCTIONNALITE
   Probleme
   ========
   
   En NEW11.0.12, les cas-tests erreu07a et zzzz258a échouent sur sur Aster4, Rocks et Calibre 5.
   
   
   Solution
   ========
   
   Ces deux cas-tests vérifient l'interception des erreurs.
   Or l'erreur qui correspond à la vérification de la cohérence des variables internes
   n'était plus lancée.
   Problème dans nmetl3: la routine de vérification NMELT3 n'était pas bien placée (on ne
   vérifiait que si l'utilisateur utilisait un EVOL_* en ETAT_INIT)
   
   Correction nmetl3.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    les cas-tests casses
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017133 DU 2011-06-15 13:40:08
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Resorption options VARI_ELGA_ELNO et SIEF_ELGA_ELNO
FONCTIONNALITE
   Dans le cadre de la fiche issue17073, on résorbe les options VARI_ELGA_ELNO et SIEF_ELGA_ELNO.
   
   Ces options servaient à transférer les champs de contraintes et de variables internes de
   ELNO à ELGA.
   Elles ne servent plus (évolution de la routine MENOGA). On résorbe donc.
   
   Résorption:
   
   CATSUPPR sief_elga_elno options
   CATSUPPR vari_elga_elno options
   
   Modifs des catalogues
   
   gener_me2dg_1.cata   gener_me3d_3.cata   gener_medgn_2.cata  gener_meshb3.cata
   gener_me2dg_2.cata   gener_me3dg_1.cata  gener_medit0.cata   gener_mv2d_2.cata
   gener_me2dsi_2.cata  gener_me3dg_3.cata  gener_medit1.cata   gener_mv3d_3.cata
   gener_me2dt0.cata    gener_meax_2.cata   gener_medpg2.cata   gener_mv3dn_3.cata
   gener_me2dt1.cata    gener_meaxs2.cata   gener_medpl2.cata   meca_hexs8.cata
   gener_me2tr0.cata    gener_mecpg2.cata   gener_medtr0.cata   mecpqs4.cata
   gener_me2tr1.cata    gener_mecpl2.cata   gener_medtr1.cata   medpqs4.cata
   
   Modifs Fortran:
   menoga.f, te0020.f, te0098.f, te0039.f, te0159.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR beaurain     BEAURAIN Jerome        DATE 07/04/2011 - 02:03:18

--------------------------------------------------------------------------------
RESTITUTION FICHE 017169 DU 2011-06-21 12:19:52
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    Routine nmforn - dxc3xa9faut de validation
FONCTIONNALITE
   Dans les problèmes d'endommagment non locaux, on vérifie la convergence sur les 
   degrés de liberté de déplacement et d'endommagement simultanément. Or ces deux 
   grandeurs ont des dimensions différentes. Ce qui peut rendre difficile la 
   comparaison des résidus sur chacun de ces degrés de liberté. On introduit alors 
   un vecteur de référence qui permet d'adimensionner les résidus. 
   
   Dans les catalogues d'éléments GVNO le vecteur elementaire EREFCO était declaré 
   avec les variables SIGM et DAMG (nom donné aux degré de liberté d'endommagement 
   dans GVNO). Or, DAMG_REFE n'était pas introduit dans les catalogues et routines 
   de RESI_REFE_RELA, qui permettent sa création et son initialisation. Dans les 
   catalogues d'éléments de GRAD_VARI, on déclare VARI en plus de SIGM dans 
   EREFCO. VARI_REFE est donc déjà existant dans le code. Par similarité entre 
   DAMG et VARI, qui désignent tout les deux les degrés de liberté d'endommagement 
   aux noeuds, on choisit de prendre la même nomination dans EREFCO pour les 
   catalogues de GVNO ==> EREFCO = (SIGM,VARI).  
   Si l'utilisateur désire travailler avec des critères de référence, il devra 
   donc déclarer SIGM_REFE (ce qui était déjà le cas) et ou VARI_REFE.
   
   Pour la validation, on choisit de modifier l'un des cas test existant pour GVNO 
   (ssnp307a), en vérifiant désormais la convergence à partir de RESI_REFE_RELA. 
   (On déclare SIGM_REFE comme cela est fait classiquement pour GRAD_VARI). 
   
   Impact catalogues :
   gener_medgn_2.cata (éléments D_PLAN_GVNO et AXIS_GVNO)
   gener_mv3dn_3.cata (éléments 3D_GVNO)
   
   Modification du cas test :
   ssnp307a.comm
   
   Impact documentation :
   Modification de V6.03.307 pour la version NEW11.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V6.03.307
VALIDATION
    CAS TEST
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR colombo      COLOMBO Daniele        DATE 07/05/2011 - 06:02:54

--------------------------------------------------------------------------------
RESTITUTION FICHE 016935 DU 2011-05-16 17:17:10
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    X-FEM: DEFI_FISS_XFEM/DEFI_GRILLE ne conserve pas le domaine de localisation
FONCTIONNALITE
   Avec la restitution de la fiche 15650, j'ai introduit la possibilité de définir une
   fissure sur un maillage en gardant à l'identique la même grille auxiliaire (et les level
   sets y définies) utilisée pour la définition de la même fissure sur un autre maillage.
   Cela est nécessaire pour l'utilisation de Homard sur un maillage où on veut propager une
   fissure par PROPA_FISS.
   
   Toutefois les modifications de DEFI_FISS_XFEM introduites avec la fiche 15650 ne tiennent
   pas en compte que la fissure définie sur la grille auxiliaire à garder (mot clé
   DEFI_FISS_GRILLE) peut être issue par un calcul PROPA_FISS où la localisation du domaine a
   été utilisée, c'est-à-dire que les informations sur la localisation du domaine et sur les
   domaines de projection entre grille auxiliaire et maillage ne sont pas correctement gardées.
   
   En conséquence, à l'heure actuelle l'utilisation de PROPA_FISS sur une fissure définie par
   DEFI_FISS_XFEM/DEFI_FISS_GRILLE ne marche pas dans le cas où la grille arrive d'une
   fissure calculée par PROPA_FISS.
   
   
   SOLUTION
   --------
   
   Il suffit de copier dans la SD de la nouvelle fissure les parties de SD de la fissure
   existante qui sont liées à la localisation du domaine et à la projection entre grille
   auxiliaire et maillage:
   
   sd_xfem:
      .PRO.RAYON_TORE
      .PRO.NOEUD_TORE
   
   Ces informations sont stockées au niveau de fissure (sd_xfem) et pas au niveau de champs
   level sets (sd_cham_no), ce qui rende nécessaire éliminer l'option qui permet de définir
   les level sets sur la grille auxiliaire à garder directement en donnant les champs level
   sets (DEFI_FISS_XFEM/DEFI_FISS_GRILLE/CHAM_NO_*_GRILLE), introduite avec la fiche 15650.
   En effet dans ce cas c'est impossible de récupérer la fissure définie par les champs
   donnés et donc de récupérer et copier les informations sur la localisation et la projection.
   
   On change donc la syntaxe de DEFI_FISS_XFEM pour ce qui concerne la définition d'une
   grille auxiliaire:
   
   nouvelle_fiss = DEFI_FISS_XFEM(...
                                  / MODELE_GRILLE = …,
                                  / FISS_GRILLE = …,
                                  ...)
   
   Si on utilise MODELE_GRILLE, les level sets sont calculées directement sur le modèle
   grille donné. Par contre, si on utilise FISS_GRILLE, la grille auxiliaire associée à la
   fissure donnée est gardée à l'identique pour la nouvelle fissure «nouvelle_fiss».
   
   
   MODIFICATIONS SD_FISS
   ---------------------
   
   Dans le cas où la fissure est définie en donnant directement les champs level sets
   (DEFI_FISS_XFEM/DEFI_FISS/CHAMP_NO_LS*) et on n'utilise pas une grille auxiliaire, on
   pourrait perdre les informations éventuelles sur la localisation du domaine de calcul et
   sur le domaine de projection qui étaient associées à la fissure de laquelle les champs ont
   été extraits. Cela n'est pas le cas si aucune localisation du domaine et aucune grille
   auxiliaire n'ont été utilisées, ce qui est vrais seulement dans les situations suivantes:
   
   1. la fissure à l'origine n'a pas été calculée par PROPA_FISS
   2. la fissure à l'origine a été calculée par PROPA_FISS mais aucune grille auxiliaire n'a
   été utilisée et on a utilisé ZONE_MAJ='TOUT'
   
   En considérant que cette option de définition de la fissure est indispensable (voir
   utilisation de Homard), la seule solution envisagée est l'émission d'une alarme par
   PROPA_FISS si on cherche de propager une fissure dans un cas qui n'est pas un des deux
   ci-dessus: c'est à l'utilisateur de vérifier.
   
   On modifie donc la sd_xfem pour stocker le fait que les champs level sets du maillage ont
   été donnés directement:
   
   sd_xfem:
      .CHAMPS.LVS -> scalaire booléen facultatif
   
   
   CAS TEST
   --------
   
   Le cas test existant zzzz283a n'est pas capable de détecter le problème décrit dans cette
   fiche parce qu'il se limite à vérifier si les level sets de la grille auxiliaire sont
   transférées correctement à la nouvelle fissure.
   Je change donc ce cas test. Je propage une fissure 3D avec un grille auxiliaire en
   utilisant une avancée et un angle constants au long du fond (même technique de celle
   utilisée dans sslv316). Après je raffine le maillage avec Homard et je définis la fissure
   sur le maillage raffiné en gardant la grille auxiliaire (option FISS_GRILLE discutée dans
   cette fiche). Je propage enfin cette fissure sur le maillage raffiné en utilisant une
   avancée et un angle constants au long du fond. Je connais la position du fond et je vais
   vérifier que le calcul éléments finis a donné le même résultats que celui attendu.
   Ce test permet donc de vérifier si la copie de la grille est correcte à la fois pour ce
   qui concerne les level sets et pour ce qui concerne l'information sur la localisation du
   domaine et sur le domaine de projection.
   
   
   DOCUMENTATION IMPACTÉE
   ----------------------
   
   U4.82.8 -> DEFI_FISS_XFEM
   D4.10.2 -> sd_xfem
   V1.01.283 -> cas test zzzz283a
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.3.17
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.82.8, D4.10.2, V1.01.283
VALIDATION
    zzzz283a
NB_JOURS_TRAV  : 3.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016973 DU 2011-05-20 11:14:48
TYPE anomalie concernant Code_Aster (VERSION 10.3)
TITRE
    X-FEM: fonds fissure formés par plusieurs morceaux pas correctement manipulés par l'algorithme upwind/simplexe de lissage de la vitesse
FONCTIONNALITE
   Le lissage du champ vitesse d'avancée de la fissure introduit avec la fiche 15271 pour les
   méthodes upwind et simplexe ne tient pas compte que le fond de la fissure pourrait être
   formé par plusieurs morceaux.
   
   Dans ce cas l'algorithme de lissage pourrait calculer pour un noeud du maillage un faux
   point projeté sur le fond de la fissure, c'est-à-dire un point qui est dehors des morceaux
   qui forment le fond de la fissure et qui se trouve sur l'arête reliant deux points
   d'extrémité de deux morceaux.
   
   On corrige.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 10.3.17
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 11.0.0
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test personel
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR corus        CORUS Mathieu          DATE 06/29/2011 - 10:15:24

--------------------------------------------------------------------------------
RESTITUTION FICHE 017199 DU 2011-06-24 10:27:35
TYPE express concernant Code_Aster (VERSION 11.1)
TITRE
    coquilles dans vecind.f
FONCTIONNALITE
   Problemes :
   ----------
   
   1) Charles a trouve un bug dans vecind.f : lorsque certains vecteurs sont annules par
   vpgskp, et qu'on construit une nouvelle base de Ritz, on ne recopie que les vecteurs non
   nuls. J'ai ecrit une betise dans cette recopie, en inversant le vecteur a recopier, et
   celui a ecraser...
   
   2) Meme genre de chose, pour selectionner au mieux les vecteurs, je les normes, en prenant
   soin d'annuler les Lagranges. Or, dans le cas de l'utilisation de la norme L2, on ne peut
   pas remonter a la numerotation de reference (seul le pointeur vecrs la matrice est
   passee), et donc pas annuler les Lagranges, si ca n'a pas ete fait avant. Il faut donc
   supprimer l'appel a zerlag fait dans ce cas la.
   
   Solutions :
   -----------
   1) Je reprends l'appel a LCEQVN
   
   2) Je supprime l'appel a ZERLAG
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    Aucune
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR courtois     COURTOIS Mathieu       DATE 07/05/2011 - 09:22:48

--------------------------------------------------------------------------------
RESTITUTION FICHE 017224 DU 2011-07-01 06:42:35
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    NEW11.0.13 - cas-tests petsc01a, petsc01d, petsc01g, perf013e en erreur dans DEFI_PART_FETI
FONCTIONNALITE
   Problème
   ========
   
   Ces tests s'arrêtent en erreur dans DEFI_PART_FETI lors d'un 
   appel à la méthode LIST_GROUP_MA d'un maillage.
   
   Correction
   ==========
   
   Lors de la dernière mise à jour (séparation concepts/sd), 
   cette méthode a été modifiée. Elle utilise maintenant le 
   catalogue de SD contre getcolljev auparavant.
   Quand la collection interrogée est vide, getcolljev retourne 
   un dictionnaire vide alors que la méthode get sur un objet 
   collection retourne None dans ce cas. Il faut donc traiter 
   un peu différemment ce cas particulier.
   
   C'est le cas pour ces tests où il n'y a pas de groupe de 
   maille.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    petsc01a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017243 DU 2011-07-04 05:52:28
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Problxc3xa8me de performance de CALC_MODE_ROTATION
FONCTIONNALITE
   Suite la restitution de issue17201, les temps d'exécution 
   des  cas-tests utilisant CALC_MODE_ROTATION se sont 
   fortement  dégradés.
   
   C'est essentiellement la modification de la méthode 
   __getitem__ des tables qui explique cette dégradation.
   
   Exemple : TAB['INST', 4] pour extraire la valeur de INST de 
   la 4ème ligne.
   
   Cette méthode (très ancienne) permet de récupérer la valeur 
   d'une case dans une table. Elle faisait "du getvecjev en 
   dur" dans la structure de données table.
   Lors de l'évolution, on a utilisé la méthode EXTR_TABLE (qui 
   convertit la table_sdaster en Table python), puis la méthode 
   values qui retourne les valeurs d'une colonne. Cela permet 
   de faire (en deux lignes) sans connaître la structure des 
   tables.
   On convertit donc la table entière, ce qui coûte forcément.
   
   On peut faire évoluer la méthode EXTR_TABLE pour ne 
   convertir qu'un sous-ensemble des colonnes : TAB.EXTR_TABLE('INST') ou TAB.EXTR_TABLE(['INST', 'NOEUD', 
   'DX'])
   C'est bien plus rapide dès que la table à quelques 
   paramètres.
   
   Mais on peut encore gagner environ 20% en utilisant 
   getvecjev.
   
   Sur le test sdll124a (dans un état intermédiaire), on a 
   selon comment est fait __getitem__ :
   - avec EXTR_TABLE() . . .: 29 s
   - avec EXTR_TABLE(para) .: 18 s
   - avec getvecjev . . . . : 15 s
   
   
   Mais l'essentiel de la perte de temps est dû à l'utilisation 
   qui est faite des tables.
   En effet, on produit une table qui contient des résultats 
   pour nbF fréquences en nbN noeuds, puis on fait une double 
   boucle nbF x nbN. A chaque itération, on récupère plusieurs 
   valeurs dans la table avec __getitem__.
   La conversion de la table ne doit être faite qu'une fois !
   
   De plus, le traitement peut être fait par colonne en créant 
   de nouvelles colonnes, résultats de formule sur les colonnes 
   existantes. Limiter les boucles sur les lignes au strict 
   nécessaire.
   
   Après modification, on obtient :
   
   cas-test . .NEW10 . .NEW11 . .modif
   sdll124a : .12.27 . .24.66 . . .8.9
   sdll125a : .30.35 . 125.48 . . 26.7
   sdll125b : .35.53 . 132.38 . . 26.9
   sdll129a : 190.22 . 500.18 . .163.0
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdll124a, sdll125a, sdll125b, sdll129a
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desoza       DE SOZA Thomas         DATE 07/04/2011 - 05:07:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 017205 DU 2011-06-27 11:20:38
TYPE anomalie concernant Code_Aster (VERSION 10.1)
TITRE
    Contact/frottement, mxc3xa9thode contine, problxc3xa8me de convergence en version 10
FONCTIONNALITE
   Anomalie
   ========
   
   Le calcul joint (expansion axisymétrique d'une pastille dans un tube) avec contact continu
   tourne en V9.9 mais échoue en V10.5 (nombre d'itérations de Newton).
   
   Analyse
   =======
   
   Le calcul tourne parfaitement en V11.0.13. Il s'agit donc d'une régression en 10 corrigée
   depuis en 11.
   Après étude, il s'avère que 2 anomalies existent mais seule celle en 10 était
   problématique (liées à la fonctionnalité SANS_GROUP_NO_FR) :
   - en V10 : on n'annulait pas le second membre lié au frottement, rendant ainsi LAGS_F1 non
   nul et perturbant la convergence
   
   - en V11 : on réalise le traitement de SANS_GROUP_NO_FR dans le cas contact alors que ce
   n'est pas nécessaire
   
   En V11 le calcul tourne car la remise plat des TE a indirectement rétabli l'annulation du
   second membre.
   
   Validation
   ==========
   
   Impact V10 : mmmvec.f
   Impact V11 : te0364.f te0365.f mmmpha.f
   
   Après correction le calcul joint tourne en V10 et donne les mêmes résultats qu'en V11.
   
   Les tests utilisant SANS_GROUP_NO_FR fonctionnent toujours.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    zzzz292a + perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017070 DU 2011-06-06 10:56:35
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Tests feti008a/feti009a/feti010a
FONCTIONNALITE
   La possibilité de faire du contact continu avec la méthode FETI a disparu en version 10.1.3.
   Pour l'instant il n'est pas prévu de la réimplémenter, on supprime donc les tests validant
   ce "couplage" dans la mesure où ils ne font plus que du calcul continu et n'apportent pas
   de plus-value à la couverture de code (vérifié avec RESU_COUVERTURE).
   
   Les 3 documents V1.04.108,V1.04.109,V1.04.110 sont supprimés de l'entrepôt. ATTENTE_DOC :
   passage direct à l'état FERME.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : V1.04.108,V1.04.109,V1.04.110
VALIDATION
    nxc3xa9ant
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 07/04/2011 - 05:07:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 013793 DU 2009-08-31 07:28:24
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    CREA_CHAMP avec OPERATION=DISC passage ELGA -> ELEM
FONCTIONNALITE
   Problème :
   ----------
   Joumana (et Jean-Michel ?) souhaite utiliser CREA_CHAMP / OPERATION='DISC' pour
   transformer un champ 'ELGA' en champ 'ELEM'.
   
   Réponse :
   ---------
   La commande ne le permet pas et la doc ne dit pas que c'est possible.
   
   Il serait très difficile de "généraliser" cette fonctionnalité, car cela veut dire que
   TOUS les éléments finis doivent déclarer un mode local "ELEM" associé à chaque mode local
   "ELGA".
   
   En revanche, s'il s'agit de faire une "moyenne" arithmétique pour n'avoir plus qu'une
   seule valeur par maille, on pourrait envisager de créer une "CARTE", car cela ne nécessite
   pas d'enrichir tous les catalogues d'éléments finis.
   
   Conclusion :
   ------------
   Je classe la fiche "sans suite" et j'attends qu'un utilisateur se manifeste à nouveau.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sans objet
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------
RESTITUTION FICHE 015581 DU 2010-09-22 13:15:55
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Suppression du mot-cle NUME_ORDRE dans LIRE_RESU
FONCTIONNALITE
   Problème :
   ----------
   Si j'ai bien compris la demande, l'utilisateur voudrait rendre facultatif le mot clé
   POSI_ORDRE de la commande LIRE_RESU au format IDEAS car cela conduit parfois à créer des
   sd_resultat dont les nume_ordre ne sont pas consécutifs, ce qui pose problème dans la
   commande DEFI_BASE_MODALE
                                                                                           
                                                                
   Réponse :
   ---------
   Dans l'étude jointe, 2 fichiers IDEAS sont lus pour créer 2 SD : resu_0 et resu_1
   On constate effectivement que dans resu_1, le numero d'ordre 4 est absent :
    
    IMPRESSION SEGMENT DE VALEURS >resu_1             .ORDR        <
    >>>>>
         1 -            1            2            3            5            6
         6 -            0            0            ...
                                                                
   Mais c'est la vie !
                                                                
   Dans une sd_resultat, le NUME_ORDRE est un entier qui sert à distinguer les instants,
   fréquences, NOEUD_CMP, ...
   Il n'est dit nulle part que ces numéros doivent etre postifs, ni consécutifs.
   Il ne faut pas confondre le numero d'ordre et le numéro de rangement qui lui varie de 1 à N.
                                                                
   Pour un numéro de rangement KRANG, on trouve son numéro d'ordre dans l'objet .ORDR :
   KORDR=.ORDR(KRANG)
                                                                
   Le problème vient de la programmation de DEFI_BASE_MODALE qui confond les 2 notions de
   numéro d'ordre et de numéro de rangement comme le prouve cet extrait de la routine ritz99.f :
                                                               
             CALL WKVECT(TEMOR1,'V V I',NBMOD1,LTORD1)
             DO 31 II=1,NBMOD1
               ZI(LTORD1+II-1)=II
    31       CONTINUE
             INORD=1
             CALL MOCO99(NOMRES,RESUL1,NBMOD1,ZI(LTORD1),INORD,.TRUE.)
                                                                
   Le vecteur jeveux TEMOR1 contient des numeros de rangement : 1,2,3, ...
   Mais la routine moco99.f attend une liste de numéros d'ordre :
         SUBROUTINE MOCO99(NOMRES,RESUL,NBMOD,LIORD,IORNE,SEUL)
   puisqu'elle fait :
           IOROL=LIORD(I)
           ...
           CALL RSEXCH(RESUL,CHMECA,IOROL,CHAMOL,IER)
                                                                                            
                                                                
   Détails :
   ---------
   On pourrait imaginer que LIRE_RESU ne cherche pas à lire systématiquement le NUME_ORDRE
   des champs à relire : lorsque POSI_ORDRE est absent, on donne comme numero d'ordre un
   entier variant de 1 à N :
     * 1er  champ à lire  -> nume_ordre = 1
     * 2eme champ à lire  -> nume_ordre = 2
     * ...
   Mais je ne suis pas favorable à cette évolution, car que doit-on faire si le ficher IDEAS
   contient :
        DEPL pour t=1
        DEPL pour t=2
        DEPL pour t=8
        DEPL pour t=9
    
        VITE pour t=1
        VITE pour t=6
        VITE pour t=7
        VITE pour t=9
                                                                
   Le numero d'ordre est la variable d'accès qui permet d'associer les différents champs (ici
   DEPL et VITE) pour un meme instant. En ce sens, il doit rester obligatoire.
                                                               
   Conclusion :
   ------------
   Le problème rencontré ne vient pas de la commande LIRE_RESU. Cette fiche est "sans suite".
   J'ai émis une nouvelle fiche d'anomalie concernant DEFI_BASE_MODALE (fiche 16674).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 016391 DU 2011-02-10 08:04:24
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Crxc3xa9ation du type de champ NOEU_SECH_R
FONCTIONNALITE
   Problème :
   ----------
   L'utilisateur ne peut pas créer de champ  NOEU_SECH_R avec CREA_CHAMP. Il souhaite une
   évolution du code.
   
   Réponse :
   ---------
   Je ne suis pas d'accord avec cette demande. L'opérateur ne crée pas de champ de SECH_R
   parce qu'il n'existe pas de grandeur SECH_R !
   
   Et je pense qu'ajouter une grandeur SECH_R ne ferait qu'ajouter de la complexité sans
   vériatble gain.
   
   Le problème est que l'opérateur qui calcule le séchage est l'opérateur THER_NON_LINE. Dans
   la structure de données produite, le séchage est stocké sous NOM_CHAM='TEMP' et la
   composante est 'TEMP'.
   Si on n'avait pas fait comme cela, il aurait fallu créer un nouveau PHENOMENE 'SECHAGE',
   un nouvel opérateur SECH_NON_LINE, de nouvelles AFFE_CHAR_SECH, ...
   
   Il est donc "naturel" que la variable de commande mécanique 'SECH' soit un champ de TEMP_R.
   
   Je propose de classer la fiche "sans suite"
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.05
--------------------------------------------------------------------------------
RESTITUTION FICHE 017014 DU 2011-05-26 08:37:59
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Passage des points de Gauss aux noeuds
FONCTIONNALITE
   Problème :
   ----------
   Dans l'étude jointe, quand on calcule les contraintes aux noeuds par :
     * CALC_ELEM / SIEF_ELNO + CALC_NO / SIEF_NOEU
   et par :
     * CREA_CHAMP / DISC : ELGA -> NOEU
                                                                                            
                           
   On n'obtient pas le meme résultat.
                                                                                            
                           
   Le champ produit par CREA_CHAMP / DISC semble un peu meilleur.
                                                                                            
                           
   Réponse :
   ---------
   Il n'y a pas de bug : le champ produit par CREA_CHAMP est "meilleur" car on triche
   (involontairement) un peu pour l'obtenir !
    
   En effet, dans le calcul CALC_CHAMP / DISC, le champ initial a été obtenu par une formule
   avec des champs de NEUT_R, les éléments de bord (QUAD4) sont concernés par le calcul car
   ils portent un champ ELGA de NEUT_R , ils sont
   donc extrapolés aux noeuds et ils participent au calcul de la moyenne.
                                                                                            
                           
   Et comme ils sont bien placés (au bord), ils "corrigent" l'extrapolation imprécise des
   éléments volumiques.
    
   En revanche, pour le calcul CALC_ELEM, seuls les éléments volumiques se préoccupent de
   SIEF_ELNO
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    xc3xa9tude jointe
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 017175 DU 2011-06-21 15:09:21
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    programmation incorrecte dans recugd.f (mais ce n'est pas grave)
FONCTIONNALITE
   Problème :
   ----------
   Les routines recude.f et recugd.f utilisées par les commandes DYNA_TRAN_MODAL,
   CALC_FLUI_STRU et PROJ_SPEC_BASE sont erronées vis à vis de la description de la structure
   de données CARTE (D4.06.05).
                                                                                            
                           
   En effet, dans la routine recugd.f, on accède aux entiers codés par la formule :
      ICODE = ZI(ICARD+3-1+2*IASSEF+II)
   où IASSEF a été récupéré dans recude.f par :
      IASSEF = ZI(ICARD+2)
                                                                                            
                           
   IASSEF est le nombre d'affectations dans la carte.
   Le bon décalage pour accéder aux entiers codés est de 2*IASSMX où IASSMX est le nombre
   "Max" d'affectations dans la carte.
                                                                                            
                           
   Si la carte est "surdimensionnée" (ce qui est le cas en général), IASSMX > IASSEF et la
   formule est fausse.
                                                                                            
                           
   Heureusement, quand on construit la carte (carele.CARGEOPO) dans la routine aceapo.f, on
   apelle la routine tecart.f qui a le bon gout de redimensionner la carte de façon que
   IASSMX = IASSEF.
   C'est un effet de biais qu'il vaut mieux éviter (si on enlève le "call tecart" le code est
   faux).
                                                                                            
                           
   Je propose donc de corriger les routines recude.f et recugd.f meme si cela ne change rien.
   C'est plus "juste".
                                                                                            
                           
   Correction :
   ------------
   J'ajoute l'argument IASSMX à la routine recugd.f pour pouvoir faire le bon décalage.
    
    
   Liste des fichiers impactés par la correction de la fiche:  17175
     aceapo.f  recude.f  recugd.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 017209 DU 2011-06-27 15:38:16
TYPE anomalie concernant Code_Aster (VERSION 9.1)
TITRE
    Problxc3xa8me dans la routine exchml.f
FONCTIONNALITE
   Problème :
   ----------
   Lors de la restitution de la fiche 17097, j'ai du étendre le périmètre d'utilisation de la
   routine exchml.f (CAS='TRICMP').
   Je ne sais pas pourquoi, mais j'en ai profité pour ajouté un cas ('COPIE') qui n'était pas
   utilisé (donc pas testé).
   La programmation du cas 'COPIE' est bugguée.
                                                                                            
                           
   Xavier Desroches pour un de ses développements est tombé sur le cas 'COPIE'. Pas de chance !
                                                                                            
                           
   Le cas 'COPIE' correspond au cas :
     1) le cham_elem "IN" a été calculé avec le mode local molo1
     2) le mode_local attendu pour le calcul est molo2
     3) Les 2 modes locaux molo1 et molo2 sont en réalité les memes (memes composantes et
   meme localisation) mais ils ont des noms différents dans le catalogue de l'élément.
                                                                                            
                           
   Correction :
   ------------
   On corrige la programmation de exchml.f
                                                                                            
                           
   Validation :
   ------------
   Un essai perso en surchargeant le catalogue de l'élément meca_hexa8 pour qu'il déclare
   sous 2 noms différents 2 modes locaux identiques.
    
    
   Liste des fichiers impactés par la correction de la fiche:  17209
     exchml.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    essai perso
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR fernandes    FERNANDES Roméo       DATE 07/05/2011 - 12:32:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 017088 DU 2011-06-09 10:24:10
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    options SIEQ_ELNO et INDL_ELGA par les modxc3xa9lisations AXIS_JHMS, PLAN_JHMS, D_PLAN_2DG et D_PAN_DIL : faux
FONCTIONNALITE
   Problème :
   ----------
   Les éléments QUAD8 des modélisations XXXX_JHMS sont sensés calculer l'option SIEQ_ELNO. Or
   le champs de SIEF_R "in" n'est pas du tout ce qui est attendu par le te0330.
   
   Il s'agit probablement d'un copier-coller lors de la création des catalogies de ces
   modélisations.
   
   On interdit donc l'appel à l'option SIEQ_ELNO (ajout du paramètre -1 dans les
   catalogues)pour ces modélisations de joints HM puisque cette option n'a pas de sens dans
   ce cas (voir doc R). Par ailleurs on interdit également l'appel aux options INDL_ELGA
   (indicateur de localisation), M_GAMMA et MASS_MECA (options des volumles finis).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 017124 DU 2011-06-14 12:58:29
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    options SIEQ_ELNO et INDL_ELGA par les modxc3xa9lisations D_PLAN_2DG et D_PAN_DIL : faux
FONCTIONNALITE
   Problème
   --------
   Les catalogues des modélisations second gradient *_2DG *_DIL font appel à l'option
   INDL_ELGA (indicateur de localisation).
   
   Cet appel n'a pas de sens pour ces modélisations puisque cet indicateur s'appuie sur le
   comportement mécanique premier gradient (voir doc R). On interdit donc cet appel (ajout du
   paramètre -1 dans les catalogues).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 017177 DU 2011-06-22 07:37:48
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    Couverture de code et fiche 9703
FONCTIONNALITE
   Quatre routines restituées n'ont jamais été couvertes :
   cabrsl
   dimsl
   epsdil
   epsreg
   
   Pour couvrir les 2 premieres : ajout du cas-test ssll117g
   Pour couvrir epsdil (voir fiche 13.372)
   
   Pour epsreg le résultat de validation conduit a un resultat FAUX.
   J'ai émis une fiche pour tracer ce problème (17.235).
   
   Par ailleurs, l'acces aux tests ssll117* est restreint. Il n'y a pas de raison à cela. Je
   modifie donc cet acces.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.01.117, V3.04.117
VALIDATION
    ssll117g, sslv117a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017235 DU 2011-07-01 13:02:05
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    modelisation D_PLAN_2DG avec resultat faux
FONCTIONNALITE
   Dans le cadre de la fiche 17177 j'ai ajoute un post-traitement avec l'option EPSI_ELGA et
   les resultats de post sont faux.
   
   Il s'agit d'une mauvaise initialisation dans la routine REGINI.
   Les résultats sont faux en post-traitement de EPSI_ELGA sur la partie second gradient
   (dans sa version complète uniquement).
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 9.0.26
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 9.0.26
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssll117
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 013372 DU 2009-05-05 05:14:00
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Extension au 3D des modxc3xa9lisations second gradient de dilatation
FONCTIONNALITE
   Objectif
   --------
   L'objectif de cette fiche est d'étendre dans Code_Aster les modélisations second
   gradient de dilatation au 3D (voir doc R5.04.03).
   Ces modélisations s'inscrivent dans le cadre des milieux à microstructure et ont
   comme objectif de donner des résultats convergents par rapport à la finesse du
   maillage pour éviter d'obtenir des solutions localisées.
   
   Validation
   ----------
   Pour valider ce développement plusieurs études ont déjà été réalisées, dont la
   dernière à fait l'objet d'une présentation lors des journées utilisateurs Code_Aster
   de 2011 (Plassart et al).
   
   On ajoute dans la base le cas-test sslv117a pour lequel on dispose d'une solution
   analytique.
   
   Impact informatique
   -------------------
   Répertoire Capy (ajout de la modelisation 3D_DIL):
   affe_char_meca_f.capy  affe_modele.capy
   
   Répertoire Cata:
   gener_3dilP1.cata  phenomene_modelisation__.cata
   
   Répertoire Fortran:
   cabrp1.f  dilcge.f  dilder.f  dilele.f  dilini.f  dimp1.f  epsdil.f  fnodil.f
   
   Répertoire Test:
   sslv117a.com0  sslv117a.comm  sslv117a.med  sslv117a.para
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V3.04.117, R5.04.03
VALIDATION
    sslv117a + plusieurs etudes
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017101 DU 2011-06-09 13:19:31
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    calcul de l'option SIGM_ELGA pour les options de THM
FONCTIONNALITE
   Origine de la fiche
   -------------------
   Dans le cadre de la fiche 17097, Jacques a introduit l'option SIGM_ELGA destiné à
   recueillir les "vraies" contraintes SIXX, ..., SIYZ calculées sur les PG du calcul à
   partir du champ SIEF_ELGA.
   
   Or, pour les modélisations THM avec 2 familles de points d'intégration, la partie
   mécanique est pas calculée uniquement sur la première famille. Comme Code_Aster impose que
   tous les PI portent les mêmes composantes, on est obligé de "definir" celles que l'on ne
   calcule pas (=> définition via l'état initial). Ceci peut alors conduire à des
   erreurs de post-traitement avec l'option SIGM_ELGA ou de visualisation dans Salome.
   
   Pour contourner ce probleme on recopie aux sommets les valeurs calculées aux points de
   gauss pour la partie mécanique. Cette copie n'a aucune incidence sur le calcul puisque les
   sommets n'interviennent pas dans l'intégration numérique, et cela évite les différents
   problèmes de
   post-traitement.
   
   On procède de la même façon pour les champs de variables internes.
   
   Les tests suivant de la base aster sont impactés pour cause de résultats modifiés en non
   régression (faux en post car basés sur les modélisations à intégration sélective)
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    etude perso
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 015334 DU 2010-07-13 11:41:55
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Evolution de DIS_CHOC
FONCTIONNALITE
   On ajoute une 8ème varaible interne à la loi DIS_CHOC (V8) pour stocker la distance entre
   les noeuds des mailles. Cette information est déjà calculée dans les routines fortran mais
   n'était pas stockée. Or elle facilite grandement le post-traitement pour la macro-commande
   POST_MAC3COEUR.
   
   Ajout du cas-test de validation mac3c02a (voir fiche 16961).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.02.103, U4.51.11
VALIDATION
    mac3c02a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016900 DU 2011-05-06 11:58:24
TYPE evolution concernant Code_Aster (VERSION 9.1)
TITRE
    Evolution de CREA_RESU / PERM_CHAM
FONCTIONNALITE
   Rappel du probleme :
   
   La commande CREA_RESU / PERM_CHAM (adapté pour traiter les problèmes de permutation des
   assemblages combustibles) ne permet pas de gérer
   les translations lorsque les mailles du groupe de mailles ne sont pas stockées dans le
   même ordre.
   
   Ce probleme vient du fait que la strategie de maillage à changer avec Salome. On ne
   procède plus par duplication des Assemblages mais on maille tout le coeur d'un coup. Par
   conséquent l'ordre des mailles dans les groupes de mailles n'est plus strictement le même
   d'un assemblage à l'autre.
   On ajoute une boucle pour récupere la bonne maille dans le groupe.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.02.103
VALIDATION
    mac3c02a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016961 DU 2011-05-19 14:28:01
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Modxc3xa9lisation des lames d'eau dans un rxc3xa9acteur
FONCTIONNALITE
   Objectif
   --------
   L'objectif de cette fiche est d'introduire dans Code_Aster une macro-commande pour
   estimer les jeux entre les assemblages combustibles (lames d'eau) en début de cycle
   à partir des informations provenant des DAMAC. Le principe de la méthodologie mise
   en oeuvre le principe est décrit dans la note CR-AMA-11.101.
   
   Pour ce développement on s'appuie sur l'outil de calcul des déformations d'assemblages
   combustibles (déjà mis en oeuvre - voir une application lors de la journée des utilisateurs
   Code_Aster 2010 - mais non encore intégré dans une macro-commande. Cette intégration est
   prévue d'ici fin 2011).
   
   
   Les limitations actuelles sont les suivantes
   --------------------------------------------
   1/ Les données provenant des mesures PARC ne permettent pas d'initialiser les déformations
   plastiques des lois de comportements (DIS_GRICRA et GRAN_IRRA_LOG). Une étude de
   sensibilité sera réalisée pour évaluer l'impact de ce défaut.
   
   2/ Les caractéristiques materiau ne prennent pas en compte l'historique d'irradiation
   (évolution à venir).
   
   Impact informatique
   -------------------
   On définit la macro-commande CALC_MAC3COEUR (voir syntaxe ci-dessous).
   L'utilisateur doit préciser sur quel type de coeur (TYPE_COEUR) il travaille
   (pour une vérification du choix utilisateur et de la cohérence des fichiers DAMAC).
   Le type TEST a été introduit pour faciliter les développements sur des cas plus simple
   qu'un coeur complet et pour permettre la validation de la macro-commande dans la base des
   cas-tests.
   
   Le mot-clé facteur 'LAME' précise qu'il s'agit d'un calcul de jeux entre les assemblages,
   en début de cycle après réorganisation du coeur. On attend alors 2 tables DAMAC comme
   décrit dans la note CR-AMA-11.101 (voir également doc U4.90.11). On ajoute également les 2
   maillages
   associés aux deux tables précédentes. Pour l'instant l'ajout de ces 2 maillages est
   obligatoire
   mais ceci deviendra facultatif prochainement étant donné que le code pourra générer
   directement
   les maillages à partir des informations des 2 tables par un appel (depuis Code_Aster) à
   Salome.
   
   
   evol_noli = CALC_MAC3COEUR(TYPE_COEUR = 'TEST','900','1300','N4','EPR',
                              LAME = _F(TABLE_N,
                                        TABLE_NP1,
                                        MAILLAGE_N,
                                        MAILLAGE_NP1),
                              DEFORMATION = _F(à venir))
   
   Capy:
   calc_mac3coeur_ops.capy
   
   datg:
   Description géométrique des assemblages et des coeurs (fichiers protégés)
   
   materiau:
   + description des caractéristiques matériaux des différents constituants des assemblages
   combustibles.
   On introduit 2 conceptions d'assemblages.
   + La gestion des caractéristiques matériaux fera l'objet d'une revisite pour éviter de
   dupliquer
   des informations lorsque deux conceptions d'assemblages utilisent le même matériau pour un
   constituant.
   
   PY:
   + calc_mac3coeur_ops : corps principal de la macro
   + mac3coeur_factory : permet de gerer l'initialisation des differents types de coeurs et
   d'assemblages combustibles à partir des repertoires datg et materiau.
   + mac3coeur_coeur : definition de la conception coeur et des fonctions associees
   + mac3coeur_assemblage : definition de la conception d'un AC et des fonctions associees
   + macro_ac_permute : gestion de la permutation d'un AC dans le reacteur (macro-commande
   cachee).
   
   Validation
   ----------
   Différents tests perso on été réalisés sur les coeurs de type 900MW, 1300MW, N4.
   On ajoute dans la base de Code_Aster le cas-test de validation sur coeur de type TEST
   (5 assemblages : un positionné au centre de la cuve et les 4 autres disposés sur chacun des
   points cardinaux de l'assemblage central).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.02.103, U4.90.11
VALIDATION
    mac3c02a + perso
NB_JOURS_TRAV  : 15.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 015211 DU 2010-06-15 13:09:05
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Macro_commande de permutation d'assemblages combustibles
FONCTIONNALITE
   La gestion de la permutation des assemblages combustibles se fait finalement en
   macro-commande cachee appelee depuis la commande CALC_MAC3COEUR.
   
   voir fiche 16961.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.02.103
VALIDATION
    mac3c02a + perso
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 017239 DU 2011-07-01 13:56:04
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Definir une macro-commande de post-traitement specifique aux assemblages combustibles
FONCTIONNALITE
   Ajout de la commande de post-traitement specifique aux calculs des deformations des
   assemblages combustibles (sortie au  format Xmgrace).
   
   Etape 1 (objet de cette fiche):
   - Post-traitement des lames d'eau (voir exemple).
   
   Etapes suivantes :
   - Autres post à venir sur les déformations (amplitudes, directions...)
   
   POST_MAC3COEUR(TYPE_COEUR   = ("TEST","900","1300","N4","EPR"),
                  RESULTAT     = SIMP(typ=evol_noli),                             
                  INST         = SIMP(typ='R', max=1),                            
                  LAME         = FACT(max='**',
                                      regles=UN_PARMI('NUME_GRILLE','TYPE_RESU',),
                               
                                NUME_GRILLE  = SIMP(typ='I', max=1),
                                UNITE        = SIMP(typ='I', max=1),   
   			     TYPE_RESU    = SIMP(into=("MINI","MAXI") ),)
                          
   Ajout de :
   post_mac3coeur_ops.capy et post_mac3coeur_ops.py
   
   Validation sur mac3c02a et différents coeur -900MW, 1300MW, N4 (voir exemple dans
   CR-AMA-11.101).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V1.02.103, U4.90.12
VALIDATION
    mac3c02a + perso
NB_JOURS_TRAV  : 4.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR greffet      GREFFET Nicolas        DATE 07/04/2011 - 04:11:55

--------------------------------------------------------------------------------
RESTITUTION FICHE 017206 DU 2011-06-27 11:34:04
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Tester le réassemblage de la matrice en DYNA_NON_LINE
FONCTIONNALITE
   Objectif :
   valider le bon comportement du découpage de pas de temps dans DYNA_NON_LINE.
   Cette fiche fait suite à la fiche 11648 où l'on force bien le recalcul de la 
   matrice de résolution quand on sous-divise le pas de temps (cette matrice de 
   résolution dépend en effet du pas de temps courant).
   
   Cas-test :
   On part d'un cas-test avec non-linéarités matériaux et contact : le cas-test 
   sdnv103a.
   Pour forcer le sous-découpage, on va imposer un nombre d'itérations de Newton 
   maximal volontairement très bas : ITER_GLOB_MAXI=5 .
   On modifie aussi REAC_INCR et REAC_ITER en les mettant à 0 (au lieu de 1 
   auparavant) pour bien valider la reconstruction de la matrice de résolution en 
   cas de sous-découpage du pas de temps.
   
   Le sous-découpage du pas de temps sera géré par le DEFI_LIST_INST suivant :
   DEFLIST =DEFI_LIST_INST(DEFI_LIST=_F(LIST_INST = L_INST),
                           ECHEC=_F(SUBD_METHODE='UNIFORME',
                                    SUBD_PAS=2,
                                    SUBD_PAS_MINI=1.E-30,),);
   
   
   En analysant ce cas-test, on s'aperçoit aussi que la solution numérique 
   calculée est assez perturbée par le choc : l'évolution de la vitesse, en 
   particulier, n'est pas très satisfaisante. On peut nettement améliorer cela en 
   jouant sur le schéma en temps : en remplaçant le schéma d'origine (famillede 
   Newmark) par une accélération moyenne modifiée avec un très fort 
   amortissement. Ici on ne préconise pas le schéma HHT complet car le système 
   mécanique n'a pas d'amortissement en régime élastique (pas de Rayleigh ou 
   d'amortissement modal).
   On obtient alors une solution bien plus lissée et physique, comme on peut le 
   voir sur le graphe ci-joint. Au niveau temps CPU on augmente un peu à cause du 
   sous-découpage : on passe de 45 s à 70 s. J'en profite donc pour ajuster 
   le .para qui devait correspondre au temps total d'étude alors que pour le cas-
   test on s'arrête bien plus tôt.
   
   Je propose donc de modifier la modélisation a avec le sous-découpage et le 
   schéma HHT.
   
   Impacts :
   sdnv103a.comm
   sdnv103a.para : on ajuste à 300 s (au lieu de 5000 s qui doit correspondre au 
   temps total d'étude jusqu'au redécollement)
   V5.03.103
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : V5.03.103
VALIDATION
    sdnv103a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR voldoire     VOLDOIRE Franois      DATE 05/07/2011 - 15:05:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 016566 DU 2011-03-08 08:38:08
TYPE anomalie concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    Labord_1D : correction dichotomie ; remonter parametres algo integration dans COMP_INCR
FONCTIONNALITE
   Fiche 16566 : Labord_1D : remonter parametres algo integration dans COMP_INCR.
   _____________________________________________________________________________
   
   La mthode de dichotomie utilise pour la rsolution des systmes d'quations 
   3.2.1-2 et 3.2.3-2 du comportement LABORD_1D (doc R7.01.07) a t mise au 
   propre et cette dichotomie est maintenant pilotable par l'utilisateur.
   
   De plus, on a apport :
   - une correction  la doc R7.01.07, cf. PJ,
   - une clarification et la mise en conformit du code avec la doc R,
   - l'annotation du code avec des rfrences aux quations de la doc R.
   
   Le travail est disponible dans l'archive:
   /home/labbe/16566_Labord_1D.REX_2011-06-21.tgz sur aster4.
   
   Mise au propre et pilotage de la dichotomie
   ===========================================
   
   La rsolution des systmes d'quations 3.2.1-2 et 3.2.3-2 est maintenant 
   faite par une vraie dichotomie faite sur le bon intervalle et sans calculs 
   redondants. 
   Nous en avons profit pour supprimer quelques variables inutiles et cela nous 
   a permis de voir plus clairement quels taient les paramtres  donner  
   l'utilisateur. 
   
   Deux paramtres utilisateurs peuvent maintenant tre renseigns dans 
   COMP_INCR pour agir sur cette dichotomie : 
   - ITER_INTE_MAXI qui est le nombre maximum d'itrations, c'est  dire le 
   nombre de fois que l'on permet de diviser l'intervalle de recherche en deux 
   avant de stopper l'algorithme ;
   - RESI_INTE_RELA qui est la prcision avec laquelle on veut rsoudre cette 
   recherche de zro.
   
   La mthode de rsolution du systme d'quation et les paramtres de pilotage 
   ont t ajouts  la doc R7.01.07 au 3.2.1.
   
   Travail supplmentaire
   ======================
   
   * Correction de la doc R7.01.07 
   
   On a corrige l'quation 3.2.1-2 (il manquant "Y1-" dans la premire ligne).
   
   * Mise en conformit du code avec la doc R7.01.07  3.2.1 et 3.2.3
   
   Dans la doc R7.01.07 aux paragraphes 3.2.1 et 3.2.3, la vrification du 
   dpassement de seuil est faite par rapport  Z1 ou Z2 (seuils au pas de temps 
   prcdent), or jusqu' prsent ceci est fait par rapport aux seuils initiaux 
   Y01 ou Y02. Nous avons mis le code en conformit avec la doc.
   On donne donc maintenant les arguments Z1 ou Z2  la routine nmcb13. 
   Ce changement est la cause de la plupart des modifications apportes aux 
   tests.
   
   * Mise en conformit du code avec la doc R7.01.07 : Mise  jour de 
   l'endommagement au cours du pas de temps
   
   Dans la routine nmcb1d, on appelle nmcb13 dans une boucle. Cette boucle 
   s'arrte quand on passe deux fois de suite par le mme cas parmi les 3 
   possibles (1: traction, 2: faible compression, 3: compression au del de la 
   fermeture des fissures). Durant ces itrations on fait voluer les 
   endommagements D1 et D2  partir de leurs valeurs en dbut de pas de
   temps (notons les DD1 et DD2). Or si on passe une deuxime fois par le cas 1 
   par exemple, la dichotomie va se faire dans l'intervalle [D1,1[ et non [DD1,1
   [ comme il se devrait.
   Nous avons donc corrig cela en ajoutant les arguments DD1 ou DD2  nmcb13.
   
   * Clarification et annotation du code
   
   Nous avons ajout des commentaires dans le code pour clarifier l'implantation 
   et faire rfrence aux quations.
   
   Cas-tests
   =========
   
   Dans les cas-tests ssns106i, ssns106j et ssns106h du modle GLRC_DM rfr  
   LABORD_1D, on a modifi lgrement les valeurs de rfrence des TEST_RESU 
   (NON_RREGRESSION).  La doc [V6.05.106] SSNS106 modifie est en PJ.
   Dans ssnl119a on a chang la valeur du mot cl SUB_ITER_PLUS de 100  110 
   dans LIST2 et LIST3 et on a mis REAC_ITER=1 dans U3=STAT_NON_LINE() pour que 
   le calcul converge. 
   Mais les valeurs testes par Code_Aster n'ont pas chang : la doc V6.02.119 
   ne change pas.
   
   Rsultats faux
   =============
   
   Depuis la premire implantation de 2003 la loi LaBorderie comportait donc 
   cette erreur dans la dichotomie qui a pu produire des rsultats lgrement 
   faux.
   
   Validation
   ==========
   
   Les corrections et ajouts apports aux sources,  la documentation et aux cas-
   test ont t valids par Luc Davenne.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 7.7.8
RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI   DEPUIS : 7.7.8
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R7.01.07
VALIDATION
    cas-test
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 07/05/2011 - 12:27:13

--------------------------------------------------------------------------------
RESTITUTION FICHE 017237 DU 2011-07-01 13:45:18
TYPE express concernant Code_Aster (VERSION 9.1)
TITRE
    Bug LIRE_MAILLAGE format MED
FONCTIONNALITE
   Problème :
   ----------
   Dans le cadre de la fiche issue17231, j'ai fabriqué un maillage de poutre au format MED
   avec Salomé et je me suis rendu compte qu'il n'était pas possible de le relire dans Aster
   (plantage en segmentation fault).
   
   
   Analyse :
   ---------
   J'ai fait une petite confusion dans un des arguments de sortie des routines MED3.0.
   
   La routine MED en question est MMHMII. En sortie cette routine a notamment 2 arguments :
   - la dimension du maillage,
   - la dimension de l'espace dans lequel se trouve le maillage.
   
   Par convention, la dimension du maillage pour un maillage de poutre, c'est 1. Mais la
   dimension de l'espace peut être supérieur à 1 (ici 2).
   
   C'est ce que se produit ici. Mon maillage est en fait un treilli maillé. La conséquence de
   cette confusion, c'est qu'on n'alloue pas les tableaux de coordonnées à la bonne taille
   d'où le plantage en segmentation fault.
   
   
   Solution :
   ----------
   Corriger MFMAAI qui appelle MMHMII pour utiliser la dimension de l'espace dans lequel se
   trouve le maillage pour allouer les divers vecteurs de travail.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST AJOUT mac3c02a                    fernandes R.FERNANDES         78     78      0
 CASTEST AJOUT ssll117g                    fernandes R.FERNANDES        156    156      0
 CASTEST AJOUT sslv117a                    fernandes R.FERNANDES        129    129      0
 CASTEST MODIF erreu07a                        abbas M.ABBAS            189      2      2
 CASTEST MODIF hsna100a                        abbas M.ABBAS            469     15     12
 CASTEST MODIF hsna100b                        abbas M.ABBAS            534     17     17
 CASTEST MODIF hsna100d                        abbas M.ABBAS            563     17     17
 CASTEST MODIF hsna100e                        abbas M.ABBAS            564     17     17
 CASTEST MODIF sdnv103a                      greffet N.GREFFET          234     24      7
 CASTEST MODIF ssll117a                    fernandes R.FERNANDES        240      4     15
 CASTEST MODIF ssll117b                    fernandes R.FERNANDES        159      4     10
 CASTEST MODIF ssll117c                    fernandes R.FERNANDES        170      4     10
 CASTEST MODIF ssll117d                    fernandes R.FERNANDES        159      4     10
 CASTEST MODIF ssll117e                    fernandes R.FERNANDES        169      4     10
 CASTEST MODIF ssll117f                    fernandes R.FERNANDES        220     26      8
 CASTEST MODIF ssnl119a                        labbe M.LABBE            482      4      4
 CASTEST MODIF ssnl126b                        abbas M.ABBAS            177      2      2
 CASTEST MODIF ssnp307a                     beaurain J.BEAURAIN         143      3      2
 CASTEST MODIF ssns106h                        labbe M.LABBE            910      2      2
 CASTEST MODIF ssns106i                        labbe M.LABBE            981      6      6
 CASTEST MODIF ssns106j                        labbe M.LABBE           1415      6      6
 CASTEST MODIF ssnv182a                        abbas M.ABBAS            268      1      1
 CASTEST MODIF ssnv182g                        abbas M.ABBAS            268      1      1
 CASTEST MODIF ssnv209b                        abbas M.ABBAS            620      1      1
 CASTEST MODIF ssnv209d                        abbas M.ABBAS            515      1      1
 CASTEST MODIF ssnv209e                        abbas M.ABBAS            517      1      1
 CASTEST MODIF ssnv209k                        abbas M.ABBAS            498      1      1
 CASTEST MODIF wtnl100c                    fernandes R.FERNANDES        627      5      5
 CASTEST MODIF wtnl100d                    fernandes R.FERNANDES        340      5      5
 CASTEST MODIF zzzz258a                        abbas M.ABBAS            167      2      2
 CASTEST MODIF zzzz283a                      colombo D.COLOMBO          316    188    406
 CASTEST SUPPR feti008a.comm                  desoza T.DESOZA           158      0    158
 CASTEST SUPPR feti009a.comm                  desoza T.DESOZA           219      0    219
 CASTEST SUPPR feti010a.comm                  desoza T.DESOZA           291      0    291
CATALOGU AJOUT typelem/gener_3dilp1        fernandes R.FERNANDES        166    166      0
CATALOGU MODIF compelem/phenomene_modelisation__  fernandes R.FERNANDES       1838      6      1
CATALOGU MODIF typelem/gener_2d2g          fernandes R.FERNANDES        173      4      3
CATALOGU MODIF typelem/gener_2dilp0        fernandes R.FERNANDES        162      4      3
CATALOGU MODIF typelem/gener_2dilsl        fernandes R.FERNANDES        150      4      3
CATALOGU MODIF typelem/gener_ejah22        fernandes R.FERNANDES        211      9      9
CATALOGU MODIF typelem/gener_ejdh22        fernandes R.FERNANDES        210      9      9
CATALOGU MODIF typelem/gener_medgn_2        beaurain J.BEAURAIN         277      2      2
CATALOGU MODIF typelem/gener_mv3dn_3        beaurain J.BEAURAIN         322      2      2
CATALOPY AJOUT commande/calc_mac3coeur     fernandes R.FERNANDES         44     44      0
CATALOPY AJOUT commande/post_mac3coeur     fernandes R.FERNANDES         38     38      0
CATALOPY MODIF commande/affe_char_meca_f   fernandes R.FERNANDES        458      4      3
CATALOPY MODIF commande/affe_modele        fernandes R.FERNANDES        273      2      1
CATALOPY MODIF commande/defi_fiss_xfem       colombo D.COLOMBO          178      9     22
    CMAT AJOUT AF3G_CR_REF_A.NOMI          fernandes R.FERNANDES         96     96      0
    CMAT AJOUT AF3G_DIL_REF_A.NOMI         fernandes R.FERNANDES         54     54      0
    CMAT AJOUT AF3G_EI_REF_A.NOMI          fernandes R.FERNANDES         81     81      0
    CMAT AJOUT AF3G_ES_REF_A.NOMI          fernandes R.FERNANDES         82     82      0
    CMAT AJOUT AF3G_GC_EB_REF_A.NOMI       fernandes R.FERNANDES        121    121      0
    CMAT AJOUT AF3G_GC_EH_REF_A.NOMI       fernandes R.FERNANDES        121    121      0
    CMAT AJOUT AF3G_GC_ME_REF_A.NOMI       fernandes R.FERNANDES        123    123      0
    CMAT AJOUT AF3G_TG_REF_A.NOMI          fernandes R.FERNANDES         96     96      0
    CMAT AJOUT AFA_CR_REF_A.NOMI           fernandes R.FERNANDES         96     96      0
    CMAT AJOUT AFA_DIL_REF_A.NOMI          fernandes R.FERNANDES         54     54      0
    CMAT AJOUT AFA_EI_REF_A.NOMI           fernandes R.FERNANDES         81     81      0
    CMAT AJOUT AFA_ES_REF_A.NOMI           fernandes R.FERNANDES         82     82      0
    CMAT AJOUT AFA_GC_EB_REF_A.NOMI        fernandes R.FERNANDES        121    121      0
    CMAT AJOUT AFA_GC_EH_REF_A.NOMI        fernandes R.FERNANDES        121    121      0
    CMAT AJOUT AFA_GC_ME_REF_A.NOMI        fernandes R.FERNANDES        123    123      0
    CMAT AJOUT AFA_TG_REF_A.NOMI           fernandes R.FERNANDES         96     96      0
    DATG AJOUT AF3G.datg                   fernandes R.FERNANDES        100    100      0
    DATG AJOUT AFA.datg                    fernandes R.FERNANDES        100    100      0
    DATG AJOUT Coeur_1300.datg             fernandes R.FERNANDES         69     69      0
    DATG AJOUT Coeur_900.datg              fernandes R.FERNANDES         71     71      0
    DATG AJOUT Coeur_EPR.datg              fernandes R.FERNANDES         70     70      0
    DATG AJOUT Coeur_N4.datg               fernandes R.FERNANDES         80     80      0
    DATG AJOUT Coeur_TEST.datg             fernandes R.FERNANDES         68     68      0
 FORTRAN AJOUT algorith/cabrp1             fernandes R.FERNANDES        151    151      0
 FORTRAN AJOUT algorith/dimp1              fernandes R.FERNANDES         70     70      0
 FORTRAN MODIF algeline/recude                desoza T.DESOZA           101      4      3
 FORTRAN MODIF algorith/assthm             fernandes R.FERNANDES        466     29      2
 FORTRAN MODIF algorith/dilcge             fernandes R.FERNANDES         62      4      3
 FORTRAN MODIF algorith/dilder             fernandes R.FERNANDES         59      4      3
 FORTRAN MODIF algorith/dilele             fernandes R.FERNANDES        125      6      1
 FORTRAN MODIF algorith/dilini             fernandes R.FERNANDES        138     23      4
 FORTRAN MODIF algorith/epsdil             fernandes R.FERNANDES         69      6      1
 FORTRAN MODIF algorith/fnodil             fernandes R.FERNANDES         97      7      2
 FORTRAN MODIF algorith/nmarpr                 abbas M.ABBAS            117      6      4
 FORTRAN MODIF algorith/nmcrar                 abbas M.ABBAS            127      3      3
 FORTRAN MODIF algorith/nmdoet                 abbas M.ABBAS            318      2      2
 FORTRAN MODIF algorith/nmetcr                 abbas M.ABBAS            275      2      2
 FORTRAN MODIF algorith/nmeteo                 abbas M.ABBAS            116      5      2
 FORTRAN MODIF algorith/nmetl3                 abbas M.ABBAS            167      6      3
 FORTRAN MODIF algorith/nmttch                 abbas M.ABBAS            112     12     15
 FORTRAN MODIF algorith/ntcrar                 abbas M.ABBAS            121      3      3
 FORTRAN MODIF algorith/op0010               colombo D.COLOMBO          839      9      1
 FORTRAN MODIF algorith/op0041               colombo D.COLOMBO          523     22     65
 FORTRAN MODIF algorith/regini             fernandes R.FERNANDES        136      2      7
 FORTRAN MODIF algorith/vecind                 corus M.CORUS            210     15     14
 FORTRAN MODIF algorith/xinils               colombo D.COLOMBO          272      9      3
 FORTRAN MODIF algorith/xmmres                 abbas M.ABBAS            472     11      3
 FORTRAN MODIF algorith/xprvit               colombo D.COLOMBO          836     22      9
 FORTRAN MODIF calculel/crpcvg             fernandes R.FERNANDES        165     25     21
 FORTRAN MODIF calculel/exchml                desoza T.DESOZA           315     18      1
 FORTRAN MODIF elements/dichoc             fernandes R.FERNANDES        290      4      2
 FORTRAN MODIF elements/mmmpha                desoza T.DESOZA           119      5      3
 FORTRAN MODIF elements/nmcb13                 labbe M.LABBE            118     68     58
 FORTRAN MODIF elements/nmcb1d                 labbe M.LABBE            139     24     11
 FORTRAN MODIF elements/pmfcom                 labbe M.LABBE            331      2      2
 FORTRAN MODIF elements/te0039             fernandes R.FERNANDES        631      3      3
 FORTRAN MODIF elements/te0047             fernandes R.FERNANDES        955      5      5
 FORTRAN MODIF elements/te0364                desoza T.DESOZA           263      2      2
 FORTRAN MODIF elements/te0365                desoza T.DESOZA           213      2      2
 FORTRAN MODIF modelisa/aceapo                desoza T.DESOZA           389      2      2
 FORTRAN MODIF utilitai/recugd                desoza T.DESOZA           128      7      5
 FORTRAN SUPPR algorith/ndarch                 abbas M.ABBAS             74      0     74
 FORTRAN SUPPR algorith/ndmapa                 abbas M.ABBAS             72      0     72
 FORTRAN SUPPR elements/mmmvec                 abbas M.ABBAS            100      0    100
FORTRAN90 MODIF echange/mfmaai               sellenet N.SELLENET          52      3      3
  PYTHON AJOUT Mac3coeur/__init__          fernandes R.FERNANDES         22     22      0
  PYTHON AJOUT Mac3coeur/calc_mac3coeur_ops  fernandes R.FERNANDES        243    243      0
  PYTHON AJOUT Mac3coeur/mac3coeur_ac_permute  fernandes R.FERNANDES        241    241      0
  PYTHON AJOUT Mac3coeur/mac3coeur_assemblage  fernandes R.FERNANDES        385    385      0
  PYTHON AJOUT Mac3coeur/mac3coeur_coeur   fernandes R.FERNANDES        671    671      0
  PYTHON AJOUT Mac3coeur/mac3coeur_factory  fernandes R.FERNANDES         71     71      0
  PYTHON AJOUT Mac3coeur/post_mac3coeur_ops  fernandes R.FERNANDES        185    185      0
  PYTHON MODIF Comportement/dis_choc       fernandes R.FERNANDES         37      4      4
  PYTHON MODIF Macro/impr_diag_campbell_ops   courtois M.COURTOIS        1202      3     13
  PYTHON MODIF Macro/impr_diag_campbell_utils   courtois M.COURTOIS         829    115    109
  PYTHON MODIF Messages/xfem                 colombo D.COLOMBO          455     34      1
  PYTHON MODIF Messages/xfem2                colombo D.COLOMBO          577      1     11
  PYTHON MODIF SD/co_maillage               courtois M.COURTOIS          52      9      7
  PYTHON MODIF SD/co_table                  courtois M.COURTOIS         128     26      6
  PYTHON MODIF SD/sd_xfem                    colombo D.COLOMBO          149      2      1


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   38        4756      4756             +4756
 MODIF :   84       29461       998    1066       -68
 SUPPR :    6         914               914      -914
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  128       35131      5754    1980     +3774 
