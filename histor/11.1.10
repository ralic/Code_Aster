

-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR abbas        ABBAS Mickael          DATE 02/21/2012 - 10:33:25

--------------------------------------------------------------------------------
RESTITUTION FICHE 018412 DU 2012-02-14 17:15:02
TYPE express concernant Code_Aster (VERSION 10.5)
TITRE
    Discr√©tisation en temps
FONCTIONNALITE
   Probl√®me
   ========
   
   
   Le message DISCRETISATION_92 est particuli√®rement elliptique:
   
   92 : _(u"""
    NUME_INST_INIT est plus grand que NUME_INST_FIN
   """),
   
   Solution
   ========
   
   En fait, il fallait comprendre:
   
   92 : _(u"""
   On ne peut faire le calcul car l'instant final donn√© est √©gal au dernier instant stock√©
   dans la structure de donn√©es RESULTAT. Il n'y a qu'un incr√©ment disponible alors qu'il
   faut au moins deux pas de temps dans les op√©rateurs non-lin√©aires.
   """),
   
   Je transforme aussi l'alarme DISCRETISATION_94 en erreur fatale car elle me parait dangereuse:
   
   94 : _(u"""
   L'instant final est introuvable dans la liste d'instants (LIST_INST).
   Risque & Conseil :
      V√©rifiez le mot-cl√© INST_FIN (ou NUME_INST_FIN), en tenant compte de la pr√©cision
   (mot-cl√© PRECISION).
   """),
   
   Et je modifie le message  DISCRETISATION_89 pour aider l'utilisateur:
   89 : _(u"""
   L'instant initial est introuvable dans la liste d'instants (LIST_INST).
   Risque & Conseil :
      V√©rifiez le mot-cl√© INST_INIT (ou NUME_INST_INIT), en tenant compte de la pr√©cision
   (mot-cl√© PRECISION).
   """),
   
   On peut faire en 10.
   Impacts discretisation.py et nmdifi.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018360 DU 2012-02-07 14:07:59
TYPE express concernant Code_Aster (VERSION 10.5)
TITRE
    Fusion des routines vtgpld et vtgplk
FONCTIONNALITE
   Probl√©matique
   =============
   
   Les routines VTGPLK et VTGPLD permettent la r√©actualisation d'un champ g√©om√©trique (sur la
   grandeur GEOM_R) √† partir d'un champ de type DEPL_R
   
   CHAMNO(GEOM_R) + ALPHA*CHAMNO(DEPL_R) --> CHAMNO(GEOM_R) ACTUALISE
   ou encore
   X + ALPHA . DX -> NX
   
   Ces routines sont tr√®s utiles dans le contact ou d√®s lors qu'on veut faire une
   r√©actualisation de la g√©om√©trie car elle ne travaillent que sur les DDL DX, DY et DZ.
   
   Or vtgplk est une simple copie de vtgpld √† une nuance pr√®s:
   
   vtgpld: 
   X +ALPHA*DX --> NX
   Y +ALPHA*DX --> NY
   Z +ALPHA*DX --> NZ
   
   vtgplk:
   ALPHA*DX --> NX
   ALPHA*DY --> NY
   ALPHA*DZ --> NZ
   
   Solution
   ========
   
   On fusionne les deux dans VTGPLD en rajoutant l'argument "CUMUL":
   CALL VTGPLD(CUMUL ,GEOMIZ,ALPHA ,DEPLAZ,BASE  ,GEOMFZ)
   On fait:
    GEOMF = GEOMI + ALPHA * DEPLA SI CUMUL = 'CUMU'
    GEOMF = ALPHA * DEPLA         SI CUMUL = 'ZERO'
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : D6.00.01
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018171 DU 2012-01-06 13:06:28
TYPE evolution concernant Code_Aster (VERSION 10.5)
TITRE
    CTC1 - Detection automatique des cycles
FONCTIONNALITE
   Probl√©matique
   =============
   
   Lorsqu'on est en ALGO_RESO_CONT = 'NEWTON', il arrive parfois que le message "flip-flop"
   apparaisse alors qu'il ne devrait pas (aucun sens dans ce cas).
   Cela provient du fait que le mode "newton g√©n√©ralis√© pour les statuts du contact" utilise
   la m√™me routine (mmmbca.f) que le mode "point fixe sur les statuts de contact".
   Il faut corriger.
   Par extension, on en profite pour introduire une strat√©gie de d√©tection de cycles dans le
   contact continu.
   
   Solution
   ========
   
   En plus de corriger ce probl√®me, on propose de mettre √† disposition la d√©tection
   automatique de trois types de cycles:
   1/ contact/pas contact sur le m√™me n≈ìud d'une it√©ration √† l'autre (on attend trois
   it√©rations: 0 1 0 ou 1 0 1)
   2/ Adh√©rence/glissement sur le m√™me noeud d'une it√©ration √† l'autre (on attend trois
   it√©rations: 0 1 0 ou 1 0 1)
   3/ Glissement avant/Glissement arri√®re sur le m√™me noeud d'une it√©ration √† l'autre
   
   Mise en ≈ìuvre
   ==============
   
   Rajout de 7 routines pour g√©rer les cycles:
   mmcycd: d√©tection des cycles
     mmcyc1: cas contact/contact
     mmcyc2: cas adh√©rent/glissant
     mmcyc3: cas glissement avant/glissement arri√®re
   mmcycl: lecture des cycles d√©tect√©s
   mmcycz: remise √† z√©ro de la d√©tection des cycles
   iscycl: routine g√©n√©rique de d√©tection de cycle de type statut. On utilise pour cela la
   notion d'entier cod√©
    Exemple: d√©tecter un cycle sur une longueur 3, en utilisant les entier cod√©, √ßa veut dire
   que l'entier vaut 010 ou 101 (en base 2), soit 4 ou 10 en base 10
   
   Cette m√©thode marche pour les cycles de type 1 ou 2
   Pour les cycles de type 3, il est n√©cessaire de stocker en plus le lagrangien augment√© de
   frottement. Entre deux it√©rations de Newton, si on est toujours glissant, on calcule
   l'angle entre les deux multiplicateurs. Si cet angle vaut Pi, c'est qu'on glisse en avant,
   puis en arri√®re.
   Il a donc √©t√© n√©cessaire de reprogrammer la d√©tection du statut de frottement
   (glissant/adh√©rent) au niveau de l'algo global (actuellement, c'est fait dans les TE)
   
   Impacts globaux:
   cfmxme pour les SD de cyclage
   nmtble/nmible/mmmbca/mmbclc/nmctcc/nmctcf/nmctcg et routines aff√©rentes pour l'application
   dans l'algo global de r√©solution
   impstd/imcod/impref: on ajoute une colonne au tableau de convergence pour informer
   l'utilisateur d'un cyclage
   
   Au passage on modifie le catalogue :
   - quand ALGO_RESO_CONT='NEWTON', ITER_CONT_* ne doit pas √™tre utilis√© (plus de sens)
   - quand ALGO_RESO_FROT='NEWTON', REAC_FROT n'a plus de sens non plus, de m√™me que
   ITER_FROT_MAXI/NB_ITER_FROT. Par contre RESI_FROT a encore un sens.
   
   
   Usage
   =====
   
   Pour l'instant, c'est purement d√©claratif/informatif. A terme, dans le cadre des travaux
   de th√®se du contact et du stage commen√ßant en mars, on utilisera ces informations pour
   aider l'algorithme √† converger plus facilement: adaptation des coefficients
   d'augmentation, d√©coupe du pas de temps.
   Le choix des cycles √† d√©tecter repose sur les travaux du Newton g√©n√©ralis√© de Alart (ces
   trois cycles sont ceux qui posent le plus probl√®me en pratique).
   
   Application
   ===========
   
   Sur le cas-test ssnv503h, on d√©couvre un cyclage de type glissement avant/arriere qu'on
   peut corriger en d√©coupant plus le transitoire.
   La d√©tection du "flip-flop" historique de la m√©thode continue marche de la m√™me mani√®re:
   d√©tection d 'un cycle contact/pas contact sur 3 it√©rations de contact de point fixe,
   for√ßage de la convergence. Avant, il fallait atteindre 15 (!) cyclages pour forcer la
   convergence
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.52
VALIDATION
    liste restreinte
NB_JOURS_TRAV  : 2.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016629 DU 2011-03-21 10:39:55
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    Homogeneisation du vocabulaire : EXTRAPOL(E)
FONCTIONNALITE
   =============
   
   Dans STAT_NON_LINE / NEWTON on trouve PREDICTION='EXTRAPOL'
   
   L'absence de "E" final est emb√™tant. Une fois sur deux on l'oublie.
   
   Solution
   ========
   
   On propose PREDICTION='EXTRAPOLE'
   
   L'impact est le suivant :
   - fortran : nmprde.f nmpred.f nmprma.f
   - capy : c_newton.capy
   - tests : 17
   hsnv121a,hsnv125d,perfe01a,perfe03a,ssnd110a,ssnd110b,ssnp101a,ssnv126a            
   ssnv171c,ssnv172a,ssnv172b,ssnv183a,ssnv194a,ssnv194b,ssnv194c
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : R5.03.14, U4.51.03, U4.53.01, R5.03.11
VALIDATION
    Cas-tests avec EXTRAPOL
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 016251 DU 2011-01-21 09:43:10
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    AR09 - Adh√©rence de les SD resultat √† un maillage unique
FONCTIONNALITE
   Probl√©matique
   =============
   
   Faire sauter la d√©pendance au maillage des SD RESULTATS et des op√©rateurs d'Aster au sens
   large.
   
   Motivation
   ==========
   
   Int√©grer l'adaptation de maillage dans un transitoire de calcul de mani√®re efficace et
   ergonomique
   
   Analyse
   =======
   
   Quatre √©tages sont n√©cessaires:
   1/ Impression des r√©sultats sur un maillage √©volutifs
   2/ Visualisation des r√©sultats sur un maillage √©volutif
   3/ Adaptation des op√©rateurs de calcul (essentiellement *_NON_LINE) pour qu'ils
   fonctionnent sur un maillage √©volutif
   4/ Adaptation des autres op√©rateurs pour la prise en compte d'un maillage √©volutif (en
   particulier le post-traitement)
   
   √âtage 1 - Impression des r√©sultats sur un maillage √©volutif
   -----------------------------------------------------------
   
   MED dispose de la possibilit√© de d√©finir un maillage √©volutif o√π sont normalis√©s les
   r√®gles d'√©volution (nouveaux n≈ìuds, nouvelle connectivit√©, d√©placement des n≈ìuds). Il n'y
   a donc pas d'obstacle de ce poitn de vue
   
   √âtage 1 - OK
   
   √âtage 2 - Visualisation des r√©sultats sur un maillage √©volutif
   --------------------------------------------------------------
   
   SALOME/VISU ne sait pas traiter ce cas, mais PARAVIS, oui.
   
   √âtage 2 - OK
   
   
   √âtage 3 - Adaptation des op√©rateurs de calcul
   ---------------------------------------------
   
   Le maillage comme d√©pendance directe:
   - peu de fonctionnalit√©s sont impact√©es. Ce n'est donc pas un probl√®me difficile.
   
   Le maillage comme d√©pendance indirecte: MODELE et LIGREL
   Sont concern√©es:
   - les op√©rations d'affectation de MODELE (AFFE_MODELE)
   - les op√©rations d'affectation de MATERIAU (AFFE_MATERIAU)
   - les op√©rations d'affectation des conditions limites (AFFE_CHAR_* et DEFI_CONTACT)
   - les op√©rations d'affectation du comportement (COMP_INCR)
   - les champs de calculs (d√©placement, contraintes, etc.)
   
   Principale difficult√©: les op√©rations de pr√©paration de calcul (par exemple AFFE_CHAR_*)
   repose sur l'id√©e que le maillage ne bouge pas.
   Solution: AFFE_CHAR_* doit cr√©er une nouvelle SD qui embarque les informations de
   topologie et les op√©rations de calcul doivent √™tre fait "au dernier moment" (sur le
   maillage "courant"). S√©paration DEFI/AFFE pour tous.
   -> Solution lourde et tr√®s impactante pour le code, sauf pour DEFI_CONTACT (op√©rateur
   "localis√©" dans OP0070)
   
   Pour les autres champs de calcul, on se repose sur PROJ_CHAMP.
   
   Impact architectural sur l'op√©rateur de calcul: augmente la complexit√© mais pas de
   difficult√© particuli√®re (volume de source)
   
   √âtage 4 - Adaptation des autres op√©rateurs
   ------------------------------------------
   
   Il se pose la question de certaines options qui n√©cessitent la connaissance du r√©sultat
   √† 2 instants diff√©rents : comment fait-on l'interpolation en temps?
   
   Homard devrait supporter tous les types d'√©l√©ments
   
   Les commandes IMPR_RESU/MAILLAGE, LIRE_MAILLAGE, etc... devront disposer d'un mot-cl√© INST
   
   Que faire pour op√©rations de modification de topologie (CREA_MAILLAGE/MODI_MAILLAGE) ?
   Exemple: les n≈ìuds au quart. Il faut propager la modification quand le maillage change.
   Homard ne change pas l'orientation des √©l√©ments (donc pas de probl√®mes pour les ORIE_*),
   mais il reste les autres (et surtout le blindage des fonctionnalit√©s "dangereuses").
   La principale difficult√© n'est pas de recenser les cas pr√©sents mais de se pr√©munir des
   fonctionnalit√©s futures...
   
   Conclusions
   ===========
   
   Question ouverte: faire un chantier d'une grande ampleur, modifier √©ventuellement les
   habitudes des utilisateurs pour se rendre compte au final que personne ne se sert de la
   fonctionnalit√© "pr√©texte" √† cette √©volution.
   Pour parler novlangue: le plus grave semble √™tre  le "risque √† faire" plut√¥t que le
   "risque √† ne pas faire"
   
   Facile √† faire √† court terme:
   - enrichir IMPR_RESU pour concat√©ner plusieurs SD r√©sultats: facilit√© pour l'utilisateur
   - proposer une macro-commande d'adaptation sur le mod√®le de MACR_RECAL
   
   Le CR AMA 11-225 a √©t√© √©crit et diffus√©. On l'ajoute √† la fiche pour m√©moire
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    rien de particulier
NB_JOURS_TRAV  : 5.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014653 DU 2010-02-17 17:11:39
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    MN06 - Verification de modeles pour ETAT_INIT dans *_NON_LINE
FONCTIONNALITE
   Probl√©matique
   =============
   
   Quand on fait une poursuite avec un *_NON_LINE exploitant un ETAT_INIT issu d'un
   pr√©c√©dent *_NON_LINE, mais en ayant subrepticement chang√© le mod√®le (ex : construction par
   couches, ajout de pi√®ces...), 
   le nouvel *_NON_LINE r√¢le dans CALCUL car il constate que des champs ne sont pas prolong√©s
   sur les nouveaux ddl.
   
   Le message d'erreur de CALCUL est assez dur √† interpr√©ter. Donc :
   
   1. tenter de d√©tecter ce pb dans *_NON_LINE au niveau ETAT_INIT et alerter l'utilisateur ;
   2. si possible, proposer une solution de type : prolongement par 0 sur la partie nouvelle.
   
   Avantage : √©viter de devoir cr√©er des r√©sultats "bidons" sur les parties nouvelles du
   mod√®le, avant la reprise.
   
   
   Solution
   ========
   
   Il est possible de changer de mod√®le lorsqu'on fait une poursuite de STAT_NON_LINE et 
   c'est n√©cessaire quand on ajoute de la mati√®re (construction par couches) ou quand on en 
   retire (excavation).
   
   Le retrait de mati√®re est "facile" : Il n'y a qu'√† "oublier" un peu d'information dans 
   les champs "-" du 1er pas de temps.
   
   Pour l'ajout de mati√®re, c'est plus compliqu√© :
     * les champs aux noeuds sont prolong√©s par "z√©ro".
     * le cham_elem sont aussi prolong√©s par 0. L'utilsateur
     * Pour certaines lois de comportement un peu "tordues" (THM ?), l'√©tat initial des
   variables internes ne doit pas √™tre 0. Pour ce genre de mod√®le, c'est l'utilisateur qui
   cr√©e ce champ avant l'appel √† STAT_NON_LINE. Si plus tard, de 
   nouvelles mailles apparaissent dans le mod√®le, il faut trouver un moyen pour les 
   affecter √† la bonne valeur et √©viter que le code ne les mettent √† 0.
   
   On ne restitue donc rien, classement sans_suite.
   Si jamais le probl√®me pr√©sent√© par Fran√ßois V. se reproduit, il √©mettra une fiche d'anomalie.
   
   Impact documentation: pour expliquer en particulier l'initialisation des champs √† z√©ro.
   
   On ajoute une petite information dans la doc de STAT_NON_LINE
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : U4.51.03
VALIDATION
    rien
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR assire       ASSIRE Aimery          DATE 02/20/2012 - 05:11:00

--------------------------------------------------------------------------------
RESTITUTION FICHE 018423 DU 2012-02-15 12:34:51
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    modification du cas-test plexu01
FONCTIONNALITE
   Comme discut√© avec Christophe et Serguei, modification du cas-test plexu01.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    plexu01a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR berro        BERRO Hassan           DATE 02/20/2012 - 05:16:35

--------------------------------------------------------------------------------
RESTITUTION FICHE 017908 DU 2011-11-14 16:19:10
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    valgrind: REST_SOUS_STRUC
FONCTIONNALITE
   *
    ----------
   | Probl√®me |
    ----------
   REST_SOUS_STRUCT permet de restituer sur le syst√®me physique des r√©sultats obtenus par des
   calculs de sous-structuration (cyclique, dynamique, et harmonique).
   
   Le mot cl√© SQUELETTE permet de d√©finir le maillage squelette de la structure global sur
   laquelle les r√©sultats doivent √™tre restitu√©s.
   
   Quand on dispose √† l'entr√©e des r√©sultats g√©n√©ralis√©s (mot-cl√© RESU_GENE), la variable ISK
   est d√©finie par l'appel suivant :
   CALL GETVID(' ','SQUELETTE',1,IARG,0,K8B,ISK)
   ----> ISK = 0, si pas de concept squelette √† l'entr√©e
   
   Dans le cas o√π nous avons des r√©sultats physiques √† l'entr√©e (RESULTAT), ISK n'est pas
   d√©fini et nous trouvons dans le code ce bloc conditionnel :
         IF (ISK .EQ. 0) THEN
           (...)
   
       ===> Code_Aster plante
   
    ----------
   | Solution |
    ---------
   La solution est tr√®s simple, il suffit de faire un appel √† GETVID juste avant le bloc
   conditionnel. Ca devient:
           CALL GETVID(' ','SQUELETTE',1,IARG,0,K8B,ISK)
           IF (ISK .EQ. 0) THEN
             (...)
   
    ------------------
   | Sources impact√©s |
    ------------------
   fortran : op0077.f
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sdll133b, sdls106a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR pellet       PELLET Jacques         DATE 20/02/2012 - 16:18:59

--------------------------------------------------------------------------------
RESTITUTION FICHE 018057 DU 2011-12-12 14:49:31
TYPE evolution concernant Code_Aster (VERSION )
TMA : Necs
TITRE
    Option EPSI_ELGA pour les DKT
FONCTIONNALITE
   Le but de la fiche ÈtÈ de dÈvelopper l'option EPSI_ELGA pour les ÈlÈments de plaques et
   coques.
   
   Travail effectuÈ :
   ================
   
   Contrairement ‡ ce qui est indiquÈ dans la proposition, la modÈlisation DKTG n'a pas ÈtÈ
   traitÈe car ces ÈlÈments n'ont pas de sous-points (voir issue18428).
   
   …lÈments traitÈ :
   
   DKT            TRIA3            MEDKTR3
   DST            TRIA3            MEDSTR3
   DKT            QUAD4            MEDKQU4
   DST            QUAD4            MEDSQU4
   Q4G            QUAD4            MEQ4QU4
   
   COQUE_3D       TRIA7            MEC3TR7H
   COQUE_3D       QUAD9            MEC3QU9H
   
   
   
   Pour les ÈlÈments de plaques (DKT,DST et Q4G), nous avons ajoutÈ l'option ‡ la routine
   te0033. Nous avons modifiÈ les routines dktsie, dstsie ... en leur ajoutant l'argument
   OPTION, de faÁon ‡ ce qu'elles retournent les dÈformations si OPTION == 'EPSI_ELGA'. Nous
   avons copiÈ des routines dktcod, dstcod ... les quelques lignes qu'il manquait pour aller
   au bout du calcul des dÈformations dans ***sie.f.
   
   
   Pour les COQUE_3D,nous avons ajoutÈ l'option ‡ la routine te0410. Cette derniËre appelle
   vdxsig
   qui calcule toutes les options gÈrÈes par te0410. Tout Ètait dÈj‡ prÈvu dans cette
   routine pour avoir les dÈformations aux points de Gauss. La routine vdesga appelÈe ligne
   171 donne dÈj‡ en sortie EPS qui contient les dÈformations aux points de Gauss. Il
   a donc suffi de copier ces valeurs pour chaque couche et niveau.
   
   Sources impactÈes :
   =================
   te0033.f,dktsie.f,dstsie.f,dkqsie.f,dsqsie.f,q4gsie.f
   te0410.f,vdxsig.f
   gener_mecq32.cata  gener_medkt2.cata
   
   Validation :
   ==========
   
   Nous avons vÈrifiÈ sur des cas tests simples pour chaque type d'ÈlÈments que EPSI_ELGA
   concordait bien avec EPSI_ELNO.
   Dans les routines ***cod.f nous avons testÈ de changer NOEU en RIGI, les rÈsultats de
   EPSI_ELNO Ètaient alors les mÍmes que EPSI_ELGA.
   Enfin nous avons ajoutÈ le calcul de l'option EPSI_ELGA dans le cas test ssls200a qui
   comporte tous les types d'ÈlÈments que l'on souhaite tester.
   
   Impact documentaire :
   ==================
   
   Aucun
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssls200a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 02/21/2012 - 03:02:21

--------------------------------------------------------------------------------
RESTITUTION FICHE 018382 DU 2012-02-10 13:57:06
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    ssll14a avec le maillage au format MED sort en NOOK
FONCTIONNALITE
   Cette fiche est la r√©affectation d'une partie de la fiche 18149 (concernant le test 
   ssll14a)
   
    Le test ssll14a avec le maillage au format MED sort en NOOK.
    En imprimant le maillage au format aster, on constate que la seule diff√©rence avec le 
   maillage initial qui provoque l'erreur concerne l'ordre des noeuds dans les groupes de 
   noeuds.
   
   Dans POST_RELEVE_T, on fait une extraction sur des GROUP_NO. Or √† partir de ces 
   groupes on construit un chemin ordonn√©. Si l'ordre des noeuds est perturb√©, le chemin 
   n'est plus le bon, ce qui explique les divergences dans les r√©sultats.
   Il faut donc r√©ordonner les noeuds comme fait initialement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssll14a
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 016022 DU 2010-12-06 17:35:41
TYPE evolution concernant Code_Aster (VERSION )
TITRE
    [FORUM] Meilleur message pour les coques multi-couches
FONCTIONNALITE
   Sur le forum, un utilisateur des coques multi-couches rencontre l'erreur ELEMENTS_42 
   qui ne l'√©claire pas beaucoup ("comportement mat√©riau non admis").
   
   Diagnostic :
   ------------
   Il obtient cette erreur car il a d√©clar√© 3 plaques dans son mod√®le (chacune avec une
   √©paisseur diff√©rente). Sur ces 3 plaques, une est multicouche et utilise donc
   DEFI_COMPOSITE pour produire un concept mat√©riau sp√©cifique. Les 2 autres sont
   mono-couches mais utilisent ELAS_ORTH, il n'a pas fait de DEFI_COMPOSITE sp√©cifique 
   pour ces 2 couches.
   
   C'est cela qui pose probl√®me √† MECA_STATIQUE car le TE des plaques ne sait pas traiter 
   un mat√©riau de type ELAS_ORTH directement. Par contre il traite une coque multi-
   couches avec un ELAS_ORTH dedans !
   
   Il faut donc dans ce cas-l√† passer par DEFI_COMPOSITE pour d√©clarer un monocouche 
   ELAS_ORTH.
   
   Correction :
   ------------
   On am√©liore le message ELEMENTS_42 :
    Le comportement mat√©riau XXXX n'est pas trait√©. 
    Conseil : utilisez la commande DEFI_COMPOSITE pour dÔøΩfinir une coque monocouche avec 
   ce comportement.
   
   
   Routine impact√©e : dxmate.f
   Catalogue de messages : elements.py
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    fichiers associ√©s √† la fiche
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 014633 DU 2010-02-15 15:02:28
TYPE evolution concernant Documentation (VERSION )
TITRE
    AR01 Mieux d√©crire les contraintes principales dans les coques
FONCTIONNALITE
   dans la doc de CALC_CHAMP et CALC_ELEM on peut lire :
    | 'EQUI_ELNO'
     Contraintes "√©quivalentes" aux noeuds :
              VMIS : contrainte de von Mises
              VMIS_SG : contrainte de von Mises sign√©e 
              PRIN_1, PRIN_2, PRIN_3 : contraintes principales
              TRESCA : contrainte de Tresca
     .....
     Pour les √©l√©ments de coques, elles sont calcul√©es directement sur les contraintes
   locales (en un point de l'√©paisseur) aux noeuds (SIGM_ELNO).
   
   AJOUT:
   ------
   On ajoute que les contraintes principales sont au nombre de 3, et que celle
   corerpondant √† la normale doit √™tre nulle.
   Par contre l'ordre de rangement de PRIN_1, PRIN_2, PRIN_3 n'est pas particulier.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.01 U4.81.04
VALIDATION
    sans
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR foucault     FOUCAULT Alexandre     DATE 02/20/2012 - 03:20:09

--------------------------------------------------------------------------------
RESTITUTION FICHE 018363 DU 2012-02-08 14:02:35
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Anomalie PMINIT suite fiche 18285
FONCTIONNALITE
   Anomalie suite √† la fiche 18285:
   --------------------------------
   La fiche 18285 portait sur la mauvaise prise en compte des termes de cisaillement de
   EPSI_INIT et SIGM_INIT dans la commande SIMU_POINT_MAT.
   
   Pour corriger cette anomalie, une duplication des vecteurs d'entr√©e fournis par
   l'utilisateur doit etre r√©alis√©e. Cette copie permet ensuite d'appliquer le coefficient
   racine(2) sur les termes de cisaillement.
   
   Pour r√©aliser cette copie de vecteurs, j'ai utilis√© par m√©garde la routine LCEQVE qui
   utilise un COMMON TDIM. Ce COMMON n'est pas encore d√©fini lorsque je l'ai appel√©. 
   
   Cette erreur ne porte que sur la partie affichage dans le tableau r√©sultats pour l'√©tat
   initial.
   
   Solution:
   ---------
   Utilisation de la routine LCEQVN
   
   Impact Fortran:
   ---------------
   pminit.f
   
   Validation:
   -----------
   AFFICHAGE DES DONNES RESULTATS
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    AFFICHAGE
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 20/02/2012 - 17:27:01

--------------------------------------------------------------------------------
RESTITUTION FICHE 018106 DU 2011-12-15 16:28:20
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    En NEW11.1.1, le cas-test sslp322a est NOOK sur Rocks.
FONCTIONNALITE
   Probl√®me :
   ----------
   
   En NEW11.1.1, le cas-test sslp322a est NOOK sur Rocks.
   Je ne vois pas dans les modifs de la 11.1.1 ce qui a pu provoquer ce changement
   dans le K1 au 36eme pas de propagation.
   Alors que pour les pas suivants (37 -> 40) il n'y a pas d'erreur !
   
   
   Solution :
   ----------
   
   Finalement, sans rien faire, en NEW11.1.8 le cas-test se termine de nouveau correctement.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    sslp322a
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018184 DU 2012-01-09 15:08:26
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    RUPT : CALC_THETA : le mot-cle GRAD_NOEU_THETA='OUI' n'est pas teste
FONCTIONNALITE
   Probl√®me :
   ----------
   
   La valeur 'OUI' du mot-cl√© GRAD_NOEU_THETA de CALC_THETA n'est pas test√©e.
   (te0384 non couvert)
   
   
   Solution :
   ----------
   
   Ce mot-cl√© a √©t√© supprim√© en 11.1.6 (theta_bande).
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucun
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018273 DU 2012-01-23 15:22:04
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    Degradation du temps CPU du cas-test ssna118a en version 11.01.04.
FONCTIONNALITE
   Probl√®me :
   ----------
   
   Le cas test ssna118a a vu son temps CPU se d√©grader suite √† la version 11.01.04. 
   
   Entre les .mess des versions 10 et 11 de ce cas tests :
   
   Dans ce cas test au temps 2.122500, c'est normal d'avoir une non convergence, c'est fait
   pour tester la remont√©e de l'erreur et le red√©coupage du pas de temps.
   
   En version 10, au temps 2.122500 ==> non-cvg dans la ldc √† la pr√©diction ==> red√©coupage
   ==> OK
   
   En version 11.1.4, au temps 2.122500 ==> non-cvg dans la ldc √† la pr√©diction ==> pas de
   d√©coupage. Il faut attendre la fin des 8 it√©rations de Newton pour le faire ==> doublement
   du temps CPU
   
   Comme en 11.1.4, il y a la fiche 18155 sur le d√©coupage des pas de temps ... (en 11.1.3
   temps CPU normal).
   
   
   
   Solution :
   ----------
   
   L'analyse du probl√®me et sa solution a √©t√© apport√©e par Jean-Michel (merci √† lui).
   
   Une modif introduite en NEW11.1.4 consiste √† utiliser le code-retour 2 de NMCOMP comme
   crit√®re physique (porosit√© <0, ou > 1, etc..   ou crit√®re de radialit√© d√©pass√©).
   Je pensais que le code retour 2 n'√©tait utilis√© par personne ! (puisque le m√©canisme pour
   le g√©rer dans STAT_NON_LINE, en particulier la routine NMFINT n'√©tait pas en place).
   
   Mais il se trouve que IRRAD3M retourne un code-retour CODRET=2 dans NMCOMP dans certains
   cas (franchissement du seuil, ce qui am√®ne le message COMPOR1_58 :
   58: _(u"""
   Le franchissement du seuil de fluage ne se fait pas dans la tol√©rance donn√©e dans
   DEFI_MATERIAU
   pour la loi IRRAD3M, par le mot clef TOLER_ET.
      Tol√©rance sur le franchissement du seuil : <%(r1)E>
      Erreur sur le franchissement du seuil    : <%(r2)E>
   La subdivision du pas de temps au niveau global est d√©clench√©e.
   Il faut pour cela l'autoriser avec le mot clef SUBD_METHODE de la commande STAT_NON_LINE.
   """),
   
   Pour corriger cette situation, il faut affecter 1 au code-retour  CODRET de NMCOMP :
   
   ce qui implique de modifier IRTETI dans LCPLNL : en effet (suivez-moi bien !)
   
   - la routine IRRCVG qui examine la convergence locale de la loi IRRAD3M  fournit :
   -  IRTETI=0 si convergence,
   -  IRTETI=1 si non convergence, et ITER_INTE_MAXI non atteint, 
   - IRTETI=3 si ITER_INTE_MAX atteint, 
   - IRTETI=4 si franchissement du seuil de fluage
   - les valeurs 0,1,2,3 sont d'ailleurs sp√©cifi√©es (depuis la nuit des temps...) dans les
   commentaires des routines de  l'environnement PLASTI :
   C       OUT IRTETI = 0:  CONVERGENCE
   C           IRTETI = 1:  ITERATION SUIVANTE
   C           IRTETI = 2:  RE-INTEGRATION
   C           IRTETI = 3:  REDECOUPAGE DU PAS DE TEMPS
   et dans certaines lois (dont IRRAD3M) on trouve :
   C                       =3 ITMAX ATTEINT REDECOUPAGE LOCAL
   C                       =4 ITMAX ATTEINT  REDECOUPAGE GLOBAL
   
   
   - en sortie de LCCONV ( qui appelle IRRCVG ), LCPLNL, qui g√®re la boucle de NEWTON , la
   programmation actuelle est :
   - si   IRTETI = 1:  ITERATION SUIVANTE de Newton
   - si  IRTETI = 0:  CONVERGENCE +> sortie de Newton
   - si  IRTETI = 3 : demande de red√©coupage local => on sort avec CODRET=1
   - si  IRTETI = 4 : demande de red√©coupage global => on sort avec CODRET=2  ! c'est l√† que
   cela ne va pas 
   
   ensuite CODRET est transmis √† LC0032, puis LC0000, puis REDECE (qui effectue le
   red√©coupage local du pas de temps si CODRET=1, et rien si CODRET=0 ou 2), puis NMCOMP.
   
   PB : il ne faudrait pas sortir de NMCOMP avec CODRET=2.
   
   - correction : 
   en modifiant LCPLNL pour avoir CODRET=1, si IRTETI=4, on obtient :
   
   - version actuelle, SSNA118A prend environ 1200s sur aster4, alors qu'il prenait environ
   600s avant la NEW11.1.14
   
   - version LCPLNL modifi√©e : le test prend 260s, et il y a de l√©gers NOOK  (et les 8 autres
   tests sont OK)           
   NOOK  AUTRE_ASTER      XXXX             0.019742297805332        0.019746902124197       
   0.0233%          4.0E-03%        
   NOOK  AUTRE_ASTER      XXXX             0.024549781585973        0.024555337948263       
   0.0226%          3.0E-03%               
   NOOK  AUTRE_ASTER      XXXX             4.6968262899641E-03      4.6943792471685E-03     
   0.0521%          3.0E-03%        
   NOOK  AUTRE_ASTER      XXXX             0.012175452642309        0.012168470285160       
   0.0573%          5.0E-03%        
   NOOK  AUTRE_ASTER      XXXX             120.35579661571  120.32799092864  0.0231%        
    1.0E-03%        
   NOOK  AUTRE_ASTER      XXXX             23.630930943705  23.584054959749  0.198%         
    0.02000%        
   
   En effet dans le cas pr√©sent, il y a ITER_INTE_PAS=-100 / -200 dans le fichier de commandes. 
   Avec la correction, on red√©coupe donc localement en 100 pas ou 200 pas dans le cas "
   franchissement du seuil de fluage", ce que l'on ne faisait pas avant. Il s'av√®re que c'est
   plus efficace sur ce test que la subdivision globale.
   
   - version LCPLNL modifi√©e et fichier de commandes modifi√© : on enl√®ve ITER_INTE_PAS=-100.
   SSNA118A tourne en 630s (comme avant) : il y a des subdivisions globales. Les tests sont OK.
   
   Je propose que l'on restitue cette correction de LCPLNL. : pas de traitement particulier
   si IRTETI=4 : on applique le m√™me traitement que IRTETI=3 : subdivision locale si
   l'utilisateur l'a demand√©, et globale sinon.
   En effet, la subdivision locale peut √™tre efficace dans certains cas.
   
   Du coup, ce n'est plus la peine de distinguer le code retour 3 ou 4 -> suppression du code
   retour =4 dans lcconv.f
   Ce simplifie et am√©loire la lisibilit√© de lcconv.f. Cette routine redevient une simple
   routine d'aiguillage, sans modification des codes retours des lois.
   
   Impacts :
    lcplnl.f, lcconv.f, lcmmcv.f, irrcvg.f, burcvg.f
    ssna118a.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna118a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------
RESTITUTION FICHE 018301 DU 2012-01-26 15:40:45
TYPE anomalie concernant Code_Aster (VERSION 11.2)
TITRE
    En NEW11.01.06, le cas-test ssnp110c s‚Äôarr√™te en erreur fatale sur Calibre5.
FONCTIONNALITE
   Probl√®me :
   ----------
   
   En NEW11.01.06, le cas-test ssnp110c s‚Äôarr√™te en erreur fatale sur Calibre5. 
   Erreur num√©rique dans CALC_ELEM, option DERA_ELGA sur le r√©sultat X-FEM.
   Cela est li√© √† la restitution de la fiche 18181.
   
   
   Solution :
   ----------
   
   Je n'ai pas eu le temps de regarder que le cas-test se termine de nouveau correctement en
   NEW11.1.8.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  NON
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssnp110c
NB_JOURS_TRAV  : 0.1
--------------------------------------------------------------------------------
RESTITUTION FICHE 018335 DU 2012-02-02 14:40:48
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    RUPT : sslv134g pb SDVERI
FONCTIONNALITE
   Probl√®me :
   ----------
   
   Si on met le cas test sslv134g en SDVERI='OUI', on obtient le message suivant :
     Objet : 'FISS1   .FOND.NOEU'    Message : n'existe pas
   
   D'apres la doc et le catalogue python de la sd_fond_fiss (cr√©√©e par DEFI_FOND_FISS),
   l'objet .FOND.NOEU doit toujours exister.
   
   Or dans ce cas, il n'existe pas.
   C'est normal, car c'est le seul cas test qui utilise la fonctionnalit√© de fond de fissure
   "d√©doubl√©" (TYPE_FOND='INF' et 'SUP'). Dans ce cas, l'objet .FOND.NOEU n'existe pas, mais
   il est remplac√© dans les 2 objets .FONDINF.NOEU et .FONDSUP.NOEU.
   
   
   Solution :
   ----------
   
   On modifie sd_fond_fiss.py pour rendre facultatif .FOND.NOEU (on pourrait s√ªrement faire
   mieux).
   On rajoute SDVERI='OUI' dans sslv134g.comm
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : d4.10.01
VALIDATION
    sslv134g
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR idoux        IDOUX Ludovic          DATE 02/20/2012 - 02:42:57

--------------------------------------------------------------------------------
RESTITUTION FICHE 018391 DU 2012-02-10 16:33:57
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    D√©gradation du temps de adls102a, sdll26a et sdls113a en 11.1.7.
FONCTIONNALITE
   Probl√®me :
   
   Pour le calcul des √©nergies, on est oblig√© de sauvegarder dans la SD RESULTAT certains
   champs nodaux suppl√©mentaires.
   Dans DYNA_LINE_TRAN, ces champs sont sauvegard√©s qu'on active ou non le calcul des
   √©nergies. On se retrouve alors √† stocker pour chaque pas de temps dans la SD RESULTAT des
   champs nuls. 
   Ceci conduit √† un surco√ªt en temps CPU, d'autant plus que DYNA_LINE_TRAN fait souvent
   beaucoup de pas de temps de calcul.
   
   Solution :
   
   Il ne faut pas √©crire ces champs dans la SD RESULTAT lorsque c'est inutile... 
   Pour ce faire, j'utilise le m√©canisme des champs exclus de l'archivage, qui est d√©j√†
   pr√©sent. Si on ne demande pas le calcul des √©nergies, ce m√©canisme me permet de ne pas
   sauvegarder les champs inutiles.
   
   Impact fortran :
   dlnewi.f
   dldiff.f
   dladap.f
   
   Validation :
   Les temps de calcul des cas-tests baissent √† des niveaux comparables √† ceux d'avant.
   On v√©rifie √©galement que les grandeurs √† sauvegarder le sont bien lorsqu'on calcule
   effectivement les √©nergies.
   
   adls102a :
   33.11s -> 12.78s
   sdll126a :
   51.78s -> 37.44s
   sdls113a :
   26.40s -> 22.63s
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    adls102a sdll126a sdls113a
NB_JOURS_TRAV  : 0.5
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR geniaut      GENIAUT Samuel         DATE 02/21/2012 - 01:33:02

--------------------------------------------------------------------------------
RESTITUTION FICHE 018093 DU 2011-12-14 12:43:21
TYPE evolution concernant Code_Aster (VERSION )
TMA : Phimeca
TITRE
    RUPT : harmonisation des vecteurs de la base locale entre DEFI_FOND_FISS et DEFI_FISS_XFEM
FONCTIONNALITE
   Probl√®me :
   ----------
   
   La base locale calcul√©e par DEFI_FOND_FISS ne respecte pas la r√®gle 'implicite' :
   vecteur normal orient√© de la l√®vre inf vers la l√®vre sup, utilis√©e dans X-FEM.
   
   Il faudrait corriger cela, afin d'harmoniser les vecteurs de la base locale entre
   DEFI_FOND_FISS et DEFI_FISS_XFEM.
   Cela permettra notamment de simplifier la prog de post_k1_k2_k3
   
   
   
   Realisation:
   ------------
   
   a/ La structure de BASEFOND de la sd_fond_fiss est calqu√©e sur celle de sd_fiss_xfem.
   
    c'est-√†-dire on a: 
     - (vnor,vdir) au lieu de (vdir,vnor),
     - une dimension N*2*2 en 2D au lieu de N*6
   
   -> post_k1_k2_k3_ops est modifi√© lors de la r√©cup√©ration de la base locale.
     (de plus le nom des variables passe de vn en vnor et de vp en vdir comme dans le fortran)
   
   b/ on oriente VNOR de la l√®vre inf vers la l√®vre sup quand LEVRE_SUP est indiqu√©.
   -> l'op√©ration de r√©orientation de VNOR dans post_k1_k2_k3_ops est supprim√©e.
   
   Op√©ration r√©alis√©e pour l'orientation de VNOR:
   On a cr√©e une nouvelle routine, nomm√©e fonno8, o√π on calcule un vecteur qui a pour origine
   le premier noeud du fond et qui se dirige vers un point de la l√®vre sup√©rieure (√† savoir
   le centre de gravit√© d'une maille de la l√®vre sup√©rieure).
   Dans fonno6, ce vecteur est projet√© sur la normale. Si la projection est n√©gative on
   r√©oriente la normale.
   
   
   Validation:
   tous les cas-tests contenant DEFI_FOND_FISS
   
   Impacts:
   
   DOC:
   D4.10.01
   
   Fortran:
   ajout fonno8
   fonnor
   fonno6
   fonno7
   meficg
   memokg
   gcour2
   gcouro
   
   PY:
   post_k1_k2_k3_ops
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : d4.10.01
VALIDATION
    cas-tests defi_fond_fiss
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR delmas       DELMAS Josselin        DATE 02/21/2012 - 01:33:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 016959 DU 2011-05-19 13:20:59
TYPE evolution concernant Code_Aster (VERSION )
TMA : Phimeca
TITRE
    AR01 - Assurer l'autoportance de CALC_ERREUR
FONCTIONNALITE
   Objectif :
   --------
   CALC_ERREUR doit √™tre autoportant : on doit g√©rer directement les d√©pendances au sein de
   l'op√©rateur et ne pas obliger l'utilisateur √†  faire un CALC_ELEM pr√©alable.
   
   L'id√©e est de faire comme pour CALC_CHAMP : On met le nom de l'option que l'on souhaite
   calculer sans se soucier des d√©pendances.
   
   Proposition :
   -----------
   1) Dans la routine modopt on propose:
   - Si pr√©sence de l'option ERTH_ELEM on v√©rifie que FLUX_ELNO est dans la sd_resu sinon on
   le calcule.
   
   2) Si OPTION=ERME_ELEM:
   
   -->En THM, on a besoin du champ SIEF_ELNO. Donc:
       - En THM, on v√©rifie que SIEF_ELNO est dans la sd_resu sinon on le calcule.
   
   -->En XFEM, on a besoin des champs SIGM_ELNO et SISE_ELNO:
       - En XFEM, on v√©rifie que SIGM_ELNO et SISE_ELNO sont dans la sd_resu sinon on les
   calcule.
   
   -->Dans le cas g√©n√©ral, on a besoin du champ SIGM_ELNO:
        - on v√©rifie que SIGM_ELNO est dans la sd_resu sinon on le calcule.
   
   3) on propose de supprimer le traitement des options EPTU_ELNO et DERA_ELNO dans modopt
   car il est d√©j√† fait dans calcop.
   
   4) Pour √©viter l'arr√™t du code si l'utilisateur donne une liste d'instants comprenant
   l'instant initial,
   on fait passer le message INDICATEUR_3 de <F> √†  <I> et on modifie son contenu.
   
   Le message <F> INDICATEUR_3 :
   
   3: _(u"""
   On ne peut pas calculer un indicateur d'erreur spatial √†  l'instant initial.
   Revoyez votre liste d'instants de calcul.
   Conseil : Faites-la d√©marrer au premier instant suivant l'instant initial.
   """),
   
   est chang√© en <I>:
   
   3: _(u"""
   On ne peut pas calculer un indicateur d'erreur spatial √†  l'instant initial.
   L'indicateur d'erreur spatial ne sera pas calcul√© √†  cet instant.
   """),
   
   Remarques :
   ---------
   1) Il n'a pas √©t√© possible de retirer le 1er CALC_ELEM de la poursuite wtnl100e.com1.
   
   En effet:
   Dans le .comm on a un RESU_2=STAT_NON_LINE(...) et dans le .com1
   RESU_2=STAT_NON_LINE(reuse=RESU_2...).
   
   Dans modopt, lorsque l'on v√©rifie la pr√©sence du champ SIEF_ELNO avec RSCHEX, on obtient
   un code retour (IRET .NE. 0) pour le RESU_2 dans le com1 car ce champ a √©t√© calcul√© pour
   les 1er num√©ros d'ordre dans le .comm.
   RSCHEX ne prend pas en compte le fait que ce champ n'a pas √©t√© calcul√© dans le .com1 pour
   la suite des num√©ros d'ordre.
   
   2) Dans le cas-test ssnp14a on a un TEST_RESU sur le champ DERA_ELGA. Or, contrairement √† 
   modopt, l'utilisation de la routine calcop n'assure pas le stockage du champ DERA_ELGA. On
   a donc ajout√© un CALC_ELEM option DERA_ELGA pour garder le TEST_RESU sur ce champ. 
   
   Impacts :
   -------
   PY:
   indicateur.py
   
   F:
   meca01.f  modopt.f
   
   CAS-TESTS:
   demo001a
   sslp107a
   sslp316a
   sslp316b
   ssls09b
   ssls09c
   sslv07b
   sslv111a
   sslv111b
   sslv111c
   sslv111d
   sslv111e
   sslv113a
   sslv113b
   sslv113c
   sslv113d
   sslv134d
   ssnp130a
   ssnp130b
   ssnp130c
   ssnp130d
   ssnp130e
   ssnp130f
   ssnp14a
   ssnv124b
   tpll01j
   wtnl100e
   wtnl100f
   wtnp110a
   wtnp116a
   wtnp116b
   zzzz121b
   zzzz121c
   zzzz121e
   zzzz175a
   zzzz257a
   zzzz257b
   zzzz257c
   zzzz257d
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : U4.81.06
VALIDATION
    cas-tests utilisant CALC_ERREUR
--------------------------------------------------------------------------------
RESTITUTION FICHE 016992 DU 2011-05-25 09:25:21
TYPE evolution concernant Code_Aster (VERSION )
TMA : Phimeca
TITRE
    CALC_CHAM_ELEM : catalogue et documentation
FONCTIONNALITE
   Objectif :
   --------
   La commande CALC_CHAM_ELEM peut produire un cham_elem aux points de Gauss contenant les
   coordonn√©es des points de Gauss et leur poids.
   
   Cette commande traitait initialement des options en thermique et en acoustique et la
   fonctionnalit√© d'extraction des coordonn√©es des points de Gauss a visiblement √©t√© rajout√©
   ensuite.
   ==> La synth√®se dans la doc n'est pas claire √† ce sujet : on parle toujours d'une commande
   qui "Calcule un champ √©l√©mentaire, en thermique et en acoustique, √† partir de champs d√©j√† 
   calcul√©s de type cham_no_*"
   
   Pour l'extraction des points de Gauss, un champ de mat√©riau ne sert √†  rien, or il est
   obligatoire dans la commande.
   
   
   Proposition :
   -----------
   1) CHAM_MATER ne sert qu'en thermique.
   On propose d'ajouter un bloc: si FLUX_XXX alors CHAM_MATER est obligatoire.
   
   2) Si on choisit l'option PRAC_ELNO, on rentre actuellement dans la routine mecoac (dans
   l'op38).
   Dans celle-ci on traite l'option INTE_ELNO, qui n'existe pas dans CALC_CHAM_ELEM.
   Comme il y a peu de lignes qui concernent PRAC_ELNO, on propose de supprimer mecoac et
   d'appeler directement la routine CALCUL dans l'op38.
   (mecoac n'est appel√© que par l'op38)
   
   3) Dans l'op38 on test OPTION==SOUR_ELGA: or cette option n'existe plus. On propose de
   faire le m√©nage dans l'op38.
     
   4) Dans les docs des cas-tests sslv100 et sslv04 on mentionne CALC_CHAM_ELEM alors que
   cette commande n'est plus test√©e dans ces cas-tests. On propose de supprimer le paragraphe
   "fonctionnalit√©s test√©es". 
     
   Impact:
   ---------
   F
   suppression mecoac.f
   op0038.f
   
   CAPY
   calc_cham_elem.capy
   
   TESTS
   ahlv100a
   sslp200a
   sslp200b
   ssls101c
   sslv117a
   sslv140a
   sslv200a
   sslv200b
   ssna121a
   ssns107a
   ssns107b
   ssns107c
   ssns107d
   ssnv169a
   ssnv169c
   ssnv178a
   ssnv178b
   zzzz266a
   zzzz266b
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : u4.81.03 v3.04.004 v3.04.100
VALIDATION
    passage des tests CALC_CHAM_ELEM
--------------------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR desroche     DESROCHES Xavier       DATE 02/21/2012 - 01:33:03

--------------------------------------------------------------------------------
RESTITUTION FICHE 018278 DU 2012-01-24 13:56:55
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : DeltaCad
TITRE
    ssla200a NOOK en convertissant le maillage
FONCTIONNALITE
   Les 8 cas-tests suivants:
   ssla200a, ssla200b, sslp200a, sslp200b, sslp201a, sslp201b, sslv200a et 
   sslv200b
   deviennent NOOK lorsqu'on convertit leurs maillages au format MED.
   
   Deux anomalies ont ete detectees:
   
   1) au niveau de POST_ELEM:
   Une erreur de programmation dans peenca.f avait ete commise. Dans cette 
   routine, on parcourt les groupes d'elements (GREL) et on traite 
   uniquement ceux dont les elements sont 2D et 3D. Pour les elements 0D et 1D, 
   on passe au grel suivant SANS decaler le pointeur des numeros d'elements, 
   d'ou les retours NOOK. 
   => le decalage du pointeur au nombre des elements 0D et 1D corrige le 
   probleme.
   L'analyse des r√©sultats faux sur les calculs d'√©nergie sera faite dans la fiche 18436.
   
   2) au niveau de MECA_STATIQUE
   Les cas-tests sslv200a et sslv200b ont 3 retours NOOK suite a des tests 
   sur les valeurs issues de la resolution du systeme lineaire. On y teste 
   la somme absolue des valeurs de deplacement a un numero d'ordre.
   On constate que le remplacement du .mail par le .med modifie le resultat 
   de deplacement. 
   Detail: on a regarde la composante DX; on a remarque que les valeurs 
   differaient a la 12eme decimale,
   mais etant donne que le deplacement suivant X est de l'ordre de E+05, la 
   somme des DX en valeur absolue devient significative.
   
   Les valeurs √©tant tr√®s proches (inf√©rieures √† 10-7),il a ete convenu de modifier la 
   tol√©rance des cas-tests.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssla200a, ssla200b, sslp200a, sslp200b, sslp201a, sslp201b, sslv200a et
--------------------------------------------------------------------------------
RESTITUTION FICHE 018284 DU 2012-01-24 15:30:00
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TMA : DeltaCad
TITRE
    ssnv148 a et plantage dans POST_ELEM
FONCTIONNALITE
   Anomalie
   ========
   Le remplacement du fichier de maillage au format "mail" par le fichier au format "med"
   genere une erreur fatale dans POST_ELEM.
   
   Description et correction
   =========================
   Lorsque Code_Aster execute le POST_ELEM/RICE_TRACEY sur les 14 mailles fournies (de M1 
   a M14), il s'arrete dans la routine MEMOY a cause d'un "floating point Exception". En 
   effet, il rencontre une divison par zero : la quantite VR(2) du quotient VR(1) sur VR
   (2) est "anormalement" nulle !
   
   Nous avons isole le probl√®me: il se produit uniquement avec la maille M14.
   
   Pour detecter l'anomalie, nous avons analyse les routines dediees a l'option 
   RICE_TRACEY de POST_ELEM.
   Nous avons releve une erreur de programmation dans memoy.f. Dans cette routine, on
   parcourt les groupes d'elements (GREL) afin d'identifier celui contenant la maille 
   M14. En affichant les mailles des grels, on a constate un oubli de decalage de 
   numerotation qui conduit a ne pas trouver la mailles M14 dans les grels parcourus.
   En effet, pour les grels 0D et 1D (POI1, SEG2, et SEG3), on passe aux grels suivants 
   (car seuls les grels 2D et 3D sont consideres). Or le pointeur des numeros de maille 
   dans la liste des groupes d'elements (LIGREL) n'avait pas ete decale lors de la "non 
   prise encompte" de ces grels.
   
   Nous avons donc decale ce pointeur au nombre d'elements presents dans chacun des grels 
   0D et 1D.
   
   Ce probleme a pu etre mis en evidence car les grels produits a partir d'un maillage 
   med ne sont pas ordonnes comme ceux d'un .mail.
   
   Validation
   ==========
   cas-tests ssna108a et ssnv148a.
   
   Ajouts
   ======
   La m√™me erreur de programmation a √©t√© d√©cel√©e dans mesomm √† 2 endroits et est corrig√©e.
   L'analyse des r√©sultats faux li√©s √† cette fiche ainsi qu'√† la fiche 18278 sera faite 
   dans la fiche 18436.
RESU_FAUX_VERSION_EXPLOITATION    :  OUI   DEPUIS : 3.1
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  OUI
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    ssna108a ssnv148a
--------------------------------------------------------------------------------



-----------------------------------------------------------------------

--------------------------------------------------------------------------------
--- AUTEUR sellenet     SELLENET Nicolas       DATE 02/20/2012 - 03:08:14

--------------------------------------------------------------------------------
RESTITUTION FICHE 018361 DU 2012-02-07 14:08:31
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    TE et couverture de code
FONCTIONNALITE
   Les TE 394 et 159 ne sont plus appelables. On les supprime.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    aucune
NB_JOURS_TRAV  : 0.01
--------------------------------------------------------------------------------
RESTITUTION FICHE 018400 DU 2012-02-13 16:32:55
TYPE anomalie concernant Code_Aster (VERSION 11.1)
TITRE
    LIRE_CHAMP, format MED, carte
FONCTIONNALITE
   Probl√®me :
   ----------
   """
   Je lis un champ exprim√© sur les t√©tra√®dres de mon maillage : 1 valeur par t√©tra√®dre. Je le
   lis sous forme de champ de grandeur de type CART_NOEU_R car je ne veux pas avoir affaire √†
   un mod√®le, sachant que c'est une valeur sans lien avec les √©l√©ments finis (en l'occurence,
   c'est le niveau de raffinement de chaque maille).
   La lecture se passe sans plantage (√† la diff√©rence de STA11). Mais le champ de grandeur
   cr√©√© ne correspond pas au champ pr√©sent dans le fichier. Un IMPR_CO montre que les valeurs
   sont nulles.
   """
   
   
   Solution :
   ----------
   En r√©alit√©, ce qui a troubl√© l'utilisateur, c'est le fait que LIRE_CHAMP sorte un carte.
   En effet, le stockage des donn√©es dans une carte est compl√®tement diff√©rent dans une carte
   par rapport √† un cham_elem ou un cham_no. La carte relue √©tait bien correcte.
   
   Un autre √©l√©ment troublant tient au fait que l'utilisateur a demand√© l'impression de la
   carte √† IMPR_RESU. Or IMPR_RESU ne sait pas imprimer le cartes. Il aurait √©t√© souhaitable
   qu'IMPR_RESU informe l'utilisateur de cet √©tat de fait. On ajoute donc l'√©mission d'une
   information.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 0.2
--------------------------------------------------------------------------------
RESTITUTION FICHE 018405 DU 2012-02-14 12:42:48
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Erreur de programmation avec CALC_CHAMP
FONCTIONNALITE
   Probl√®me :
   ----------
   """
   Dans le calcul joint, on plante dans un ASSERT (du √† un DISMOI) lors de l'appel √† un
   CALC_CHAMP avec le mot-cl√© EXCIT/COEF_MULT_C renseign√©.
   Remarque : ce mot-cl√© est obligatoire dans le cas trait√©.
   """
   
   
   Analyse :
   ---------
   Le plantage a lieu dans DEBCAL sur le calcul d'EFGE_ELNO. C'est sur le DISMOI sur le
   maillage √† la ligne 154. On v√©rifie que le maillage sur lequel repose le champ IN de
   CALCUL est bien identique √† celui du LIGREL.
   
   Le champ IN a √©t√© cr√©√© par MECEUC en d√©coupant un champ complexe en une partie r√©elle et
   une partie imaginaire.
   
   En fait, ce champ est une carte mais une carte incompl√®te (car SEPACH qui fait le
   d√©coupage ne sait pas traiter les cartes). Il lui manque le '.NOMA'. Cette carte est
   construite √† partir de COEF_MULT_C donn√© √† CALC_CHAMP par l'utilisateur.
   
   
   Solution :
   ----------
   Apr√®s avoir discuter avec Jacques et Micka√´l, on a d√©cid√© d'interdire COEF_MULT_C,
   FONC_MULT_C et PHAS_DEG en entr√©e de CALC_CHAMP car la routine MECEUC n'est pas adapt√©e
   pour le traitement de ce cas.
   
   Je modifie aussi SEPACH pour qu'il traite correctement les cartes. √Ä l'heure actuelle, il
   traite les cartes comme des cham_no.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    test unitaire
NB_JOURS_TRAV  : 1.0
--------------------------------------------------------------------------------
RESTITUTION FICHE 018416 DU 2012-02-15 10:37:57
TYPE anomalie concernant Code_Aster (VERSION 10.5)
TITRE
    Plantage CREA_TABLE sur le champ d'indicateur d'erreur
FONCTIONNALITE
   Probl√®me :
   ----------
   """
   Je cherche √† r√©cup√©rer une table Aster contenant le diam√®tre des mailles.
   
   Le test joint essaie de r√©pondre √† l'objectif (en utilisant la composante TAILLE de
   l'indicateur
   d'erreur m√©canique) mais je plante dans un crea_table √† partir d'un r√©sultat de calcul
   d'indicateur d'erreur. Le plantage est l'erreur jeveux :
   
   La liste de param√®tres de cr√©ation d'objet est incompl√®te.
   """
   
   
   Analyse :
   ---------
   La routine CTCRTB cherche les param√®tres √† utiliser pour cr√©er la table demand√©e. Elle le
   fait en 2 passes :
   1) recherche du nombre de param√®tres pour allouer les vecteurs JEVEUX,
   2) remplissage des vecteur avec les param√®tres √† retenir pour la cr√©ation de la table.
   
   Le probl√®me, c'est que les phases 1 et 2 ne sont pas r√©alis√©es de la m√™me mani√®re. Du coup
   dans notre cas, on se retrouve √† avoir trouv√© dans la phase 1 10 param√®tres et dans la
   phase 2, on n'en remplie que 9. De ce fait √† la cr√©ation de la table, on plante parce
   qu'on dit qu'on a 10 param√®tres mais on n'en donne que 9.
   
   
   Solution :
   ----------
   Je fais en sorte de faire strictement les m√™mes op√©rations dans la phase 1 et dans la
   phase 2. Ainsi le plantage disparait.
RESU_FAUX_VERSION_EXPLOITATION    :  NON
RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
IMPACT_DOCUMENTAIRE : 
VALIDATION
    unitaire
NB_JOURS_TRAV  : 0.02
--------------------------------------------------------------------------------



========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

 CASTEST MODIF ahlv100a                      macocco K.MACOCCO          286      2      2
 CASTEST MODIF demo001a                      macocco K.MACOCCO          301      1      5
 CASTEST MODIF hsnv121a                        abbas M.ABBAS            218      3      3
 CASTEST MODIF hsnv125d                        abbas M.ABBAS            472      3      3
 CASTEST MODIF perfe01a                        abbas M.ABBAS            320      2      2
 CASTEST MODIF perfe03a                        abbas M.ABBAS            334      3      3
 CASTEST MODIF plexu01a                       assire A.ASSIRE           240      4     12
 CASTEST MODIF sdnv104c                        abbas M.ABBAS            243      1      2
 CASTEST MODIF ssll14a                      desroche X.DESROCHES        608     22      9
 CASTEST MODIF sslp107a                      macocco K.MACOCCO          388      2      6
 CASTEST MODIF sslp200a                      macocco K.MACOCCO         1472      1      2
 CASTEST MODIF sslp200b                      macocco K.MACOCCO         1525      2      3
 CASTEST MODIF sslp316a                      macocco K.MACOCCO          282     12      6
 CASTEST MODIF sslp316b                      macocco K.MACOCCO          241     11      6
 CASTEST MODIF ssls09b                       macocco K.MACOCCO          323      1      5
 CASTEST MODIF ssls09c                       macocco K.MACOCCO          204      1      5
 CASTEST MODIF ssls101c                      macocco K.MACOCCO          450      1      2
 CASTEST MODIF ssls200a                     cheignon E.CHEIGNON         381     30     58
 CASTEST MODIF sslv07b                       macocco K.MACOCCO          157      2      2
 CASTEST MODIF sslv111a                      macocco K.MACOCCO          465      1      6
 CASTEST MODIF sslv111b                      macocco K.MACOCCO          386      1      6
 CASTEST MODIF sslv111c                      macocco K.MACOCCO          387      1      6
 CASTEST MODIF sslv111d                      macocco K.MACOCCO          386      1      6
 CASTEST MODIF sslv111e                      macocco K.MACOCCO          387      1      6
 CASTEST MODIF sslv113a                      macocco K.MACOCCO          273      6      6
 CASTEST MODIF sslv113b                      macocco K.MACOCCO          285      6      6
 CASTEST MODIF sslv113c                      macocco K.MACOCCO          177      1     11
 CASTEST MODIF sslv113d                      macocco K.MACOCCO          177      1     11
 CASTEST MODIF sslv117a                      macocco K.MACOCCO          128      2      3
 CASTEST MODIF sslv134d                      macocco K.MACOCCO          580      1      4
 CASTEST MODIF sslv134g                      geniaut S.GENIAUT          651      3      3
 CASTEST MODIF sslv140a                      macocco K.MACOCCO          242      2      3
 CASTEST MODIF sslv200a                      macocco K.MACOCCO         1101      8      8
 CASTEST MODIF sslv200b                      macocco K.MACOCCO         1061      9      9
 CASTEST MODIF ssna102d                        abbas M.ABBAS            311      1      1
 CASTEST MODIF ssna117b                      geniaut S.GENIAUT          310      2      4
 CASTEST MODIF ssna118a                      geniaut S.GENIAUT          303      6      6
 CASTEST MODIF ssna121a                      macocco K.MACOCCO          240      3      3
 CASTEST MODIF ssnd110a                        abbas M.ABBAS            792      2      2
 CASTEST MODIF ssnd110b                        abbas M.ABBAS            653      2      2
 CASTEST MODIF ssnd112a                        abbas M.ABBAS            777      4      4
 CASTEST MODIF ssnd112b                        abbas M.ABBAS            515      2      2
 CASTEST MODIF ssnd112c                        abbas M.ABBAS            930      4      4
 CASTEST MODIF ssnp101a                        abbas M.ABBAS            263      3      3
 CASTEST MODIF ssnp130a                      macocco K.MACOCCO          329      3      8
 CASTEST MODIF ssnp130b                      macocco K.MACOCCO          314      3      3
 CASTEST MODIF ssnp130c                      macocco K.MACOCCO          273      3      3
 CASTEST MODIF ssnp130d                      macocco K.MACOCCO          289      3      3
 CASTEST MODIF ssnp130e                      macocco K.MACOCCO          242      2      2
 CASTEST MODIF ssnp130f                      macocco K.MACOCCO          241      2      2
 CASTEST MODIF ssnp14a                       macocco K.MACOCCO          619      5      1
 CASTEST MODIF ssnp503k                        abbas M.ABBAS            179      2      3
 CASTEST MODIF ssnp504e                        abbas M.ABBAS            240      1      2
 CASTEST MODIF ssns107a                      macocco K.MACOCCO          191      2      3
 CASTEST MODIF ssns107b                      macocco K.MACOCCO          194      2      3
 CASTEST MODIF ssns107c                      macocco K.MACOCCO          189      2      3
 CASTEST MODIF ssns107d                      macocco K.MACOCCO          193      2      3
 CASTEST MODIF ssnv104e                        abbas M.ABBAS            460      2      2
 CASTEST MODIF ssnv124b                      macocco K.MACOCCO          161      3      3
 CASTEST MODIF ssnv126a                        abbas M.ABBAS            461      3      3
 CASTEST MODIF ssnv128m                        abbas M.ABBAS            258      1      2
 CASTEST MODIF ssnv128n                        abbas M.ABBAS            176      1      3
 CASTEST MODIF ssnv128q                        abbas M.ABBAS            193      1      2
 CASTEST MODIF ssnv128s                        abbas M.ABBAS            213      2      5
 CASTEST MODIF ssnv128t                        abbas M.ABBAS            221      7      5
 CASTEST MODIF ssnv128u                        abbas M.ABBAS            254      1      1
 CASTEST MODIF ssnv128v                        abbas M.ABBAS            212      1      2
 CASTEST MODIF ssnv128x                        abbas M.ABBAS            178      1      2
 CASTEST MODIF ssnv148a                      macocco K.MACOCCO          376      3      3
 CASTEST MODIF ssnv169a                      macocco K.MACOCCO          241      1      2
 CASTEST MODIF ssnv169c                      macocco K.MACOCCO          215      1      2
 CASTEST MODIF ssnv171c                        abbas M.ABBAS            395      3      3
 CASTEST MODIF ssnv172a                        abbas M.ABBAS           1401     13     13
 CASTEST MODIF ssnv172b                        abbas M.ABBAS            197      3      3
 CASTEST MODIF ssnv178a                      macocco K.MACOCCO          325      2      3
 CASTEST MODIF ssnv178b                      macocco K.MACOCCO          325      2      3
 CASTEST MODIF ssnv183a                        abbas M.ABBAS            564      4      4
 CASTEST MODIF ssnv194a                        abbas M.ABBAS            324      3      3
 CASTEST MODIF ssnv194b                        abbas M.ABBAS            209      2      2
 CASTEST MODIF ssnv194c                        abbas M.ABBAS            233      3      3
 CASTEST MODIF ssnv207a                     foucault A.FOUCAULT         265      2      2
 CASTEST MODIF ssnv209a                        abbas M.ABBAS            231      1      2
 CASTEST MODIF ssnv209f                        abbas M.ABBAS            268      1      2
 CASTEST MODIF ssnv209i                        abbas M.ABBAS            189      1      2
 CASTEST MODIF tpll01j                       macocco K.MACOCCO          135      1      6
 CASTEST MODIF tplv100a                      macocco K.MACOCCO          470      1      1
 CASTEST MODIF tplv100b                      macocco K.MACOCCO          135      2      2
 CASTEST MODIF tplv100c                      macocco K.MACOCCO          138      2      2
 CASTEST MODIF tplv100d                      macocco K.MACOCCO          260      1      1
 CASTEST MODIF tplv100e                      macocco K.MACOCCO          248      1      1
 CASTEST MODIF wtnl100e                      macocco K.MACOCCO          208      3     22
 CASTEST MODIF wtnl100f                      macocco K.MACOCCO          206      3     13
 CASTEST MODIF wtnp110a                      macocco K.MACOCCO          246      3      3
 CASTEST MODIF wtnp116a                      macocco K.MACOCCO          473      6     20
 CASTEST MODIF wtnp116b                      macocco K.MACOCCO          515      6     19
 CASTEST MODIF zzzz121b                      macocco K.MACOCCO          746      1      9
 CASTEST MODIF zzzz121c                      macocco K.MACOCCO          485      2      7
 CASTEST MODIF zzzz121e                      macocco K.MACOCCO          388      2     10
 CASTEST MODIF zzzz175a                      macocco K.MACOCCO          302      1      6
 CASTEST MODIF zzzz257a                      macocco K.MACOCCO          313      1      8
 CASTEST MODIF zzzz257b                      macocco K.MACOCCO          314      1      8
 CASTEST MODIF zzzz257c                      macocco K.MACOCCO          285      1      8
 CASTEST MODIF zzzz257d                      macocco K.MACOCCO          236      2      9
 CASTEST MODIF zzzz266a                      macocco K.MACOCCO           97      4      4
 CASTEST MODIF zzzz266b                      macocco K.MACOCCO          107      4      4
CATALOGU MODIF typelem/gener_mecq32         cheignon E.CHEIGNON         326      4      1
CATALOGU MODIF typelem/gener_medkt2         cheignon E.CHEIGNON         417      4      2
CATALOPY MODIF commande/calc_cham_elem       macocco K.MACOCCO           64      3      5
CATALOPY MODIF commande/calc_champ          sellenet N.SELLENET         240      5     10
CATALOPY MODIF commande/calc_erreur         sellenet N.SELLENET          95      5     10
CATALOPY MODIF commande/defi_contact           abbas M.ABBAS            583     14      5
CATALOPY MODIF commun/c_newton                 abbas M.ABBAS             28      3      3
 FORTRAN AJOUT algorith/iscycl                 abbas M.ABBAS             57     57      0
 FORTRAN AJOUT algorith/mmcyc1                 abbas M.ABBAS            134    134      0
 FORTRAN AJOUT algorith/mmcyc2                 abbas M.ABBAS            147    147      0
 FORTRAN AJOUT algorith/mmcyc3                 abbas M.ABBAS            185    185      0
 FORTRAN AJOUT algorith/mmcyc4                 abbas M.ABBAS            134    134      0
 FORTRAN AJOUT algorith/mmcycd                 abbas M.ABBAS            169    169      0
 FORTRAN AJOUT algorith/mmcycl                 abbas M.ABBAS            134    134      0
 FORTRAN AJOUT algorith/mmcycz                 abbas M.ABBAS            105    105      0
 FORTRAN AJOUT algorith/mmextm                 abbas M.ABBAS             97     97      0
 FORTRAN AJOUT algorith/mmreas                 abbas M.ABBAS            171    171      0
 FORTRAN AJOUT algorith/mmstac                 abbas M.ABBAS             96     96      0
 FORTRAN AJOUT algorith/mmstaf                 abbas M.ABBAS            209    209      0
 FORTRAN AJOUT algorith/mmvalp                 abbas M.ABBAS             97     97      0
 FORTRAN AJOUT elements/fonno8               macocco K.MACOCCO          138    138      0
 FORTRAN MODIF algeline/vtgpld                 abbas M.ABBAS            185    114     86
 FORTRAN MODIF algorith/burcvg               geniaut S.GENIAUT          107      6      6
 FORTRAN MODIF algorith/callam                 abbas M.ABBAS             64      4     39
 FORTRAN MODIF algorith/cfmmve                 abbas M.ABBAS            155      4      3
 FORTRAN MODIF algorith/cfmxme                 abbas M.ABBAS            160     16      6
 FORTRAN MODIF algorith/dladap                 idoux L.IDOUX            608      7      7
 FORTRAN MODIF algorith/dldiff                 idoux L.IDOUX            436      7      7
 FORTRAN MODIF algorith/dlnewi                 idoux L.IDOUX            649      7      7
 FORTRAN MODIF algorith/geomco                 abbas M.ABBAS             83      4      5
 FORTRAN MODIF algorith/impcod                 abbas M.ABBAS             91      3      3
 FORTRAN MODIF algorith/impref                 abbas M.ABBAS            287      8     10
 FORTRAN MODIF algorith/impstd                 abbas M.ABBAS            234     10      3
 FORTRAN MODIF algorith/irrcvg               geniaut S.GENIAUT          109      6      7
 FORTRAN MODIF algorith/isfonc                 abbas M.ABBAS            227     58     51
 FORTRAN MODIF algorith/lcconv               geniaut S.GENIAUT           86     28     44
 FORTRAN MODIF algorith/lcmmcv               geniaut S.GENIAUT          134      3      4
 FORTRAN MODIF algorith/lcplnl               geniaut S.GENIAUT          285     15     21
 FORTRAN MODIF algorith/mcomce                 abbas M.ABBAS            103      2      2
 FORTRAN MODIF algorith/mcopce                 abbas M.ABBAS             51     12     28
 FORTRAN MODIF algorith/mcopco                 abbas M.ABBAS            112     14     17
 FORTRAN MODIF algorith/memokg               macocco K.MACOCCO          242      5      3
 FORTRAN MODIF algorith/mmalgo                 abbas M.ABBAS             87     21     61
 FORTRAN MODIF algorith/mmbclc                 abbas M.ABBAS            105      9      6
 FORTRAN MODIF algorith/mmconv                 abbas M.ABBAS            133     13      3
 FORTRAN MODIF algorith/mmmbca                 abbas M.ABBAS            420    104     91
 FORTRAN MODIF algorith/mmpoin                 abbas M.ABBAS            182      4      4
 FORTRAN MODIF algorith/mreacg                 abbas M.ABBAS             83      4      3
 FORTRAN MODIF algorith/nmctcc                 abbas M.ABBAS            163     14     11
 FORTRAN MODIF algorith/nmctcf                 abbas M.ABBAS            180      3      3
 FORTRAN MODIF algorith/nmctci                 abbas M.ABBAS             91      3      2
 FORTRAN MODIF algorith/nmdepl                 abbas M.ABBAS            255      6      7
 FORTRAN MODIF algorith/nmdifi                 abbas M.ABBAS            107      3      3
 FORTRAN MODIF algorith/nmfonc                 abbas M.ABBAS            794    160     60
 FORTRAN MODIF algorith/nmnewt                 abbas M.ABBAS            386      3      3
 FORTRAN MODIF algorith/nmprde                 abbas M.ABBAS            175      3      3
 FORTRAN MODIF algorith/nmpred                 abbas M.ABBAS            153      3      3
 FORTRAN MODIF algorith/nmprma                 abbas M.ABBAS            262      3      3
 FORTRAN MODIF algorith/nmtble                 abbas M.ABBAS            212     13      9
 FORTRAN MODIF algorith/nmvgme                 abbas M.ABBAS            226      4      4
 FORTRAN MODIF algorith/op0077                 berro H.BERRO            297      3      2
 FORTRAN MODIF algorith/op0154                 abbas M.ABBAS            286      4      3
 FORTRAN MODIF algorith/pminit              foucault A.FOUCAULT         484      3      3
 FORTRAN MODIF algorith/reaclm                 abbas M.ABBAS             64      4    116
 FORTRAN MODIF algorith/velame                 abbas M.ABBAS            159      5      5
 FORTRAN MODIF algorith/vtgplk                 abbas M.ABBAS             27      5    134
 FORTRAN MODIF calculel/ccpoux              sellenet N.SELLENET         340      7     27
 FORTRAN MODIF calculel/meca01               macocco K.MACOCCO          732      8      2
 FORTRAN MODIF calculel/meficg               macocco K.MACOCCO          478      8      9
 FORTRAN MODIF calculel/memoy                macocco K.MACOCCO          215      6      3
 FORTRAN MODIF calculel/mesomm               macocco K.MACOCCO          276      6      4
 FORTRAN MODIF calculel/op0038               macocco K.MACOCCO          179     12     12
 FORTRAN MODIF calculel/peenca               macocco K.MACOCCO          158      9      4
 FORTRAN MODIF calculel/sepach              sellenet N.SELLENET         229     44     38
 FORTRAN MODIF debug/mmimp4                    abbas M.ABBAS            159     48     13
 FORTRAN MODIF elements/dkqsie              cheignon E.CHEIGNON         235     32     11
 FORTRAN MODIF elements/dktsie              cheignon E.CHEIGNON         237     28      6
 FORTRAN MODIF elements/dsqsie              cheignon E.CHEIGNON         279     35     11
 FORTRAN MODIF elements/dstsie              cheignon E.CHEIGNON         264     29      6
 FORTRAN MODIF elements/dxmate              desroche X.DESROCHES        613      3      3
 FORTRAN MODIF elements/fonno6               macocco K.MACOCCO          314     46     22
 FORTRAN MODIF elements/fonno7               macocco K.MACOCCO          133      7      7
 FORTRAN MODIF elements/fonnor               macocco K.MACOCCO          324     28     16
 FORTRAN MODIF elements/gcour2               macocco K.MACOCCO          638      5      5
 FORTRAN MODIF elements/gcouro               macocco K.MACOCCO          424      5      5
 FORTRAN MODIF elements/mmmtfc                 abbas M.ABBAS            160      1      1
 FORTRAN MODIF elements/q4gsie              cheignon E.CHEIGNON         245     33     12
 FORTRAN MODIF elements/te0033              cheignon E.CHEIGNON         326     34      6
 FORTRAN MODIF elements/te0410              cheignon E.CHEIGNON         143     18      2
 FORTRAN MODIF elements/vdxsig              cheignon E.CHEIGNON         297      9      1
 FORTRAN MODIF modelisa/cazocc                 abbas M.ABBAS            326      1      1
 FORTRAN MODIF modelisa/cazocp                 abbas M.ABBAS            308     52     24
 FORTRAN MODIF modelisa/cfmmvd                 abbas M.ABBAS            115      1      1
 FORTRAN MODIF utilitai/ctcrtb              sellenet N.SELLENET         243     42     12
 FORTRAN MODIF utilitai/modopt               macocco K.MACOCCO          172     42     30
 FORTRAN MODIF utilitai/pemain                 abbas M.ABBAS            225      5      5
 FORTRAN SUPPR calculel/mecoac               macocco K.MACOCCO           68      0     68
 FORTRAN SUPPR calculel/te0159              sellenet N.SELLENET          70      0     70
 FORTRAN SUPPR elements/te0394              sellenet N.SELLENET          64      0     64
  PYTHON MODIF Macro/post_bordet_ops         macocco K.MACOCCO          317      2     13
  PYTHON MODIF Macro/post_k1_k2_k3_ops       macocco K.MACOCCO         2093     86    144
  PYTHON MODIF Messages/compor1              geniaut S.GENIAUT          378      2      2
  PYTHON MODIF Messages/contact3               abbas M.ABBAS            230      3      8
  PYTHON MODIF Messages/discretisation         abbas M.ABBAS            112      9      9
  PYTHON MODIF Messages/elements            desroche X.DESROCHES        354      5      3
  PYTHON MODIF Messages/indicateur           macocco K.MACOCCO          150      3      4
  PYTHON MODIF SD/sd_fond_fiss               geniaut S.GENIAUT           39      3      3


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   14        1873      1873             +1873
 MODIF :  195       62522      1810    1967      -157
 SUPPR :    3         202               202      -202
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  212       64597      3683    2169     +1514 
