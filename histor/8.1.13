

-----------------------------------------------------------------------
--- AUTEUR boyere E.BOYERE   DATE  le 06/09/2005 a 17:57:35

-----------------------------------------------------------------------
CORRECTION AL 2005-194
   NB_JOURS_TRAV  : 4.5
   INTERET_UTILISATEUR : NON
   TITRE DYNA_TRAN_EXPLI plante
   FONCTIONNALITE
DYNA_TRAN_EXPLI crashe brutalement dans le calcul de la chute d'une barre sur le sol.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V5.01.102, V5.03.100
       EXPL_ : ajout de modelisations
   VALIDATION
Nouvelles modelisations : sdnd102d et sdnv100f
On n'a pas pu rejouer l'etude de la chute du barreau jusqu'au bout car,
en explicite, elle necessite pour respecter les criteres de stabilite
un pas de temps de l'ordre de 1.E-8 s pour un temps de chute reel de 1 s.
Comme c'est un mouvement de corps rigide,
une solution serait de calculer la chute du bloc considere indeformable
puis l'impact avec un code elements finis.
   DETAILS
Le plantage etait du a l'ecrasement du pointeur de la matrice de masse
dans la routine MXMASS. Le probleme n'apparait pas lorsque le calcul est
conduit sur base modale et il y avait un defaut de couverture de la
validation. J'ajoute deux tests.
-----------------------------------------------------------------------------
CORRECTION AL 2005-248
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE plantage de DYNA_TRAN_EXPLI
   FONCTIONNALITE
corrige par l'AL2005-194.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-----------------------------------------------------------------------------
CORRECTION AL 2005-288
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE plantage de DYNA_TRAN_EXPLI
   FONCTIONNALITE
     corrige par l'AL2005-194.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

-----------------------------------------------------------------------------
REALISATION EL 2004-253
   NB_JOURS_TRAV  : 3.5
AOM pour le projet UTRILLO
   INTERET_UTILISATEUR : NON
   TITRE archivage de calculs avec de tres nombreux pas de temps
   FONCTIONNALITE
DYNA_TRAN_MODAL, par ses algorithmes economes, permet de faire des calculs tres precis en temps.
Habituellement un echantillonage (par archivage)
permet de ne conserver qu'une petite partie des pas de temps calcules.
Mais certains post-traitements (en particulier les chocs et l'usure)
necessitent d'examiner l'integralite du transitoire.
L'archivage est alors deconseille.
La consequence peut en etre des bases gigantesques (plusieurs giga).
L'utilisateur propose une solution : ne pas garder les evolutions modales.
Je ne suis pas tres favorable a ce developpement car les participations
modales ne demandent qu'un stockage relativement modeste en comparaison
des informations sur les chocs.
Quelques regles de trois m'ont convaincu qu'en supprimant
ce qui est l'essentiel de la structure de donnees tran_gene,
en l'occurence les evolutions des participations modales,
on ne gagnerait, dans les exemples presentes par l'utilisateur,
qu'un rapport deux a trois sur la taille de la base.
Or si l'ojectif vise est bel et bien de traiter des bases de
plusieurs dizaines de giga, on est encore loin du compte.
Je propose donc plutot de decouper le calcul
en intervalles ou l'on associe de suite calcul transitoire
et post-traitement dont on detruit aussitot les concepts.
Ainsi on n'a plus a stocker d'encombrantes bases, puisque
le post-traitement se fait dans la foulee.
Le desavantage est de ne pas pouvoir refaire un post-traitement
supplementaire sur un transitoire archive.
Mais le calcul transitoire sur base modale etant par definition peu
couteux, cela me semble moins penalisant que d'archiver d'enormes bases.
La methode est d'ores-et-deja realisable par des boucles en python.
On peut aussi proposer d'automatiser le mecanisme par une macro.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   NON
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR cibhhlv L.VIVAN   DATE  le 05/09/2005 a 16:10:00

--------------------------------------------------------------------------
REALISATION EL 2005-186
   NB_JOURS_TRAV  : 4.5
   POUR_LE_COMPTE_DE   : J.PELLET
   INTERET_UTILISATEUR : NON
   TITRE : AFFE_CHAR_CINE doit accepter plus de ddls
   FONCTIONNALITE
     Maintenant que STAT_NON_LINE accepte des charges cinématiques, il serait
     souhaitable d'étendre les possibilités de cette commande qui ne permet
     actuellement que d'imposer les DDLS :
        drx  dry  drz  dx  dy  dz  grx  phi  pres  temp
     En effet, pourquoi ne pas traiter les ddls des éléments THM, XFM, ...
   DETAIL
     Tout nouveau ddl doit etre declare dans le catalogue de la commande.
     Utilisation de GETMJM qui parametrise le fortran.
     Mise a jour de la liste des DDL issue de AFFE_CHAR_MECA
           'DX','DY','DZ','DRX','DRY','DRZ','GRX','PRES','PHI',
           'TEMP','PRE1','PRE2','UI2','UI3','VI2','VI3','WI2','WI3','UO2',
           'UO3','VO2','VO3','WO2','WO3','UI4','UI5','VI4','VI5','WI4',
           'WI5','UO4','UO5','VO4','VO5','WO4','WO5','UI6','UO6','VI6',
           'VO6','WI6','WO6','WO','WI1','WO1','GONF','DCX','DCY','DCZ',
           'H1X','H1Y','H1Z','E1X','E1Y','E1Z','E2X','E2Y','E2Z',
           'E3X','E3Y','E3Z','E4X','E4Y','E4Z'

   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.44.03
       EXPL_ : STAT_NON_LINE, ajout de nouveaux DDL sous MECA_IMPO
   VALIDATION
     passage des 32 tests validant AFFE_CHAR_CINE
     passage d'une etude a Romeo qui valide le developpement


-----------------------------------------------------------------------
--- AUTEUR d6bhhjp J.P.LEFEBVRE   DATE  le 05/09/2005 a 16:10:43

------------------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE : Introduction d'un nouveau DEFI_FICHIER dans zzzz176a
   FONCTIONNALITE : repertoires de tests multiples dans astk
   DETAILS :
   La commande DEFI_FICHIER permet de récupérer la valeur d'un
   numéro d'unité logique dans une variable python pour la réinjecter
   dans une commande de type IMPR_. Cette possibilité n'était utilisée
   dans aucun fichier de commandes de test.
   On teste le fichier obtenu à l'aide de la commande TEST_FICHIER.
   RESU_FAUX_VERSION_EXPLOITATION    : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   : NON
   RESTITUTION_VERSION_EXPLOITATION  : NON
   RESTITUTION_VERSION_DEVELOPPEMENT : OUI
   IMPACT_DOCUMENTAIRE:  NON
   VALIDATION : zzzz176a	

------------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2005-120
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : NON
   TITRE : LENTEUR DE FIN(format_hdf='oui')
   FONCTIONNALITE
   Comme indiqué dans la réponse préliminaire, le problème est bien lié aux (trop)
   nombreux objets JEVEUX manipulés dans les structures de données résultat associées
   à ce type de calcul : transitoire contenant de nombreux pas de temps. Il n'y a pas
   de solution immédiate sans remettre en cause en profondeur les choix sur les SD
   dans Code_Aster.
   Le profiling montre bien que les routines JEVEUX faisant appel aux fonctions HDF
   sont en cause.
   La copie des bases au format HDF consiste à créer un "sous-fichier" HDF par objet
   JEVEUX, pour travailler sur des données homogènes en type, il y a donc autant de
   sous-fichiers que d'objet Jeveux, d'où des temps importants de mise en oeuvre pour
   effectuer les conversions.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   IMPACT_DOCUMENTAIRE : NON

------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2004-396
   NB_JOURS_TRAV  : 0.1
   INTERET_UTILISATEUR : NON
   TITRE : Pas de recopie de la base en ARRET_CPU
   FONCTIONNALITE
   Je n'ai pas vu pourquoi la base n'avait pas été recopiée lors du passage de JMP,
   en refaisant passer le test hsnv125g tout en limitant le temps CPU, je vérifie
   bien que l'exception est "trappée" et que l'on s'arrete proprement en sauvegardant
   la base (test effectué sur AlphaServer et sous Linux).
   Sous Linux, le diagnostic de l'exécution est ENDED <S>_CPU_LIMIT
   RESU_FAUX_VERSION_EXPLOITATION   : NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   IMPACT_DOCUMENTAIRE : NON


-----------------------------------------------------------------------
--- AUTEUR durand C.DURAND   DATE  le 05/09/2005 a 16:14:14

------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 5
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
     affichages dans fichier message et mesures de temps
   DETAILS
   Plusieurs travaux :

   1/ Affichages des macros dans le fichier de message
      La lecture des fichiers de message peut etre pénible quand elle
      est caviardée par les échos des sous-commandes générées par la
      macro elle-meme. L'utilisateur, la plupart du temps, n'est pas
      intéressé par l'écho de ces sous-commandes. J'introduis donc
      un mot clé simple IMPR_MACRO,into=("OUI","NON"),defaut="NON"
      dans le catalogue de DEBUT et de POURSUITE. Il sera stocké comme un
      attribut du jdc, au mm titre que PAR_LOT. Donc, par défaut, seul
      l'écho des commandes explicitement appellées par l'utilisateur dans
      son jeu de commandes apparaitra. Toutefois, le travail fait pour le
      .code continue à gérer l'arborescence sous les macros dans tous les
      cas.

      Pour ces macros, n'apparaissait pas les mesures de temps, donc pas
      de signal de cloture de la macro. On ne distinguait pas clairement
      la fin des sous-commandes d'une macro des commandes simples qui
      suivaient. Désormais, on a le flag de fin pour tout le monde, y
      compris les include :

    #  FIN COMMANDE : INCLUDE
    #  ------------------------------

       Ainsi, on voit clairement maintenant dans le fichier de message
       le début et la fin d'une macro, encadrant l'écho de ce qu'elle
       produit.

       Pour info, ces messages non désirés dans le fichier mess pouvaient
       mm aller jusqu'à poser des pbs mémoires dans le cas de très (vraiment
       très) nombreux appels à CALC_FONCTION avec de grosses fonctions (liste
       VALE dans le DEFI_FONCTION sous CALC_FONCTION importante, travaux
       S. Cambier monte-carlo)

       J'en profite pour faire pas mal de ménage sur des impressions mal
       faites.

       Pour mémo : l'écho de la commande est produit par la méthode
       set_icmd. Il faut donc faire attention dans les macros commandes
       à bien appeller set_icmd avant toute autre action, en tête de la
       méthode.

   2/ Mesure de temps des commandes
      Jusqu'à présent, on avait conservé le système de mesure de temps de
      l'ancien superviseur, donc en fortran, donc on "oubliait" les macros
      et les tâches python qu'on peut y faire. Avec la généralisation de
      ces macros python, cela devenait gênant. Toutefois, la mesure globale
      CPU pour tout le job était correcte puisqu'un flag était allumé dans DEBUT
      par UTTCPU et fermé dans FIN.
      Désormais, toutes les mesures de temps sont reportées dans le superviseur
      (méthode clock du module time). UTTCPU ne sert plus qu'aux mesures locales
      aux algorithmes (stat_non_line ...).
      Ainsi, le cumul commande par commande en fin de fichier resu est correct:
      les macros apparaissent, pas leurs sous commandes (sinon, double comptabilité).
      Le temps total est identique aux temps individuels cumulés.

   3/ Affichages dans les macros et arrêts fatals
      Suppression de la levée d'erreur dans les macros par self.cr.fatal
      et appel systématique à UTMESS (from Utilitai import Utmess)

   4/ Plus de "print" dans le python
      Pour ne plus avoir de conflit d'écriture sur les unités logiques 6 et 8
      entre python et fortran, il faut systématiquement utiliser la méthode
      affiche du  module aster (aster.affiche) pour imprimer quoique ce soit
      sur les fichiers mess et resu depuis le python.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   VALIDATION : cas tests de la base
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.11.01 commande DEBUT
       EXPL_ : ajout du mcsimp IMPR_MACRO
     DOC_U : U4.11.03 commande POURSUITE
       EXPL_ : ajout du mcsimp IMPR_MACRO
     DOC_D : D5.01.02 introduire une macro-commande
       EXPL_ : recours à UTMESS pour les levées d'exception, aster.affiche
               pour les affichages.
-----------------------------------------------------------------------
CORRECTION AL 2005-314
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE modif mémoire ascou20a
   FONCTIONNALITE test ascou20a
   DETAILS
     on passe de 600Mo à 800Mo
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION ascou20a
------------------------------------------------------------------------------
CORRECTION AL 2005-318
   NB_JOURS_TRAV  : 0.
   INTERET_UTILISATEUR : NON
   TITRE modif mémoire ssla200a
   FONCTIONNALITE test ssla200a
   DETAILS
     on passe de 16 à 32
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION ssla200a


-----------------------------------------------------------------------
--- AUTEUR galenne E.GALENNE   DATE  le 05/09/2005 a 14:01:33

-------------------------------------------------------------------------------
CORRECTION AL 2005-245
   NB_JOURS_TRAV  : 1
   INTERET_UTILISATEUR : OUI
   TITRE : DEFI_FOND_FISS ET POST_K1_K2_K3 / Type de mailles du fond de fissure
   FONCTIONNALITE
   Le type de mailles du fond de fissure (SEG2 ou SEG3) est utilisé dans l'opérateur
   POST_K1_k2_K3 pour déterminer sur quels noeuds le résultat doit être affiché.

   Le type de maille TYPE se trouve dans la structure de données FOND_FISS (depuis 7.2.4)
   et est identifié dans l'opérateur DEFI_FOND_FISS.
   Malheureusement TYPE n'était calculé que si le fond de fissure était défini par
   l'utilisateur par un GROUP_MA et avec un NOEUD_ORIG / GROUP_NO_ORIG. Dans tous les autres
   cas (GROUP_MA sans origine ou GROUP_NO), le calcul plantait dans POST_K1_K2_K3 :
   <F> <POST_K1_K2_K3> BUG: MANQUE .TYPE

   --> on complète la routine gverif

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
      sslv134b : calcul de K à partir de plusieurs définitions du fond de fissure

---------------------------------------------------------------------
REALISATION EL 2004-137
   NB_JOURS_TRAV  : 3
   INTERET_UTILISATEUR : OUI
   TITRE : POST_RCCM / cas test
   FONCTIONNALITE
   Suite aux récentes corrections et évolutions de POST_RCCM, il apparait nécessaire de
   compléter la validation de cet opérateur.

   * Modification cas test rccm01 : on reprend ce cas test analytique simple pour
   disjoindre la validation des types 'TRANSITOIRE' (rccm01a) et 'UNITAIRE' (rccm01b).
   Ce cas test valide le calcul de l'ensemble des options (PM_PB, SN et FATIGUE).

   * Création cas test rccm07 :  étude de la ligne de charge du circuit RCV (étude UTO).
   Ce cas test permet de valider le type 'UNITAIRE' sur une étude industrielle. On ne
   dispose pas ici de solution de référence, mais une étude de l'UTO compare les résultats
   d'ASTER avec ceux des codes ANSYS et SYSTUS : les écarts sur PM sont généralement
   inférieurs à 5%, les écarts sur SN sont inférieurs à 10% et les différents facteurs
   d'usage sont cohérents, ce qui est satisfaisant compte tenu des multiples
   modélisations possibles.
   Dans le cas test, on se contente de postraiter les résultats des calculs thermomécaniques
   réalisés par l'UTO
   rccm07a.comm : calcul de PM/PB pour 4 situations sur les 9 segments d'analyse (test sur
   un segment uniquement)
   rccm07a.com1 : calcul en FATIGUE sur un segment d'analyse et pour deux lois de Wohler
   différentes

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
      DOC_V : V1.01.107  (rccm01)
         EXPL_ : modification des deux modélisations
      DOC_V : V1.04.141  (rccm07)
         EXPL_ : description du cas test
   VALIDATION
   DETAILS
   Fichiers restitués :
   - rccm01a : rccm01a.comm, rccm01a.com0, rccm01a.com1, rccm01a.para, rccm01a.mail
   - rccm01b : rccm01b.comm, rccm01b.com0, rccm01b.com1, rccm01b.para
   - rccm07a : rccm07a.comm, rccm07a.com1 + rccm07a.61 -> rccm07a.82


-----------------------------------------------------------------------
--- AUTEUR godard V.GODARD   DATE  le 05/09/2005 a 16:13:48

-----------------------------------------------------------------------
REALISATION EL 2005-146
   NB_JOURS_TRAV  : 8.
   INTERET_UTILISATEUR : OUI
   TITRE : Nouvelle modélisation pour la liaison grille-crayon des assemblages combustibles
   FONCTIONNALITE
      Jusqu'à présent, la modélisation DIS_CONTACT était utilisée
   sur des éléments discret à 2 noeuds pour modéliser le glissement
   et le possible décollement des crayons par rapport aux grilles.
   Cependant, cette modélisation ne décrit pas bien le comportement
   en rotation de la liaison, particulièrement au niveau de la décharge.
   Pour résoudre ce problème, on introduit une nouvelle modélisation,
   nommée DIS_GRICRA, construite à partir d'une étude analytique simple.

   DETAILS
   La modélisation DIS_GRICRA s'utilise avec des éléments discrets à 2 noeuds,
   avec 6 ddl par noeud (translation+rotation)--> DIS_TR dans AFFE_MODELE
   A partir des ddl globaux, on résout 3 sous-systèmes: 2 bossettes + 1 ressort
   pour lesquels on fait le bilan des forces. On se ramène ensuite au système global
   en exprimant la force global et le moment.
   La loi de comportement sur chaque sous-système est du type plasticité avec écrouissage
   positif dans les directions tangentielles au discret pour modéliser le glissement,
   et du type élastique unilatéral dans la direction du discret pour modéliser le contact.
   La loi fait intervenir 12 variables internes associées au glissement.

   On introduit un nouveau matériau dans DEFI_MATERIAU que l'on nomme DIS_GRICRA
   nécessitant l'introduction de 20 paramètres:
   - 10 pour la liaison (mécanique)
   - 6 pour la dépendance à l'irradiation (facultatifs)
   - 4 pour la dépendance en température (facultatifs)
   !!! les formules de dépendance à l'irradiation et la température
   sont rentrées en dur dans le fortran !!!
   Contrairement aux autres discrets, on ne prend pas en compte les caractéristiques
   de rigidité de AFFE_CARA_ELEM. La matrice de rigidité du discret doit donc
   etre prise nulle dans AFFE_CARA_ELEM. La rigidité est seulement issue des paramètres
   dans DEFI_MATERIAU.
   La matrice tangente est non symétrique, on surcharge donc le catalogue des éléments
   MECA_DIS_TR pour autoriser l'utilisation des MATUNS pour FULL_MECA et RIGI_MECA_TANG
   On introduit 2 cas-test:
   ssnl131 (a,b,c,d): tests simple avec 4 liaisons pour tester seulement la liaison:
                      a : glissement
                      b : rotation
                      c : rotation + irradiation
                      d : rotation + température
   ssnl132 (a,b)    : modélisation complète d'un assemblage (MAC3S2)
                      comparaison avec des résultats expérimentaux.
                      a : essai de compression
                      b : essai de flexion
   L'intéret de ssnl132 est de "fixer" la modélisation des assemblages.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R5.03.17
       EXPL_ : doc des éléments discrets
     DOC_U : U4.51.11
       EXPL_ : comp_incr nouvelle modélisation
             U4.43.01
       EXPL_ : defi_materiau
     DOC_V : V6.02.131
       EXPL_ : Rajout d'une modélisation
     DOC_V : V6.02.132
       EXPL_ : Rajout d'une modélisation
   VALIDATION
      SSNL131A,SSNL131B,SSNL131C,SSNL131D,SSNL132A,SSNL132B
-----------------------------------------------------------------------
CORRECTION AL 2005-307
   NB_JOURS_TRAV : 0.5
   INTERET_UTILISATEUR : NON
   TITRE   Problème dans le calcul de GRAN_IRRA_LOG (1D)
   FONCTIONNALITE
     Il y a a priori une erreur dans la routine nm1vil qui calcule le fluage
     sous irradiation:
     la déformation plastique cumulée est exprimée en fonction de
     la contrainte alors qu'elle devrait etre exprimée en fonction
     de la contrainte équivalente.
     Il y a de plus une possibilité de division par 0 que l'on doit interdire.
   On corrige

   RESU_FAUX_VERSION_EXPLOITATION    :  OUI  DEPUIS : 7.2.1
     EXPL_ : possible erreur engendrée pour visc_irra_log et gran_irra_log
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  OUI  DEPUIS : 8.0.0
     EXPL_ : possible erreur engendrée pour visc_irra_log et gran_irra_log
   RESTITUTION_VERSION_EXPLOITATION  :  OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR joumana J.EL-GHARIB   DATE  le 05/09/2005 a 13:41:26

-------------------------------------------------------------------------------
REALISATION EL 2005-207
   NB_JOURS_TRAV  : 10
   INTERET_UTILISATEUR : OUI
   TITRE EVOLUTION DE L'ARCHITECTURE MICRO_MACRO
   FONCTIONNALITE STAT_NON_LINE - MONOCRISTAL

   Dans le cadre du travail d'optimisation des performances pour Sinergy, on restitue
   les évolutions suivantes :

   -Ajout d'une variable interne : déformation plastique cumulée globale pour le monocristal (avant-dernière
   variable interne du comportement MONOCRISTAL)

   -Une nouvelle alternative d'initialisation du Newton local: Initialisation des variables internes
   des systèmes de glissement plastifiés par une valeur d'essai, déduction de la deformation viscoplastique
   globale en la supposant homogène, déduction de la contrainte

   -Redécoupage local puis global en cas de non convergence en fonction de l'évolution de l'erreur
   sur la norme du résidu

   -Pour donner une orientation du syteme de glissement, avec Zmat il faut donner les angles d'Euler
   alors que dans Aster il faut donner les angles nautiques. Dans le cas test zmat004a, des lignes python
   permettent de transformer les angles d'Euler en angles nautiques et donc l'utilisateur n'a pas à les
   calculer.

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_R : R5.03.11-A
       EXPL_ : Comportements élastoviscoplastiques mono et polycristallins
     DOC_V : V6.04.171-A
       EXPL_ : Comparaison POLY_CFC et MONOCRISTAL
     DOC_V :
       EXPL_ : Comparaison ASTER ZMAT sur le Monocristal en implicite
   VALIDATION
   fichier ajouté :
   ssnv171c  : comparaison monocristal implicite et explicite
   et test de la nouvelle variable interne.
   zmat004a : test conjoint de monocristal et zmat pour un monocristal octaedrique avec une orientation quelconque.
   Passage de tous les tests utilisant DEFI_COMPOR :
     sslv120a
     ssnv171b
     ssnv172a
     sauf le ssnv125a qui plante avec la version officielle.

   DETAILS
   fortran modifié :
    op0059.f  nmvprk.f lcplnl.f lcmmjp.f lcmmon.f lcmmjf.f lcmmji.f lcmmei.f lcmmja.f
    lcmmat.f lcplas.f lcmmvx.f lcmmin.f lcinit.f lccnvx.f plasti.f nmcomp.f redece.f
    lcmmcv.f lcconv.f  lcelas.f lcjela.f lcjplc.f lcmate.f calcme.f nmcpla.f
   fortran ajouté :
    lcdpec.f

-------------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 0.1
   INTERET_UTILISATEUR : OUI
   TITRE CORRECTION DE LA COURBE DE SATURATION
   FONCTIONNALITE DEFI_MATERIAU
   On s'est aperçu lors de la rédaction des docs de cas test wtnv123 et wtnv126 que la courbe de saturation
   n'est pas compatible avec les données. Elle n'impacte pas les résultats, mais pour des soucis de
   cohérence entre les données on la modifie ainsi que la valeur de DEGR_SATU sous THM_INIT.
   cas test modifiés :
    wtnv123a wtnv123b wtnv123c wtnv126a wtnv126b

   RESU_FAUX_VERSION_EXPLOITATION    :  NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :  NON
   RESTITUTION_VERSION_EXPLOITATION  :  NON
   RESTITUTION_VERSION_DEVELOPPEMENT :  OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION


-----------------------------------------------------------------------
--- AUTEUR lebouvie F.LEBOUVIER   DATE  le 05/09/2005 a 14:17:27

------------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 8.
   POUR_LE_COMPTE_DE : E. GALENNE
   Cette restitution partielle effectuée dans le cadre de la fiche EL2004-212
   INTERET_UTILISATEUR : OUI
   TITRE : MACR_ASCOUF_MAIL / Extension du domaine Rm/e
   FONCTIONNALITE : MACR_ASCOUF_MAIL
   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U4.CF.10
       EXPL_ : Macro commande MACR_ASCOU_MAIL
     DOC_V : V1.01.211
       EXPL_ : Description du cas-test ascou22a
   VALIDATION
       cas-test ascou22a
   DETAILS :
   Objectifs
   ---------
   La macro-commande MACR_ASCOUF_MAIL est aujourd'hui largement utilisée par les
   différentes unités d'EDF pour mailler rapidement des tubes/coudes fissurés
   ou présentant une ou plusieurs sous-épaisseurs. La gamme de géométrie autorisée
   est aujourd'hui limitée à des valeurs de Rayon moyen/Epaisseur comprises entre
   5 et 12. Ce qui correspond à la majorité des géométries rencontrées dans le
   CPP et le CSP des REP.

   L'objectif de cette évolution est d'étendre cette gamme jusqu'à une valeur
   de Rm/e de 50 afin de pouvoir utiliser cette macro-commande pour du matériel
   de l'îlot conventionnel.

   Modifications
   -------------
   Les travaux effectués dans le cadre de cette restitution partielle concernent
   l'extension du domaine de validité dans le cas ou le défaut est de type
   sous-épaisseurs multiples. La principale modification effectuée dans la
   procédure ascouf_ssep_mult_v1.datg concerne le raffinement du maillage dans
   les embouts afin que la qualité (étirement et distorsion) des mailles dans ces zones
   soit satisfaisantes. Le problème vient principalement de la longueur des embouts
   qui doit respecter une longueur minimum :
   L > 3/2(Rm**3/e)**0.5 ce qui conduit a des longueurs de :
     - Rm/e=21 => L= 921.mm
     - Rm/e=35 => L=2014.mm
     - Rm/e=47 => L=3114.mm

   Remarques:
   ----------
   Ces remarques font suite aux tests effectués.
   - Les caractéristiques géométriques des deux sous-épaisseurs, combinés avec
     les dimensions géométriques du coude (Rm/e=21,35 et 47) nécessite un maillage
     fin et de plus en plus fin lorsque Rm/e augmente.
   - Rm/e =21: le maillage de ce coude a été obtenu sans trop de difficulté.
     108843 Noeuds,37060 Mailles.
   - Rm/e=35 et 47 : le maillage de ces coudes est plus difficile a obtenir voir
     impossible (CPU important, mémoire GIBI) si on veut avoir un maillage
     satisfaisant partout. Pour les tests effectués :
       .Rm/e =35 il faut prévoir 80 mailles dans le sens circonférentielle
       .Rm/e =47 il faut prévoir 140 mailles dans le sens circonférentielle
     Le maillage correct n'a pu être obtenu. Un maillage plus grossier, de qualité
     inférieur a été obtenu. En conséquence, pour les Rm/e > 21, une alarme a été
     mise dans la procédure GIBI pour informer l'utilisateur d'un problème de maillage
     potentiel (maillage impossible à obtenir, qualité du maillage,...)
   - Les modifications apportées n'ont pas d'impact sur les coudes dont le
     rapport Rm/e < 12.

   Validation
   ----------
   Pour mettre au point de la procédure GIBI "ascouf_ssep_mult_v1.datg" trois tests,
   avec des rapports Rm/e = 21,35 et 47, basés sur le cas-test de référence
   suivant ont été créés :

    - ascou14 : Coude avec épaisseurs multiples, calcul élastique linéaire

   Les vérifications suivantes ont été effectuées :
    - Maillage: analyse avec IDEAS de la qualité des mailles volumiques
                (Distorsion, étirement, bords libres)
    - Résultat : analyse des déplacements et des contraintes

   Le cas-test restitué est le suivant:
     - ascou22a (basé sur le cas-test ascou14a) Rm/e = 21,

------------------------------------------------------------------------------
REALISATION EL 2005-196
   NB_JOURS_TRAV  : 1.0
   POUR_LE_COMPTE_DE : F. VOLDOIRE
   INTERET_UTILISATEUR : OUI
   TITRE : Test sdll108 (table de Neubert)
   FONCTIONNALITE :
   DETAILS :
   Cas-test sdll108:
     - Mise à jour des valeurs de référence et on site la référence dans
       la modélisation.
   Doc V
     - Mise à jour de la doc V à partir de la doc V issu de a validation
       indépendante.
   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_V : V2.02.108
       EXPL_: Mise à jour du cas-test
   VALIDATION : cas-test restitué sdll108b


-----------------------------------------------------------------------
--- AUTEUR rezette C.REZETTE   DATE  le 05/09/2005 a 14:11:38

------------------------------------------------------------------------------
REALISATION EL 2005-188
   POUR_LE_COMPTE_DE : G. NICOLAS
   INTERET_UTILISATEUR : OUI
   TITRE : IMPR_RESU
   FONCTIONNALITE Permettre la sélection d'entités topologiques
   RESU_FAUX_VERSION_EXPLOITATION  :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
     DOC_U : U7.05.21 ( Procédure IMPR_RESU (FORMAT MED) )
       EXPL_ : Ajout des mots clés NOEUD, MAILLE, GROUP_NO, GROUP_MA
   VALIDATION : zzzz162a zzzz161a
   NB_JOURS_TRAV  : 1.5
   DETAILS :
   1.Objectif
      Valider les mots clés NOEUD, MAILLE, GROUP_NO, GROUP_MA de l'opérateur
      IMPR_RESU au format MED.
   2. Syntaxe
      IMPR_RESU ( o UNITE  = unit,
                  o FORMAT = 'MED',
                  o RESU   =  _F (
                              o     /  MAILLAGE = ma,
                                    /  RESULTAT = resu,
                              f     NOM_CHAM    = l_nomsymb,
                              f     |  MAILLE   = l_ma,
                              f     |  NOEUD    = l_no,
                              f     |  GROUP_NO = l_gno,
                              f     |  GROUP_MA = l_gma
                              f     ...)
                              ...)
   3. Réalisation

     3.1 Méthode de validation

      La méthode de validation retenue est la suivante:
      * Définition d'un fichier --> DEFI_FICHIER(UNITE=81)
      * Impression au format MED d'un champ sur une partie du maillage:
        IMPR_RESU(FORMAT='MED', UNITE=81,
	          RESU=_F(RESULTAT= ..,NOM_CHAM=.., GROUP_NO= ..))
        A ce stade, on exécute xmdump sur le fichier d'unité logique 81
        pour vérifier que la restriction a bien été prise en compte.
      * Création d'un concept résultat à partir du fichier MED précédent.
         RESU2=LIRE_RESU(UNITE=81,FORMAT='MED',...)
      * On concoit un fichier qui servira de fichier de validation:
          DEFI_FICHIER(UNITE=82)
	Impression du concept RESU2 au format GMSH dans ce fichier
          IMPR_RESU(FORMAT=GMSH,RESU=_F(RESULTAT=RESU2),)
        On teste le fichier pour la non-regression du code:
	  TEST_FICHIER(FICHIER='./fort.82', ...)

     3.2 Champs testés:
        Les 4 mots clés NOEUD,MAILLE,GROUP_XX ont été testés sur les champs :
	    DEPL           (EVOL_ELAS, EVOL_NOLI)
            EPSI_ELNO_DEPL (EVOL_ELAS)
	    SIEF_ELNO_ELGA (EVOL_NOLI)
            VARI_ELNO_ELGA (EVOL_NOLI)
            TEMP           (EVOL_THER)

   Cas-tests modifiées  : zzzz162a zzzz161a
   Catalogue modifié    : impr_resu.capy


-----------------------------------------------------------------------
--- AUTEUR romeo R.FERNANDES   DATE  le 06/09/2005 a 10:17:46

------------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2005-167
   NB_JOURS_TRAV  : 0.1
   INTERET_UTILISATEUR : NON
   TITRE : Plantage des cas-tests wtnv102a et wtnv102b sous linux
   FONCTIONNALITE
     Cas-test 3D_THH
   DETAILS
   Le plantage etait du a une condition non respectee dans la routine ASSERT
   de verification des dimensions.
   Le plantage ne se produit plus depuis la version 8.1.10 suite a
   l'evolution sur la resolution des systemes couples THM. Comme cette
   evolution a impactee de facon consequente les differents dimensionnement
   et comme les cas-tests sont OK sur les differentes plate-formes on propose
   de classer cette anomalie SANS_SUITE.

   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   IMPACT_DOCUMENTAIRE : NON

------------------------------------------------------------------------------------
CLASSEMENT SANS SUITE AL 2005-185
   NB_JOURS_TRAV  : 0.1
   INTERET_UTILISATEUR : NON
   TITRE : Plantage des cas-tests wtnp102a et wtnp102b sous linux
   FONCTIONNALITE
     Cas-test D_PLAN_THH
   DETAILS
     IDEM AL 2005-167.
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   IMPACT_DOCUMENTAIRE : NON


-----------------------------------------------------------------------
--- AUTEUR torkhani M.TORKHANI   DATE  le 06/09/2005 a 12:34:27

------------------------------------------------------------------------------------
REALISATION EL 2005-082
   NB_JOURS_TRAV  : 15.
   INTERET_UTILISATEUR : NON
   TITRE INTRODUIRE LA COMPLIANCE DANS LE TRAITEMENT DU CONTACT
         (METHODE CONTINUE)
   FONCTIONNALITE
     Il s'’agit d'’introduire un nouveau modele d'’interface de contact prenant en compte
     Les aspects microscopiques (aspect compliant des asperites) et macroscopiques
     (comportant de signorini des surfaces moyennes de contact).
   DETAILS
    1) Nouveau mot-cle facultatif COMPLIANCE dans l'operateur   AFFE_CHAR_MECA
       sous le bloc relatif a la methode continue permettant de prendre en compte (ou non) la
       presence d'un modele micro-macro pour l'interface de contact. Ceci permet de prendre en
       compte la rugosite des surfaces de contact a l'echelle microscopique.
       Ce modele permet aussi d'adoucir les conditions de non interpenetration de Signorini
       (modele robuste idealise moyennant les surfaces de contact). Ceci presente un interet
       pour le contact dun corps rigide par exemple sur un massif (problemes numeriques).
       En dynamique, l'apport de ce modele consiste en la possibilite d'introduire une densite de
       percussion amortissante qui tient compte du choc par le controle du saut des vitesses
       normales au moment de l'impact (dissipation de l'energie de choc).
    2) Modifications des structures de donnees contact
       Les tableaux DEFICO(1:16) // '.CARACF' et DEFICO(1:16) // '.TABFIN') ont ete utilisees
       pour le stockage des statuts de caracteristiques de la methode de compliance (taille de
       l'asperite, coefficients de penalisation et puissances des lois polynomiales de compliance)
       et du statut de contact intermediaire SL relatif a la position par rapport aux asperites.
    3) Routines modifiees
       La routine CAZOCC.f permet la lecture des principales caracteristiques du contact et le
       remplissage de la SD 'DEFICO' pour la methode continue.
       Des variables intermediaires de type REEL et INTEGER permettent donc de recuperer, par
       zone de contact, les valeurs des parametres de la compliance.
       La routine MMMBCA.f permettant l'actualisation des statuts de contact globaux de Signorini
       permet, dans le cadre du modele d'interface compliant, d'actualiser les statuts de contact locaux
       (position par rapport aux asperites) et globaux (position par rapport a la surface moyenne de
       contact).
       Dans les routines elementaires TE0364.f et TE0365.f, les contributions da la partie compliante
       du modele d'interface aux termes elementaires de contact ont ete ecrites selon une loi
       polynomiale de compliance.
       Pour les autres routines, il sagit dune simple repercussion des extensions des tableaux
       TABFIN et CARACF.
       Il s'en suit des modifications aussi dans les catalogues gener_cmcfz1.cata, gener_cmcfz2.cata,
       rigi_cont.cata, rigi_frot.cata, char_meca_cont.cata et char_meca_frot.cata pour l'extension
       de la carte de contact.
    4) Cas-test: Ajout dune nouvelle version sdnv100d du cas-test sdnv100 avec presence de compliance.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : OUI
   DOC_U : U4.44.01
       EXPL_ : Ajout de mot-cles COMPLIANCE  = '‘OUI'’ ou ‘'NON’ 'dans
                      AFFE_CHAR_MECA/CONTACT/METHODE='CONTINUE' :

       CONTACT = _F(…METHODE = ‘CONTINUE’,

             -  COMPLIANCE            = / ‘OUI’
                                        /’NON’                       [DEFAUT]
                        *        ASPERITE        =   dn0           [R]
                        *        E_N             =   EN            [R]
                        -        E_V             =  /CN            [R]
                                                    /0.            [DEFAUT]

A la condition COMPLIANCE = ‘'OUI'’, on doit renseigner les parametres de la compliance.
selon la loi polynomiale de compliance de la forme :

      Pn =  - EN * SL * (jeu + dn0)mnen – CN * SL * (jeu + dn0)mncn * [[Vn]]

Ici, les valeurs de mnen et mncn ont ete fixees a 2 et 1 respectivement.

   DOC_V : V5.03.100A
       EXPL_ : AJOUT de cas_test SDNV100D : Impact d’'une poutre sur une paroi rigide
   DOC_D : D6.04.14-D
       EXPL_ : Utilisation du tableau TABFIN et CARACF pour le stockage des caracteristiques
                      de la compliance.
   DOC_R : R5.03.52
       EXPL_ : Theorie du modele multi-niveau dans le cadre de la methode continue.

   VALIDATION
     SDNV100D





-----------------------------------------------------------------------
--- AUTEUR vabhhts J.PELLET   DATE  le 05/09/2005 a 18:58:00

------------------------------------------------------------------------------
CORRECTION AL 2005-269
   NB_JOURS_TRAV : 0
   INTERET_UTILISATEUR : NON
   TITRE "ssls129a plante en 8.1.8 sous linux Rocks"

   FONCTIONNALITE
   Il s'agit du même problème que AL 2005-270

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION  : passage du test sur Rocks et clayastr avec la bonne région mémoire.
   DETAILS
    Liste des fichiers modifiés:
     jerecu.f

------------------------------------------------------------------------------
CORRECTION AL 2005-270
   NB_JOURS_TRAV : 4 (JP:3, JPL:1)
   INTERET_UTILISATEUR : NON
   TITRE "rccm05a plante en 8.1.8 sous linux Rocks"

   FONCTIONNALITE
   La restitution 8.1.8 comportait une évolution consistant à récupérer
   les enregistrements vides sur la base Volatile.
   Pour cela, on a introduit dans un certain nombre de subroutines (op0070, ...)
   des appels à une nouvelle routine JERECU qui détermine les enregistrements
   "libérables".
   Une petite erreur s'était glissée dans la routine JERECU ayant pour conséquence
   d'écraser (parfois) le contenu de certains objets. Le code s'arrétait alors
   avec des messages variés. Par exemple :
      - "MATRICE NON FACTORISABLE ..."
      - "LONGUEUR DE SEGMENT INVALIDE ..."
   Jean-Pierre a corrigé cette routine en ajoutant une petite ligne bien "sentie" :
      109a110
      >            IITECR(IC) = 0

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : passage du cas test sur Rocks avec la bonne région mémoire
   DETAILS
     Liste des fichiers modifiés:
       jerecu.f

------------------------------------------------------------------------------
CORRECTION AL 2005-278
   NB_JOURS_TRAV : 0.3 (JP:0.1, MA:0.2 ?)
   INTERET_UTILISATEUR : NON

   TITRE "test ssnv129c plante sous Linux en 8.1.9"

   FONCTIONNALITE
   Il s'agit encore du bug JERECU ! (voir AL 2005-270)

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : passage du test sur alphaserver avec la bonne région mémoire (256Mo)
   DETAILS
     Liste des fichiers modifiés:
       jerecu.f

------------------------------------------------------------------------------
CORRECTION AL 2005-283
   NB_JOURS_TRAV : 0.5 (JP:0.2, EG:0.3 ?)
   INTERET_UTILISATEUR : NON
   TITRE "test ssnv166b plante sous Linux en 8.1.9"
   FONCTIONNALITE
   Il s'agit encore du bug JERECU ! (voir AL 2005-270)

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION : passage du test sur Rocks avec la bonne région mémoire (1000Mo)
   DETAILS
     Liste des fichiers modifiés:
       jerecu.f

------------------------------------------------------------------------------
CORRECTION AL 2005-304
   NB_JOURS_TRAV : 0.4
   INTERET_UTILISATEUR : OUI
   TITRE "Test sdnx300b beaucoup plus lent en version 8.1.8"
   FONCTIONNALITE
   Suite à l'introduction de l'appel à JERECU dans la commande
   RECU_FONCTION, le temps CPU de cette commande s'est beaucoup
   dégradé.
   Pour revenir à des temps raisonnables, je ne fais plus appel à JERECU dans RECU_FONCTION.
   (routines focrrO.f et focrr2.f) car cette commande doit rester rapide.
   J'ai regardé rapidement ces 2 routines et je ne crois pas qu'elles créent de petits objets
   sur la base Volatile dans la boucle sur les numéros d'ordre.
   L'usage de JERECU est donc inutile.
   Cette correction permet de diviser par 100 le temps CPU des premiers RECU_FONCTION
   du test sdnx300b (voir DETAILS ci-dessous).
   On déduit de ces mesures que le cout CPU d'un JERECU (pour ce test) est d'environ 5.e-3s
   ce qui n'est pas négligeable.
   Je remets à 120s le temps CPU de ce test.

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   OUI
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION

   DETAILS
   Mesures CPU faites sur clpaster (Linux/Rocks)

                            AVANT        AVANT        AVANT       |      APRES        APRES        APRES
                            USER         SYST         TOTAL       |      USER         SYST         TOTAL
 * RECU_FONCTION    :       0.22 :       4.50 :       4.72 *      |      0.04 :       0.00 :       0.04 *
 * RECU_FONCTION    :       0.23 :       4.63 :       4.86 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.23 :       4.69 :       4.92 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.18 :       4.55 :       4.73 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.15 :       4.70 :       4.85 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.18 :       3.36 :       3.54 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.16 :       3.27 :       3.43 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.24 :       3.51 :       3.75 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.19 :       3.17 :       3.36 *      |      0.04 :       0.00 :       0.04 *
 * RECU_FONCTION    :       0.24 :       3.21 :       3.45 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.25 :       3.22 :       3.47 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.20 :       3.20 :       3.40 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.14 :       3.11 :       3.25 *      |      0.04 :       0.00 :       0.04 *
 * RECU_FONCTION    :       0.28 :       3.11 :       3.39 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.30 :       3.16 :       3.46 *      |      0.05 :       0.00 :       0.05 *
 * RECU_FONCTION    :       0.42 :       4.44 :       4.86 *      |      0.11 :       0.00 :       0.11 *
 * RECU_FONCTION    :       0.21 :       4.74 :       4.95 *      |      0.11 :       0.00 :       0.11 *
 * RECU_FONCTION    :       0.29 :       4.52 :       4.81 *      |      0.11 :       0.00 :       0.11 *
 * RECU_FONCTION    :       0.26 :       4.74 :       5.00 *      |      0.11 :       0.00 :       0.11 *
 * RECU_FONCTION    :       0.21 :       4.66 :       4.87 *      |      0.11 :       0.00 :       0.11 *
 * RECU_FONCTION    :       0.27 :       4.68 :       4.95 *      |      0.11 :       0.00 :       0.11 *

   Liste des fichiers modifiés:
  focrr0.f  focrr2.f
  sdnx300b.comm

------------------------------------------------------------------------------
RESTITUTION HORS AREX   (H2)
   NB_JOURS_TRAV : 0.3
   INTERET_UTILISATEUR : NON
   FONCTIONNALITE
   RESU_FAUX_VERSION_EXPLOITATION   :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   IMPACT_DOCUMENTAIRE : NON
   VALIDATION
   DETAILS

   1) on supprime les 3 elrefe introduits pour les éléments XFEM :
         X20, X10 et X15.
      Il suffit d'employer à la place :
         HE8, TE4 et PE6

   Liste des fichiers modifiés:
   elraca.f  elraga.f  elrfdf.f  elrfvf.f  nuelrf.f
   gener_me_x.cata     gener_me_xh.cata    type_maille__.cata

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///////  RESTITUTION POUR SAMUEL GENIAUT                  //////////////////////
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

REALISATION EL 2005-033
  NB_JOURS_TRAV  : 20.
  INTERET_UTILISATEUR : OUI
  TITRE           X-FEM et enrichissement en fond de fissure
  FONCTIONNALITE  Afin de traiter un problème avec une fissure dans le
  cadre de la méthode X-FEM, il est nécessaire d'enrichir la base des
  fonctions de forme dans une zone proche du fond de fissure. Cet
  enrichissement nécessite l'introduction de 4 fonctions singulières.
  RESU_FAUX_VERSION_EXPLOITATION    :   NON
  RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
  RESTITUTION_VERSION_EXPLOITATION  :   NON
  RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
  VALIDATION
   ssnv185b, ssnv185c, ssnv185d, ssnv185e

DETAILS
   Cette fiche est la suite de l'EL 2004-149 qui avait introduit
   l'enrichissement Heaviside.

   On introduit de nouveaux ddls enrichis.
   Le déplacement discrétisé a alors pour expression :

	u(x)= ai.Ni(x) + bi.Ni(x).H(x) + c1i.Ni(x).F1(x) + c2i.Ni(x).F2(x)
                                  + c2i.Ni(x).F3(x) + c3i.Ni(x).F3(x)
   où ai sont les ddls classiques
      Ni sont les fonctions de forme classiques
      bi sont les ddls enrichis Heaviside
      H est la fonction Heaviside généralisée
      c1i, c2i, c3i et c4i sont les nouveaux ddls enrichis
      F1, F2, F3 et F4 sont les 4 fonctions singulières
      F1=sqrt(r)sin(theta/2)
      F2=sqrt(r)cos(theta/2)
      F3=sqrt(r)sin(theta/2)sin(theta)
      F4=sqrt(r)cos(theta/2)sin(theta)
      r et theta étant les coordonnées polaires dans la base locale au
      fond de fissure.

   Dans Aster, les nouveaux ddls enrichis introduits sont les suivants
   E1X, E1Y, E1Z, E2X, E2Y, E2Z, E3X, E3Y, E3Z, E4X, E4Y, E4Z.


    1) Où et quoi enrichir ?
    -----------------------

	   1.a) L'enchissement des noeuds

    Les noeuds '0' sont des noeuds classiques.
    Les noeuds '1' sont des noeuds Heaviside.
    Les noeuds '2' sont des noeuds Crack-Tip.
    Les noeuds '3' sont des noeuds Heaviside et Crack-Tip.

    exemple 1 :


    0------------0------------0------------0------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    1------------1------------2------------2------------0
    |            |            |            |            |
    |            |            |            |            |
  ###################################      |            |
    |            |            |            |            |
    |            |            |            |            |
    1------------1------------2------------2------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    0------------0------------0------------0------------0
	


     exemple 2 :


    0------------0------------2------------2------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
  ##1############1############2######------2------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    0------------0------------2------------2------------0


     exemple 3 :


    0------------2------------2------------2------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
  ##1############3############2------------2------------0
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    |            |            |            |            |
    0------------2------------2------------2------------0


    Ces noeuds sont déterminés grace aux valeurs des level sets sur les
    noeuds supports associés (opération déjà effectuée par DEFI_FISS_XFEM).

    	1.b) L'enrichissement des mailles

    Cette étape est nécessaire pour la création de nouveaux éléments finis
    ayant des ddls enrichis.
    On caractérise l'état de la maille suivant l'état de ses noeuds :
    Si une maille possède au moins un noeud Heaviside -> maille Heaviside
    Si une maille possède au moins un noeud Crack-Tip -> maille Crack-Tip
    Si une maille possède au moins un noeud Heaviside et au moins un noeud
    Crack-Tip, ou si la maille possède au moins un noeud Heaviside-Crack-Tip
                                                      -> maille Heaviside-Crack-Tip

    Introduction de 2 nouveaux types d'éléments finis :
    éléments enrichi Crack-Tip (gener_me_xt)
    éléments enrichi Heaviside et Crack-Tip (gener_me_xht)

       1.c) Supprimer les ddls enrichis "en trop"

     De meme que pour les ddls Heaviside, on supprime les ddls enrichis à tort
     par un passage dans AFFE_CHAR_MECA avec le mot-clé LIAISON_XFEM='OUI'.
     (cf EL 2004-149)


    2) Intégration et quantités élémentaires
    ----------------------------------------

   De meme que pour les éléments Heaviside, ces nouveaux éléments présentent
   un champ de déplacement discontinu au travers de la fissure. Il convient
   d'adopter la meme méthode d'intégration par sous-découpage des éléments
   (cf EL 2004-149).


    3) Conditions aux limites
    -------------------------

   Pour introduire des conditions aux limites sur un ddl enrichi, il faut créer
   les catalogues correspondant : d_depl_r_e1x, d_depl_r_e1y,...

   Ceci est uniquement utile dans les cas académiques où on souhaiterait bloquer un
   ddl enrichi. Dans la partique, cela n'arrive pas les ddls enrichis sont portés
   par des noeuds proches de la fissure.

   Cependant, certains cas test peuvent utiliser cette fonctionnalité.
   Mais on notera que l'utilisateur doit etre bien conscient du sens physique des
   conditions imposées !


    4) Contact
    ----------

    Le contact est pris en compte par la méthode continue, sur les éléments de type
    Heaviside-Crack-Tip, mais pas sur les éléments de type Crack-Tip.



    catalogues :  d_depl_r_e1x.cata  d_depl_r_e1y.cata  d_depl_r_e1z.cata
                  d_depl_r_e2x.cata  d_depl_r_e2y.cata  d_depl_r_e2z.cata
                  d_depl_r_e3x.cata  d_depl_r_e3y.cata  d_depl_r_e3z.cata
                  d_depl_r_e4x.cata  d_depl_r_e4y.cata  d_depl_r_e4z.cata
                  gener_me_xht.cata  gener_me_xt.cata
                  forc_noda.cata     grandeur_simple__.cata
                  affe_char_meca.capy


    fortan
    routines de contact             : te0532.f te0533.f te0534.f te0548.f
                                      xplmat.f xmmbca.f
    routines de calcul rigidité     : te0539.f xmel3d.f xkel3d.f
                                      reeref.f xcalfe.f xdel3d.f xjacff.f
    routines de calcul force nodale : vefnme.f te0542.f xbsigm.f xxbsig.f
    routines utilitaires            : xdeldl.f xdelco.f

    fortran supprimé (reorganisation des te0539 et te542) : xxel3d.f xibsig.f

IMPACT_DOCUMENTAIRE : OUI
    DOC_D : D4.10.02 SD FISS_XFEM
       EXPL_ :
    DOC_R : R7.02.12 Méthode X-FEM
       EXPL_ :    enrichissement avec les fonctions singulières
    DOC_V : V6.04.185 Fissure débouchante dans une plaque 3D de largeur
                      finie avec X-FEM
       EXPL_ :

--------------------------------------------------------------------------
REALISATION EL 2005-216
  NB_JOURS_TRAV  : 0.5
  INTERET_UTILISATEUR : OUI
  TITRE           CALC_G_LOCAL_T, option CALC_K_G_F en 3D
  FONCTIONNALITE  Permettre l'utilisation de l'option CALC_K_G_F en 3D
  RESU_FAUX_VERSION_EXPLOITATION    :   NON
  RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
  RESTITUTION_VERSION_EXPLOITATION  :   NON
  RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
  VALIDATION
   ssnv185a
  DETAILS
   Cadre : calcul des SIFs par l'opérateur CALC_G_LOCAL_T.
   En présence d'une charge issue d'AFFE_CHAR_MECA_F, l'option CALC_K_G devient
   CALC_K_G_F. Ceci n'etait valable que pour les éléments 2D.
   Pour l'étendre au 3D, il a suffit de modifier le catalogues de l'option
   CALC_K_G_F (calc_k_g_f.cata) ainsi que celui des éléments 3D (gener_me_3d_3.cata).
   Puis dans le fortran (te0295.f) récupérer les champs d'entrée adequat.

   Attention :
   -----------
   Ce nouveau cas test (ssnv185a) emet une ALARME légitime
   (présence de mailles doubles) car il s'agit des 2 lèvres de la fissure
   maillée qui sont superposées !!

  IMPACT_DOCUMENTAIRE : OUI
    DOC_U : U4.82.04 CALC_G_LOCAL_T
       EXPL_ : option CALC_K_G_F possible pour les éléments 3D
    DOC_V : V6.04.185 Fissure débouchante dans une plaque 3D de largeur
                      finie avec X-FEM
       EXPL_ :

--------------------------------------------------------------------------
REALISATION EL 2005-217
  NB_JOURS_TRAV  : 2.
  INTERET_UTILISATEUR : OUI
  TITRE           CALC_G_LOCAL_T option CALC_K_G(_F) pour les éléments X-FEM
  FONCTIONNALITE  Permettre le post-traitement des facteurs d'intensité de contraintes
                par la méthode "G-theta" pour les éléménts X-FEM.
RESU_FAUX_VERSION_EXPLOITATION   :   NON
RESU_FAUX_VERSION_DEVELOPPEMENT  :   NON
RESTITUTION_VERSION_EXPLOITATION  :  NON
RESTITUTION_VERSION_DEVELOPPEMENT :  OUI

VALIDATION
   ssnv185b, ssnv185c, ssnv185d, ssnv185e
DETAILS
   Calcul des SIFs par l'opérateur CALC_G_LOCAL_T, option CALC_K_G ou CALC_K_G_F
   Il faut un post-traitement spécial pour les éléments X-FEM car le champ de
   déplacement n'est pas donné de maniere simple (il fait intervenir des ddls enrichis).
   Un nouveau te (similaire au te0295) est donc créé pour traiter les éléments X-FEM.
   Pour chague sous-élément, on proécède de la meme façon que dans le te0295.
   La seule différence est au niveau du calcul du gradient du champ de déplaement
   solution, qui nécessite dans ce cas de prendre en compte les termes dus aux ddls
   enrichis.

ajout fortran : te0297.f  xsif3d.f  chauxi.f
modif fortran : op0077.f

modif cata : calc_k_g_f.cata  calc_k_g.cata  gener_me_x.cata

IMPACT_DOCUMENTAIRE : OUI
    DOC_R : R7.02.12 Méthode X-FEM
       EXPL_ :
    DOC_U : U4.82.04 CALC_G_LOCAL_T
       EXPL_ : option CALC_K_G_F possible pour les éléments X-FEM
    DOC_V : V6.04.185 Fissure débouchante dans une plaque 3D de largeur
                      finie avec X-FEM
       EXPL_ :


--------------------------------------------------------------------------
CORRECTION AL 2005-170
  NB_JOURS_TRAV  : 0.5
  INTERET_UTILISATEUR : OUI
  TITRE           ssnv182b et X-FEM
  FONCTIONNALITE
    le cas test plantait sous clpaster
  DETAILS
    En mettant 600s au lieu de 400s dans le .para, le cas test passe.
  RESU_FAUX_VERSION_EXPLOITATION    :   NON
  RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
  RESTITUTION_VERSION_EXPLOITATION  :   NON
  RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
  IMPACT_DOCUMENTAIRE : NON
  VALIDATION
   SSNV182b

------------------------------------------------------------------------
RESTITUTION HORS AREX
   NB_JOURS_TRAV  : 0.5
   INTERET_UTILISATEUR : OUI
   FONCTIONNALITE
     Remplacer le schéma d'intégration numérique par défaut
     pour le contact méthode continue avec X-FEM
   DETAILS
   La famille par défaut était une famille d'intégration aux noeuds.
   Ce schéma n'est pas assez riche. Il est remplacé par une famille
   à 4 points pour l'intégration sur les facettes triangulaires (TRIA3)
   des termes de contact avec la méthode continue et X-FEM.
   En effet, le schéma doit permettre l'intégration exacte d'un champ
   de pression constant. L'intégrande sur la facette est alors un
   monome en xi.yj avec i+j < 4. Un schéma à 4 points de Gauss suffit.
   Le cas test ssnv182c.comm utilisait un schéma aux noeuds. Certaines
   pressions de contact étaient fausses, mais n'étaient pas testées.
   Maintenant, il utilise le schéma à 4 points et toutes les pressions
   sont testées.
   fichiers modifiés : defi_fiss_xfem.capy
                       ssnv182c.comm

   RESU_FAUX_VERSION_EXPLOITATION    :   NON
   RESU_FAUX_VERSION_DEVELOPPEMENT   :   NON
   RESTITUTION_VERSION_EXPLOITATION  :   NON
   RESTITUTION_VERSION_DEVELOPPEMENT :   OUI
   VALIDATION : SSNV182C
   IMPACT_DOCUMENTAIRE : OUI
    DOC_V : V6.04.182 Bloc avec interface en contact frottant avec X-FEM
       EXPL_ :
    DOC_R : R7.02.12 Méthode X-FEM
       EXPL_ :


========================================================================
=== Recapitulation des operations demandees pour toutes les restitutions
========================================================================


    TYPE Action    unite                      user      Auteur         nblg  ajout suppr.

       C MODIF supervis/astermodule           durand C.DURAND          4010     57      5
 CASTEST AJOUT ascou22a                     lebouvie F.LEBOUVIER        376    376      0
 CASTEST AJOUT rccm07a                       galenne E.GALENNE          350    350      0
 CASTEST AJOUT sdnd102d                       boyere E.BOYERE           170    170      0
 CASTEST AJOUT sdnv100f                       boyere E.BOYERE           226    226      0
 CASTEST AJOUT ssnl131a                       godard V.GODARD           171    171      0
 CASTEST AJOUT ssnl131b                       godard V.GODARD           168    168      0
 CASTEST AJOUT ssnl131c                       godard V.GODARD           215    215      0
 CASTEST AJOUT ssnl131d                       godard V.GODARD           214    214      0
 CASTEST AJOUT ssnl132a                       godard V.GODARD           893    893      0
 CASTEST AJOUT ssnl132b                       godard V.GODARD           915    915      0
 CASTEST AJOUT ssnv171c                      joumana J.EL-GHARIB        260    260      0
 CASTEST AJOUT ssnv185a                      vabhhts J.PELLET           244    244      0
 CASTEST AJOUT ssnv185b                      vabhhts J.PELLET           191    191      0
 CASTEST AJOUT ssnv185c                      vabhhts J.PELLET           205    205      0
 CASTEST AJOUT ssnv185d                      vabhhts J.PELLET           188    188      0
 CASTEST AJOUT ssnv185e                      vabhhts J.PELLET           223    223      0
 CASTEST AJOUT zmat004a                      joumana J.EL-GHARIB        358    358      0
 CASTEST MODIF ascou20a                       durand C.DURAND            81      1      1
 CASTEST MODIF rccm01a                       galenne E.GALENNE          199      2      2
 CASTEST MODIF rccm01b                       galenne E.GALENNE          415    341    284
 CASTEST MODIF rccm02a                       galenne E.GALENNE          353      2      2
 CASTEST MODIF rccm02b                       galenne E.GALENNE          354      2      2
 CASTEST MODIF rccm03a                       galenne E.GALENNE         4279      2      2
 CASTEST MODIF rccm04a                       galenne E.GALENNE          361      2      1
 CASTEST MODIF rccm06a                       galenne E.GALENNE         1433      2      1
 CASTEST MODIF sdll108b                     lebouvie F.LEBOUVIER        455     93     89
 CASTEST MODIF sdnx300b                      vabhhts J.PELLET          2759      1      1
 CASTEST MODIF ssla200a                       durand C.DURAND          1315      1      1
 CASTEST MODIF sslv134b                      galenne E.GALENNE          693     72      1
 CASTEST MODIF ssnv182b                      vabhhts J.PELLET           271      2     10
 CASTEST MODIF ssnv182c                      vabhhts J.PELLET           212      2      2
 CASTEST MODIF wtnv123a                      joumana J.EL-GHARIB        599      4      4
 CASTEST MODIF wtnv126a                      joumana J.EL-GHARIB        851      4      5
 CASTEST MODIF wtnv126b                      joumana J.EL-GHARIB        824      4      5
 CASTEST MODIF zzzz120b                       durand C.DURAND           656      2      1
 CASTEST MODIF zzzz161a                      rezette C.REZETTE          259     36      2
 CASTEST MODIF zzzz162a                      rezette C.REZETTE          465     74      1
 CASTEST MODIF zzzz176a                      d6bhhjp J.P.LEFEBVRE       169     17      1
CATALOGU AJOUT typelem/d_depl_r_e1x          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e1y          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e1z          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e2x          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e2y          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e2z          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e3x          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e3y          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e3z          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e4x          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e4y          vabhhts J.PELLET            64     64      0
CATALOGU AJOUT typelem/d_depl_r_e4z          vabhhts J.PELLET            64     64      0
CATALOGU MODIF compelem/grandeur_simple__    vabhhts J.PELLET           573     28     29
CATALOGU MODIF compelem/type_maille__        vabhhts J.PELLET           338      3     24
CATALOGU MODIF options/calc_k_g              vabhhts J.PELLET            45      5      1
CATALOGU MODIF options/calc_k_g_f            vabhhts J.PELLET            44      8      1
CATALOGU MODIF options/char_meca_cont       torkhani M.TORKHANI          41      3      1
CATALOGU MODIF options/char_meca_frot       torkhani M.TORKHANI          41      3      1
CATALOGU MODIF options/forc_noda             vabhhts J.PELLET            85      4      2
CATALOGU MODIF options/rigi_cont            torkhani M.TORKHANI          40      3      1
CATALOGU MODIF options/rigi_frot            torkhani M.TORKHANI          40      3      1
CATALOGU MODIF typelem/gener_cmcfz1         torkhani M.TORKHANI          58      7      6
CATALOGU MODIF typelem/gener_cmcfz2         torkhani M.TORKHANI         150      7      6
CATALOGU MODIF typelem/gener_me3d_3          vabhhts J.PELLET           594     11      3
CATALOGU MODIF typelem/gener_me_x            vabhhts J.PELLET           579     14      6
CATALOGU MODIF typelem/gener_me_xh           vabhhts J.PELLET           268    135    129
CATALOGU MODIF typelem/gener_me_xht          vabhhts J.PELLET           260    182     56
CATALOGU MODIF typelem/gener_me_xt           vabhhts J.PELLET           226    151     60
CATALOGU MODIF typelem/gener_medtr1           godard V.GODARD           201     10      7
CATALOPY MODIF commande/affe_char_cine       cibhhlv L.VIVAN            136     63      3
CATALOPY MODIF commande/affe_char_cine_f     cibhhlv L.VIVAN             64      1      1
CATALOPY MODIF commande/affe_char_meca      torkhani M.TORKHANI         962      8      1
CATALOPY MODIF commande/affe_char_meca_f    torkhani M.TORKHANI         615     13      1
CATALOPY MODIF commande/debut                 durand C.DURAND            79      3      1
CATALOPY MODIF commande/defi_fiss_xfem       vabhhts J.PELLET            56      3      2
CATALOPY MODIF commande/defi_materiau         godard V.GODARD          2874     24      1
CATALOPY MODIF commande/impr_resu            rezette C.REZETTE          152      3      3
CATALOPY MODIF commande/poursuite             durand C.DURAND            76      3      1
CATALOPY MODIF commun/c_comp_incr             godard V.GODARD           321      3      1
    DATG MODIF ascouf_ssep_mult_v1.datg   F.LEBOUVIER 1774                20      1      0
 FORTRAN AJOUT algorith/dicrgr                godard V.GODARD           459    459      0
 FORTRAN AJOUT algorith/lcdigc                godard V.GODARD           187    187      0
 FORTRAN AJOUT algorith/lcdpec               joumana J.EL-GHARIB         31     31      0
 FORTRAN AJOUT algorith/xcalfe               vabhhts J.PELLET           157    157      0
 FORTRAN AJOUT algorith/xkel3d               vabhhts J.PELLET           370    370      0
 FORTRAN AJOUT elements/chauxi               vabhhts J.PELLET           169    169      0
 FORTRAN AJOUT elements/te0297               vabhhts J.PELLET           152    152      0
 FORTRAN AJOUT elements/xsif3d               vabhhts J.PELLET           332    332      0
 FORTRAN AJOUT elements/xxbsig               vabhhts J.PELLET           203    203      0
 FORTRAN AJOUT utilitai/fclose                durand C.DURAND            41     41      0
 FORTRAN MODIF algorith/cakg3d               vabhhts J.PELLET           371     16      4
 FORTRAN MODIF algorith/calcme               joumana J.EL-GHARIB        872      3      3
 FORTRAN MODIF algorith/conlig              torkhani M.TORKHANI          62     11     10
 FORTRAN MODIF algorith/frapp2              torkhani M.TORKHANI         701    297    273
 FORTRAN MODIF algorith/lccnvx               joumana J.EL-GHARIB         82      6      3
 FORTRAN MODIF algorith/lcconv               joumana J.EL-GHARIB        117      7      4
 FORTRAN MODIF algorith/lcelas               joumana J.EL-GHARIB         71      1      1
 FORTRAN MODIF algorith/lcinit               joumana J.EL-GHARIB         84     11      3
 FORTRAN MODIF algorith/lcjela               joumana J.EL-GHARIB         62      2      1
 FORTRAN MODIF algorith/lcjplc               joumana J.EL-GHARIB         59      1      1
 FORTRAN MODIF algorith/lcmate               joumana J.EL-GHARIB        140      1      1
 FORTRAN MODIF algorith/lcmmat               joumana J.EL-GHARIB        320      3      2
 FORTRAN MODIF algorith/lcmmcv               joumana J.EL-GHARIB        126     32      6
 FORTRAN MODIF algorith/lcmmei               joumana J.EL-GHARIB        131      2      2
 FORTRAN MODIF algorith/lcmmin               joumana J.EL-GHARIB        160     71      3
 FORTRAN MODIF algorith/lcmmja               joumana J.EL-GHARIB        171      2      2
 FORTRAN MODIF algorith/lcmmjf               joumana J.EL-GHARIB        214      2      2
 FORTRAN MODIF algorith/lcmmji               joumana J.EL-GHARIB        105      2      2
 FORTRAN MODIF algorith/lcmmjp               joumana J.EL-GHARIB        124      5      5
 FORTRAN MODIF algorith/lcmmon               joumana J.EL-GHARIB        147      1      6
 FORTRAN MODIF algorith/lcmmvx               joumana J.EL-GHARIB        101     10      4
 FORTRAN MODIF algorith/lcplas               joumana J.EL-GHARIB        135     13      5
 FORTRAN MODIF algorith/lcplnl               joumana J.EL-GHARIB        240     19      5
 FORTRAN MODIF algorith/mappar              torkhani M.TORKHANI         335     40     37
 FORTRAN MODIF algorith/mmacon              torkhani M.TORKHANI         237    110    109
 FORTRAN MODIF algorith/mmcmem              torkhani M.TORKHANI         151     95     93
 FORTRAN MODIF algorith/mmmbca              torkhani M.TORKHANI         273    104    107
 FORTRAN MODIF algorith/mmmres              torkhani M.TORKHANI        1027     69     69
 FORTRAN MODIF algorith/mxmass                boyere E.BOYERE           204      4      1
 FORTRAN MODIF algorith/nm1vil                godard V.GODARD           283      9      4
 FORTRAN MODIF algorith/nmcomp               joumana J.EL-GHARIB        728     13     10
 FORTRAN MODIF algorith/nmcpla               joumana J.EL-GHARIB        464      3      3
 FORTRAN MODIF algorith/nmdepl              torkhani M.TORKHANI         279    167    195
 FORTRAN MODIF algorith/nmible              torkhani M.TORKHANI         171     75     81
 FORTRAN MODIF algorith/nmvprk               joumana J.EL-GHARIB        355     18      1
 FORTRAN MODIF algorith/op0041               vabhhts J.PELLET           193      4      2
 FORTRAN MODIF algorith/op0070              torkhani M.TORKHANI         813     30     23
 FORTRAN MODIF algorith/plasti               joumana J.EL-GHARIB        474     11      4
 FORTRAN MODIF algorith/reaclm              torkhani M.TORKHANI         112     50     50
 FORTRAN MODIF algorith/rechco              torkhani M.TORKHANI         411    195    190
 FORTRAN MODIF algorith/redece               joumana J.EL-GHARIB        287     14      5
 FORTRAN MODIF algorith/sdconx               vabhhts J.PELLET           133     15     11
 FORTRAN MODIF algorith/vefnme               vabhhts J.PELLET           236      9      5
 FORTRAN MODIF algorith/xcrvol               vabhhts J.PELLET           120     17     26
 FORTRAN MODIF algorith/xinils               vabhhts J.PELLET           447     39     23
 FORTRAN MODIF algorith/xjacff               vabhhts J.PELLET           126      7      7
 FORTRAN MODIF algorith/xmel3d               vabhhts J.PELLET           162     21     19
 FORTRAN MODIF algorith/xmmbca               vabhhts J.PELLET           157      8      5
 FORTRAN MODIF algorith/xplmat               vabhhts J.PELLET            70      6      6
 FORTRAN MODIF calculel/calcul              torkhani M.TORKHANI         337      1      1
 FORTRAN MODIF calculel/nuelrf               vabhhts J.PELLET            82      2      3
 FORTRAN MODIF calculel/op0077               vabhhts J.PELLET           577      2      2
 FORTRAN MODIF elements/elraca               vabhhts J.PELLET           906      4      4
 FORTRAN MODIF elements/elraga               vabhhts J.PELLET          1077      4      6
 FORTRAN MODIF elements/elrfdf               vabhhts J.PELLET          1201      4      4
 FORTRAN MODIF elements/elrfvf               vabhhts J.PELLET           434      4      4
 FORTRAN MODIF elements/gverif               galenne E.GALENNE          774     64      5
 FORTRAN MODIF elements/reeref               vabhhts J.PELLET           246     62     23
 FORTRAN MODIF elements/te0047                godard V.GODARD           701     68      3
 FORTRAN MODIF elements/te0295               vabhhts J.PELLET           483     17      5
 FORTRAN MODIF elements/te0364              torkhani M.TORKHANI        1096    357    229
 FORTRAN MODIF elements/te0365              torkhani M.TORKHANI         729    340    232
 FORTRAN MODIF elements/te0532               vabhhts J.PELLET           227     23     21
 FORTRAN MODIF elements/te0533               vabhhts J.PELLET           465     36     55
 FORTRAN MODIF elements/te0534               vabhhts J.PELLET           396     30     31
 FORTRAN MODIF elements/te0539               vabhhts J.PELLET           330     36     30
 FORTRAN MODIF elements/te0542               vabhhts J.PELLET           120     37     18
 FORTRAN MODIF elements/te0548               vabhhts J.PELLET           144     19      9
 FORTRAN MODIF elements/xbsigm               vabhhts J.PELLET           138     22     10
 FORTRAN MODIF elements/xdel3d               vabhhts J.PELLET           103     10      8
 FORTRAN MODIF jeveux/jerecu                 vabhhts J.PELLET           165      4      2
 FORTRAN MODIF modelisa/calico              torkhani M.TORKHANI         419      1      1
 FORTRAN MODIF modelisa/caraco              torkhani M.TORKHANI         168    103    120
 FORTRAN MODIF modelisa/caxfem               vabhhts J.PELLET           111      9      1
 FORTRAN MODIF modelisa/cazocc              torkhani M.TORKHANI         254    149    125
 FORTRAN MODIF modelisa/cazoco              torkhani M.TORKHANI         576    386    373
 FORTRAN MODIF modelisa/charci               cibhhlv L.VIVAN            170     60     40
 FORTRAN MODIF modelisa/chcsur               cibhhlv L.VIVAN            248      7      4
 FORTRAN MODIF modelisa/op0059               joumana J.EL-GHARIB        263      6      2
 FORTRAN MODIF modelisa/op0101               cibhhlv L.VIVAN            111     31     24
 FORTRAN MODIF modelisa/op0108               cibhhlv L.VIVAN            104     27     20
 FORTRAN MODIF modelisa/surfco              torkhani M.TORKHANI         390      1      1
 FORTRAN MODIF modelisa/xdelco               vabhhts J.PELLET           178     20     27
 FORTRAN MODIF modelisa/xdeldl               vabhhts J.PELLET           222      7      7
 FORTRAN MODIF prepost/pkfond                galenne E.GALENNE          800      3      2
 FORTRAN MODIF supervis/affich                durand C.DURAND            34      8      3
 FORTRAN MODIF supervis/debut                 durand C.DURAND            83      2      7
 FORTRAN MODIF supervis/execop                durand C.DURAND           130      1      7
 FORTRAN MODIF supervis/ibcata                durand C.DURAND           122      4      4
 FORTRAN MODIF supervis/ibmain                durand C.DURAND            79      1      6
 FORTRAN MODIF supervis/op9999                durand C.DURAND           140      1     38
 FORTRAN MODIF utilifor/utfinm                durand C.DURAND           114      1      5
 FORTRAN MODIF utilitai/focrr0               vabhhts J.PELLET           211      1      3
 FORTRAN MODIF utilitai/focrr2               vabhhts J.PELLET           414      1      3
 FORTRAN MODIF utilitai/ulclos                durand C.DURAND            55      4      2
 FORTRAN MODIF utilitai/uttcpu                durand C.DURAND           148      2      2
 FORTRAN SUPPR algorith/xibsig               vabhhts J.PELLET           146      0    146
 FORTRAN SUPPR algorith/xxel3d               vabhhts J.PELLET           318      0    318
 FORTRAN SUPPR supervis/exstat                durand C.DURAND           118      0    118
  PYTHON MODIF Build/B_ETAPE                  durand C.DURAND           706      7      3
  PYTHON MODIF Build/B_JDC                    durand C.DURAND           173      1      1
  PYTHON MODIF Build/B_SENSIBILITE_JDC        durand C.DURAND           497      6      1
  PYTHON MODIF Cata/ops                       durand C.DURAND           442      8      5
  PYTHON MODIF Execution/E_ETAPE              durand C.DURAND           278     58     14
  PYTHON MODIF Execution/E_JDC                durand C.DURAND           281     89      2
  PYTHON MODIF Execution/E_MACRO_ETAPE        durand C.DURAND           209     27     18
  PYTHON MODIF Execution/E_SUPERV             durand C.DURAND           338     11      2
  PYTHON MODIF Macro/calc_precont_ops         durand C.DURAND           467      3      4
  PYTHON MODIF Macro/calc_table_ops           durand C.DURAND           176     11      7
  PYTHON MODIF Macro/defi_cable_bp_ops        durand C.DURAND           310     25     28
  PYTHON MODIF Macro/impr_fonction_ops        durand C.DURAND           402      9      7
  PYTHON MODIF Macro/lire_inte_spec_ops       durand C.DURAND           117      5     13
  PYTHON MODIF Macro/lire_table_ops           durand C.DURAND           177      3      3
  PYTHON MODIF Macro/macr_ascouf_calc_ops     durand C.DURAND           687      9     12
  PYTHON MODIF Macro/macr_ascouf_mail_ops     durand C.DURAND          2797    345    397
  PYTHON MODIF Macro/macr_aspic_calc_ops      durand C.DURAND           804     13     36
  PYTHON MODIF Macro/macr_aspic_mail_ops      durand C.DURAND           908     42     61
  PYTHON MODIF Macro/macr_cara_poutre_ops     durand C.DURAND           810      5     10
  PYTHON MODIF Macro/macr_lign_coupe_ops      durand C.DURAND           366      8     19
  PYTHON MODIF Macro/macr_recal_ops           durand C.DURAND           156      4      8
  PYTHON MODIF Macro/macro_elas_mult_ops      durand C.DURAND           273      3      4
  PYTHON MODIF Macro/macro_matr_ajou_ops      durand C.DURAND           256     13     17
  PYTHON MODIF Macro/macro_matr_asse_ops      durand C.DURAND           149      8     21
  PYTHON MODIF Macro/macro_proj_base_ops      durand C.DURAND            59      4      7
  PYTHON MODIF Macro/reca_algo                durand C.DURAND           260      4      3
  PYTHON MODIF Macro/reca_interp              durand C.DURAND           181     10      9
  PYTHON MODIF Noyau/N_JDC                    durand C.DURAND           450     11      1
  PYTHON MODIF Outils/macro_rota_globale      durand C.DURAND           143      2      2
  PYTHON MODIF Utilitai/Utmess                durand C.DURAND            47     10     29
  PYTHON SUPPR Macro/ajout_quad_gmsh          durand C.DURAND             0      0      0


        nb unites  nb lignes  ajouts  suppr.  difference
 AJOUT :   39        8236      8236             +8236
 MODIF :  176       71988      5812    4482     +1330
 SUPPR :    4         582               582      -582
 DEPLA :    0           0 
         ----      ------     ------  ------   ------
 TOTAL :  219       80806     14048    5064     +8984 
