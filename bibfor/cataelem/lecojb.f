      SUBROUTINE LECOJB(OB,UNITE,BASE,IRET)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF CATAELEM  DATE 18/09/2007   AUTEUR DURAND C.DURAND 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C TOLE CRS_512
      IMPLICIT NONE
      CHARACTER*(*) OB
      CHARACTER*1 BASE
      INTEGER UNITE ,IRET
C    BUT : LIRE UN OBJET JEVEUX SUR L'UNITE LOGIQUE : UNITE.
C          S'IL N'Y A PLUS RIEN A LIRE SUR LE FICHIER : IRET=1
C OUT   OB (K24)   : NOM DE L'OBJET LU
C IN    UNITE (I)  : UNITE LOGIQUE
C IN    BASE (K1)  : G/V/L
C OUT   IRET  (I)  : CODE RETOUR : 0 -> OK ; 1 : IL N'Y RIEN A LIRE
C --------------- COMMUNS NORMALISES  JEVEUX  --------------------------
      CHARACTER*32 JEXNUM,JEXNOM,JEXATR
      COMMON /IVARJE/ZI(1)
      COMMON /RVARJE/ZR(1)
      COMMON /CVARJE/ZC(1)
      COMMON /LVARJE/ZL(1)
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
      INTEGER ZI
      REAL*8 ZR
      COMPLEX*16 ZC
      LOGICAL ZL
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24,OB1
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      CHARACTER*8 KBID
C --------------- FIN COMMUNS NORMALISES  JEVEUX  --------------------
      CHARACTER*3 TYPE
      CHARACTER*40 ACCES
      CHARACTER*8 STOCK,MODLON,NOMK8,GENR
      CHARACTER*16 MOCLE1,MOCLE2,MOCLE3,MOCLE4
      INTEGER LONMAX
      INTEGER IAD,LONG,NMAXOC,NUTIOC,IOBJ,LONT
      INTEGER JTMP,K

      CALL JEMARQ()
      READ(UNITE,1001,END=9998) MOCLE1,GENR
      CALL ASSERT(MOCLE1.EQ.'|TYPE_JEVEUX=')


      IF (GENR.EQ.'SIMPLE') THEN
C     ----------------------------
          READ (UNITE,1002) MOCLE1,OB1,MOCLE2,TYPE,MOCLE3,LONG
          CALL ASSERT(MOCLE1.EQ.'|NOM=')
          CALL ASSERT(MOCLE2.EQ.'|TYPE=')
          CALL ASSERT(MOCLE3.EQ.'|LONMAX=')
          CALL WKVECT(OB1,BASE//' V '//TYPE,LONG,IAD)
          CALL LECVEC(IAD,LONG,TYPE,UNITE)


      ELSEIF (GENR.EQ.'PT_NOM') THEN
C     ----------------------------
          READ (UNITE,1002) MOCLE1,OB1,MOCLE2,TYPE,MOCLE3,LONG
          CALL ASSERT(MOCLE1.EQ.'|NOM=')
          CALL ASSERT(MOCLE2.EQ.'|TYPE=')
          CALL ASSERT(MOCLE3.EQ.'|NOMMAX=')
          CALL JECREO(OB1,BASE//' N '//TYPE)
          CALL WKVECT('&&LECOJB.PTNOM',BASE//' V '//TYPE,LONG,JTMP)
          CALL  LECVEC(JTMP,LONG,TYPE,UNITE)
          CALL JEECRA(OB1,'NOMMAX',LONG,KBID)
          IF (TYPE.EQ.'K8') THEN
            DO 10, K=1,LONG
               CALL JECROC(JEXNOM(OB1,ZK8(JTMP-1+K)))
 10         CONTINUE
          ELSEIF (TYPE.EQ.'K16') THEN
            DO 11, K=1,LONG
               CALL JECROC(JEXNOM(OB1,ZK16(JTMP-1+K)))
 11         CONTINUE
          ELSEIF (TYPE.EQ.'K24') THEN
            DO 12, K=1,LONG
               CALL JECROC(JEXNOM(OB1,ZK24(JTMP-1+K)))
 12         CONTINUE
          ELSEIF (TYPE.EQ.'K32') THEN
            DO 13, K=1,LONG
               CALL JECROC(JEXNOM(OB1,ZK32(JTMP-1+K)))
 13         CONTINUE
          ELSE
            CALL ASSERT(.FALSE.)
          END IF
          CALL JEDETR('&&LECOJB.PTNOM')



      ELSEIF (GENR.EQ.'COLLEC') THEN
C     ----------------------------
        READ (UNITE,1004) MOCLE1,OB1,MOCLE2,TYPE,MOCLE3,NMAXOC,
     &  MOCLE4,NUTIOC,MOCLE4,ACCES(1:2),MOCLE4,STOCK,
     &         MOCLE4,MODLON,MOCLE4,LONMAX,MOCLE4,LONT

        CALL ASSERT(MOCLE1.EQ.'|NOM=')
        CALL ASSERT(MOCLE2.EQ.'|TYPE=')
        CALL ASSERT(MOCLE3.EQ.'|NMAXOC=')
        CALL JECREC(OB1,BASE//' V '//TYPE,ACCES(1:2),STOCK,MODLON,
     &          NMAXOC)

        IF (STOCK.EQ.'CONTIG')  CALL JEECRA(OB1,'LONT',LONT,KBID)
        IF ((MODLON.EQ.'CONSTANT').AND.(STOCK.NE.'CONTIG'))
     &  CALL JEECRA(OB1,'LONMAX',LONMAX,KBID)
        DO 2,IOBJ=1,NUTIOC

          IF (ACCES(1:2).EQ.'NO') THEN
               READ (UNITE,1005) MOCLE1,NOMK8,MOCLE2,LONG
               CALL ASSERT(MOCLE1.EQ.'|NOM=')
               CALL ASSERT(MOCLE2.EQ.'|LONMAX=')
               CALL JECROC(JEXNOM(OB1,NOMK8))
               IF (MODLON.NE.'CONSTANT')
     &            CALL JEECRA(JEXNOM(OB1,NOMK8),'LONMAX',LONG,KBID)
               IF (LONG.GT.0) CALL JEVEUO(JEXNOM(OB1,NOMK8),'E',IAD)
          ELSE
               READ (UNITE,1006) MOCLE1,LONG
               CALL ASSERT(MOCLE1.EQ.'|LONMAX=')
               CALL JECROC(JEXNUM(OB1,IOBJ))
               IF (MODLON.NE.'CONSTANT')
     &              CALL JEECRA(JEXNUM(OB1,IOBJ),'LONMAX',LONG,KBID)
               IF (LONG.GT.0) CALL JEVEUO(JEXNUM(OB1,IOBJ),'E',IAD)
          END IF
          CALL  LECVEC(IAD,LONG,TYPE,UNITE)
 2      CONTINUE

      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF


      OB = OB1
      IRET=0
      GO TO 9999

9998  CONTINUE
      OB=' '
      IRET=1

9999  CONTINUE

      CALL JEDEMA()

 1001 FORMAT (A13,A6)
 1002 FORMAT (A5,A24,A6,A3,A8,I12)
 1004 FORMAT (A5,A24,A6,A3,A8,I12,A8,I12,
     &        A7,A2,A10,A8,A10,A8,
     &        A8,I12,A6,I12)
 1005 FORMAT (A5,A8,A8,I12)
 1006 FORMAT (A8,I12)
      END
