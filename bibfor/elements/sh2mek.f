      SUBROUTINE SH2MEK(XETEMP,SIGMA,RE)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ELEMENTS  DATE 03/07/2012   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C
C               ELEMENT SHB20
C
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      INTEGER IPROPE
      REAL*8 XE(60),RE(60,60)
      REAL*8 XCOQ(3,4),BKSIP(3,20,20),B(3,20)
      REAL*8 XCENT(3),PPP(3,3),TMPKE2(60,60)
      REAL*8 XL(3,4),XXX(3),YYY(3),TMPKE(60,60)
      REAL*8 XXG5(20),XYG5(20),XZG5(20),PXG5(20)
      REAL*8 SIGLOC(6),SIGMA(*)
C
      REAL*8 SIGMAG(6)
C
      REAL*8 SITMP1(20,20),SITMP2(20,20)
      REAL*8 XETEMP(*)

C
C ON DEFINIT LES POINTS DE GAUSS ET LES POIDS
C
C-----------------------------------------------------------------------
      INTEGER I ,IP ,IZ ,J ,KK 
      REAL*8 AJAC ,RBID ,ZETA ,ZLAMB 
C-----------------------------------------------------------------------
      XZG5(1) = -0.906179845938664D0
      XZG5(2) = -0.538469310105683D0
      XZG5(3) =  0.D0
      XZG5(4) =  0.538469310105683D0
      XZG5(5) =  0.906179845938664D0
C
      PXG5(1) =  0.236926885056189D0
      PXG5(2) =  0.478628670499366D0
      PXG5(3) =  0.568888888888889D0
      PXG5(4) =  0.478628670499366D0
      PXG5(5) =  0.236926885056189D0
C
      DO 10 IZ =1,5
         XXG5(IZ)    = -0.577350269189625D0
         XXG5(IZ+5)  =  0.577350269189625D0
         XXG5(IZ+10) =  0.577350269189625D0
         XXG5(IZ+15) = -0.577350269189625D0
         XYG5(IZ)    = -0.577350269189625D0
         XYG5(IZ+5)  = -0.577350269189625D0
         XYG5(IZ+10) =  0.577350269189625D0
         XYG5(IZ+15) =  0.577350269189625D0
         XZG5(IZ+5)  = XZG5(IZ)
         PXG5(IZ+5)  = PXG5(IZ)
         XZG5(IZ+10) = XZG5(IZ)
         PXG5(IZ+10) = PXG5(IZ)
         XZG5(IZ+15) = XZG5(IZ)
         PXG5(IZ+15) = PXG5(IZ)
   10 CONTINUE
C
      DO 20 I = 1,60
        XE(I) = XETEMP(I)
   20 CONTINUE
CC
CC CALCUL DE B (1 2 3) AUX 5 POINTS DE GAUSS
CC
       CALL SH2KSI(20,XXG5,XYG5,XZG5,BKSIP)
       DO 40 J=1,20
         DO 30 I=1,20
           SITMP2(I,J) = 0.D0
   30    CONTINUE
   40  CONTINUE
CC
CC DEBUT DE LA BOUCLE SUR LES 20 PTS GAUSS
CC
       DO 140 IP=1,20
CC
CC CALCUL DE B
CC
         CALL S2CALB(BKSIP(1,1,IP),XE,B,AJAC)
CC
CC CALCUL DE MATRICE DE PASSAGE POUR POUVOIR CALCULER LES CONTRAINTES
CC DANS LE REPERE GLOBAL
CC
         DO 50 I=1,6
CC LES CONTRAINTES LOCALES POUR POUVOIR TRAITER LA PLASTICITE AVANT
            SIGLOC(I)=SIGMA((IP-1)*6+I)
   50    CONTINUE
         ZETA  = XZG5(IP)
         ZLAMB = 0.5D0*(1.D0-ZETA)
         DO 70 I=1,4
            DO 60 J=1,3
               XCOQ(J,I) = ZLAMB*XE((I-1)*3+J)
     &             + (1.D0-ZLAMB)*XE(3*I+9+J)
   60       CONTINUE
   70    CONTINUE
C
         CALL RLOSHB(XCOQ,XCENT,PPP,XL,XXX,YYY,RBID)
CC
CC PASSAGE DES CONTRAINTES AU REPERE GLOBAL
CC
         CALL CHRP3D(PPP,SIGLOC,SIGMAG,1)
         DO 90 J = 1,20
           DO 80 I = 1,20
             SITMP1(I,J) = 0.D0
   80      CONTINUE
   90    CONTINUE
C
         DO 110 J = 1,20
           DO 100 I = 1,20
             SITMP1(I,J) = SIGMAG(1)*B(1,I)*B(1,J) +
     &         SIGMAG(2)*B(2,I)*B(2,J) +
     &         SIGMAG(3)*B(3,I)*B(3,J) +
     &         SIGMAG(4)*(B(1,I)*B(2,J)+B(2,I)*B(1,J)) +
     &         SIGMAG(6)*(B(1,I)*B(3,J)+B(3,I)*B(1,J)) +
     &         SIGMAG(5)*(B(3,I)*B(2,J)+B(2,I)*B(3,J))
  100      CONTINUE
  110    CONTINUE
C
         DO 130 J=1,20
            DO 120 I=1,20
               SITMP2(I,J) = SITMP2(I,J)
     &               + AJAC*PXG5(IP)*SITMP1(I,J)
  120       CONTINUE
  130    CONTINUE
  140  CONTINUE
       CALL R8INIR(3600,0.D0,TMPKE,1)
       DO 170 KK=1,3
         DO 160 I=1,20
            DO 150 J=1,20
               TMPKE(I+(KK-1)*20,J+(KK-1)*20) = SITMP2(I,J)
  150       CONTINUE
  160    CONTINUE
  170  CONTINUE
CC
CC ON MET DE L'ORDRE:
C
       CALL R8INIR(3600,0.D0,TMPKE2,1)
       DO 190 J=1,20
         DO 180 I=1,60
            TMPKE2(I,(J-1)*3+1)=TMPKE(I,J)
            TMPKE2(I,(J-1)*3+2)=TMPKE(I,J+20)
            TMPKE2(I,(J-1)*3+3)=TMPKE(I,J+40)
  180    CONTINUE
  190  CONTINUE
C
       CALL R8INIR(3600,0.D0,TMPKE,1)
       DO 210 I=1,20
         DO 200 J=1,60
            TMPKE((I-1)*3+1,J)=TMPKE2(I,J)
            TMPKE((I-1)*3+2,J)=TMPKE2(I+20,J)
            TMPKE((I-1)*3+3,J)=TMPKE2(I+40,J)
  200    CONTINUE
  210  CONTINUE
C
       IPROPE = 1
C
       IF(IPROPE.EQ.0) THEN
          CALL DCOPY(3600,TMPKE,1,RE,1)
       END IF
C
       IF(IPROPE.EQ.1) THEN
          CALL DAXPY(3600,1.D0,TMPKE,1,RE,1)
       END IF
C
       END
