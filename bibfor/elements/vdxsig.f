      SUBROUTINE VDXSIG(NOMTE,OPTION,XI,NB1,NPGSR,SIGTOT,SIGMPG,EFFGT)
      IMPLICIT REAL*8 (A-H,O-Z)
      REAL*8 SIGMPG(*)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ELEMENTS  DATE 31/01/2012   AUTEUR REZETTE C.REZETTE 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C
C CALCUL DES OPTIONS SIEF_ELGA SIGM_ELNO
C                    EFGE_ELNO EPSI_ELNO
C  POUR LES COQUE_3D
C
C ======================================================================
C --------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ---------------------
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C --------- FIN  DECLARATIONS  NORMALISEES  JEVEUX --------------------
      CHARACTER*16 NOMTE,OPTION
      INTEGER NB1,NB2,NPGE,NPGSR,NPGSN
      INTEGER NBCOU,JCOU,IMOY,IRET,IRET1,IRET2,IRET3
      PARAMETER(NCOUMX=10)
      REAL*8 XI(3,9),SIG(NCOUMX*162),EPS(NCOUMX*162),TEM(NCOUMX*27)
      REAL*8 VECTA(9,2,3),VECTN(9,3),VECTPT(9,2,3)
      REAL*8 VECTG(2,3),VECTT(3,3)
      REAL*8 HSFM(3,9),HSS(2,9),HSJ1M(3,9),HSJ1S(2,9)
      REAL*8 BTDM(4,3,42),BTDS(4,2,42)
      REAL*8 HSF(3,9),HSJ1FX(3,9),WGT
      REAL*8 BTDF(3,42),BTILD(5,42)
      REAL*8 DEPL(42),ROTF(9)
      REAL*8 EPSILN(6,27),SIGMA(6,27),SIGTOT(6,9),EFFGT(8,9)
      REAL*8 TEMPGA(27)
      REAL*8 YOUNG,NU,ALPHA,EPAIS
      REAL*8 XI3,P1XI3,P2XI3,P3XI3,TINF,TMOY,TSUP
      REAL*8 EPSVAL(3),KSI3S2,ZERO,DEUX,HIC,ZMIN,UN
C
C     LES TABLEAUX SIG,EPS,TEM ONT ETE ALLOUES DE FACON STATIQUE POUR
C     OPTIMISER LE CPU CAR LES APPELS A WKVECT DANS LES TE SONT COUTEUX.
      ZERO = 0.0D0
      UN = 1.0D0
      DEUX = 2.0D0
C NOMBRE DE POINTS DE GAUSS DANS LA TRANCHE
C (POUR RESTER COHERENT AVEC SIEF_ELGA EN PLASTICITE )
      NPGE=3
      EPSVAL(1)=-1.D0
      EPSVAL(2)=0.D0
      EPSVAL(3)=1.D0
C
C     RECUPERATION DES OBJETS
C
      CALL JEVETE('&INEL.'//NOMTE(1:8)//'.DESI',' ', LZI )
      NB1  =ZI(LZI-1+1)
      NB2  =ZI(LZI-1+2)
      NPGSR=ZI(LZI-1+3)
      NPGSN=ZI(LZI-1+4)
C
      CALL JEVETE('&INEL.'//NOMTE(1:8)//'.DESR',' ', LZR )
C
      CALL JEVECH ('PCACOQU' , 'L' , JCARA)
      EPAIS = ZR(JCARA)
C
      CALL JEVECH('PNBSP_I','L',JCOU)
      NBCOU=ZI(JCOU)
      IMOY=(3*NBCOU+1)/2
      HIC = UN/NBCOU
      ZMIN = -0.5D0
C
      CALL RCVARC(' ','TEMP','REF','RIGI',1,1,TREF,IRET)
      CALL VECTAN(NB1,NB2,XI,ZR(LZR),VECTA,VECTN,VECTPT)
C
      CALL JEVECH('PDEPLAR', 'L', JDEPG)
C
      CALL TRNDGL(NB2,VECTN,VECTPT,ZR(JDEPG),DEPL,ROTF)
C
      KWGT=0
      KPGS=0
C
      DO 90 ICOU=1,NBCOU
C
      DO 100 INTE=1,NPGE
C
C     CALCUL DE BTDMR, BTDSR : M=MEMBRANE , S=CISAILLEMENT , R=REDUIT
C
C       -- COTE DES POINTS D'INTEGRATION
C       --------------------------------
      IF (INTE.EQ.1) THEN
        KSI3S2 = ZMIN + (ICOU-1)*HIC
      ELSE IF (INTE.EQ.2) THEN
        KSI3S2 = ZMIN + HIC/DEUX + (ICOU-1)*HIC
      ELSE
        KSI3S2 = ZMIN + HIC + (ICOU-1)*HIC
      END IF
C
        DO 150 INTSR=1,NPGSR
          CALL MAHSMS(0,NB1,XI,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTN,
     &                                       VECTG,VECTT,HSFM,HSS)
C
          CALL HSJ1MS(EPAIS,VECTG,VECTT,HSFM,HSS,HSJ1M,HSJ1S)
C
          CALL BTDMSR(NB1,NB2,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTPT,
     &                                       HSJ1M,HSJ1S,BTDM,BTDS)
 150    CONTINUE
C
        DO 200 INTSN=1,NPGSN
C
C     CALCUL DE BTDFN : F=FLEXION , N=NORMAL
C     ET DEFINITION DE WGT=PRODUIT DES POIDS ASSOCIES AUX PTS DE GAUSS
C                          (NORMAL) ET DU DETERMINANT DU JACOBIEN
C
          CALL MAHSF(1,NB1,XI,KSI3S2,INTSN,ZR(LZR),EPAIS,VECTN,
     &                                             VECTG,VECTT,HSF)
C
          CALL HSJ1F(INTSN,ZR(LZR),EPAIS,VECTG,VECTT,HSF,
     &                                                  KWGT,HSJ1FX,WGT)
C
          CALL BTDFN(1,NB1,NB2,KSI3S2,INTSN,ZR(LZR),EPAIS,VECTPT,
     &                                                      HSJ1FX,BTDF)
C
C     CALCUL DE BTDMN, BTDSN : M=MEMBRANE , S=CISAILLEMENT , N=NORMAL
C     FORMATION DE BTILD
C
          CALL BTDMSN(1,NB1,INTSN,NPGSR,ZR(LZR),BTDM,BTDF,BTDS,BTILD)
C
C     APPEL DE MATRTH POUR RECUPERER INDITH AFIN DE SAVOIR SI
C     ALPHA EST DONNE C'EST A DIRE SI THERMIQUE
C
          CALL RCVARC(' ','TEMP','+','MASS',INTSN,3*ICOU-2,TINF,IRET1)
          CALL RCVARC(' ','TEMP','+','MASS',INTSN,3*ICOU-1,TMOY,IRET2)
          CALL RCVARC(' ','TEMP','+','MASS',INTSN,3*ICOU,TSUP,IRET3)
          IF ( (IRET1+IRET2+IRET3) .EQ. 0 ) THEN
            CALL MATRTH('MASS',NPGSN,YOUNG,NU,ALPHA,INDITH)
            XI3=EPSVAL(INTE)
            P1XI3= 1-XI3*XI3
            P2XI3=-XI3*(1-XI3)/2.D0
            P3XI3= XI3*(1+XI3)/2.D0
            IF (IRET.EQ.1) THEN
                CALL U2MESS('F','CALCULEL_15')
              ELSE
                TEM(KWGT)=TMOY*P1XI3+TINF*P2XI3+TSUP*P3XI3
                TEM(KWGT)=TEM(KWGT)-TREF
              ENDIF
          ELSE
            INDITH=-1
          ENDIF
C
          CALL VDESGA(NOMTE,KWGT,INTE,INTSN,NB1,NB2,XI,DEPL,BTILD,
     &                INDITH,ALPHA,TEM,EPS,SIG,VECTT)
C
          KPGS = KPGS+1
          K1=6*((INTSN-1)*NPGE*NBCOU+NPGE*(ICOU-1)+INTE - 1)
          DO 35 I=1,6
            SIGMPG(K1+I) = SIG(I+6*(KPGS-1))
 35       CONTINUE
C
 200    CONTINUE
 100  CONTINUE
 90   CONTINUE
C
      KWGT=0
      KPGS=0

C CAS OU ON CALCULE SIGM_ELNO OU EPSI_ELNO, ON REPASSE
C A 2 POINTS DE GAUSS CAR LES MATRICES DE PASSAGE GAUSS/NOEUD SONT
C CALCULES POUR 2 POINTS DE GAUSS ET LES CONTRAINTES EXIBEES RESTENT
C INTERNES AU CALCUL
C ON REPASSE AUSSI SUR UNE COUCHE ( ELGA = SUR NBCOU COUCHES
C                                   ELNO = SUR 1 COUCHE  )

       IF ( (OPTION .EQ. 'SIGM_ELNO' ) .OR.
     &     (OPTION .EQ. 'EPSI_ELNO' ) ) THEN
         NPGE=2
         EPSVAL(1)=-0.57735026918962D0
         EPSVAL(2)=0.57735026918962D0
      ENDIF

      DO 101 INTE=1,NPGE
C
C     CALCUL DE BTDMR, BTDSR : M=MEMBRANE , S=CISAILLEMENT , R=REDUIT
C
      KSI3S2=EPSVAL(INTE)/2.D0
      DO 151 INTSR=1,NPGSR
        CALL MAHSMS(0,NB1,XI,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTN,
     &                                       VECTG,VECTT,HSFM,HSS)
C
        CALL HSJ1MS(EPAIS,VECTG,VECTT,HSFM,HSS,HSJ1M,HSJ1S)
C
        CALL BTDMSR(NB1,NB2,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTPT,
     &                                       HSJ1M,HSJ1S,BTDM,BTDS)
C
C       CALL BTDMSP(NB1,NB2,XI,INTE,INTSR,ZR(LZR),EPAIS,VECTPT,
C    &                                       HSJ1M,HSJ1S,BTDM,BTDS)
        CALL MAHSF(0,NB1,XI,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTN,
     &                                             VECTG,VECTT,HSF)
C
        CALL HSJ1F(INTSR,ZR(LZR),EPAIS,VECTG,VECTT,HSF,KWGT,HSJ1FX,WGT)
C
        CALL BTDFN(0,NB1,NB2,KSI3S2,INTSR,ZR(LZR),EPAIS,VECTPT,
     &                                                      HSJ1FX,BTDF)
C     CALL BTDFP(0,NB1,NB2,XI,INTE,INTSR,ZR(LZR),EPAIS,VECTPT,HSJ1FX,
C    &                                                             BTDF)
C
        CALL BTDMSN(0,NB1,INTSR,NPGSR,ZR(LZR),BTDM,BTDF,BTDS,BTILD)
C
C     CALL BTILDP(0,NB1,XI,INTE,INTSR,NPGSR,ZR(LZR),BTDM,BTDF,BTDS,
C    &                                                            BTILD)
C
C     APPEL DE MATRTH POUR RECUPERER INDITH AFIN DE SAVOIR SI
C     ALPHA EST DONNE C'EST A DIRE SI THERMIQUE
C
        CALL RCVARC(' ','TEMP','+','RIGI',INTSR,1,TINF,IRET1)
        CALL RCVARC(' ','TEMP','+','RIGI',INTSR,IMOY,TMOY,IRET2)
        CALL RCVARC(' ','TEMP','+','RIGI',INTSR,3*NBCOU,TSUP,IRET3)
        IF ( (IRET1+IRET2+IRET3) .EQ. 0 ) THEN
            CALL MATRTH('RIGI',NPGSR,YOUNG,NU,ALPHA,INDITH)
            XI3=EPSVAL(INTE)
            P1XI3= 1-XI3*XI3
            P2XI3=-XI3*(1-XI3)/2.D0
            P3XI3= XI3*(1+XI3)/2.D0
            IF (IRET.EQ.1) THEN
                CALL U2MESS('F','CALCULEL_15')
            ELSE
                TEMPGA(KWGT)=TMOY*P1XI3+TINF*P2XI3+TSUP*P3XI3
                TEMPGA(KWGT)=TEMPGA(KWGT)-TREF
            ENDIF
        ELSE
            TEMPGA(KWGT)=0.D0
        ENDIF
C
        CALL VDESGA(NOMTE,KWGT,INTE,INTSR,NB1,NB2,XI,DEPL,BTILD,
     &                       INDITH,ALPHA,TEMPGA,EPSILN,SIGMA,VECTT)
C
 151  CONTINUE
 101  CONTINUE
C
      IF (OPTION(1:9).EQ.'EPSI_ELNO'.OR.
     &    OPTION(1:9).EQ.'SIGM_ELNO') THEN
C
        CALL JEVECH('PNUMCOR','L',JNUMCO)
        INIV=ZI(JNUMCO+1)
        CALL VDESND(NOMTE,OPTION,INIV,NB1,NPGE,NPGSR,ZR(LZR),EPSILN
     &                                                    ,SIGMA,SIGTOT)
C
      ELSE IF (OPTION(1:9).EQ.'EFGE_ELNO') THEN
C
        CALL VDEFGE(NOMTE,OPTION,NB1,NPGSR,ZR(LZR),EPAIS,SIGMA,EFFGT)
C
      ENDIF
C
C --- DETERMINATION DES REPERES  LOCAUX DE L'ELEMENT AUX POINTS
C --- D'INTEGRATION ET STOCKAGE DE CES REPERES DANS LE VECTEUR .DESR :
C     --------------------------------------------------------------
      K = 0
      DO 110 INTSR=1,NPGSR
        CALL VECTGT(0,NB1,XI,ZERO,INTSR,ZR(LZR),EPAIS,VECTN,VECTG,VECTT)
C
        DO 120 J = 1, 3
          DO 130 I = 1, 3
            K = K + 1
            ZR(LZR+2000+K-1) = VECTT(I,J)
 130      CONTINUE
 120    CONTINUE
 110  CONTINUE
C
      END
