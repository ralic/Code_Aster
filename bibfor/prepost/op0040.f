      SUBROUTINE OP0040 ( IER )
      IMPLICIT   NONE
      INTEGER             IER
C     ------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF PREPOST  DATE 09/01/2006   AUTEUR DURAND C.DURAND 
C ======================================================================
C COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE D6BHHAM A.M.DONORE
C
C     PROCEDURE IMPR_OAR
C     ------------------------------------------------------------------
C     ----- DEBUT COMMUNS NORMALISES  JEVEUX  --------------------------
      INTEGER           ZI
      COMMON / IVARJE / ZI(1)
      REAL*8            ZR
      COMMON / RVARJE / ZR(1)
      COMPLEX*16        ZC
      COMMON / CVARJE / ZC(1)
      LOGICAL           ZL
      COMMON / LVARJE / ZL(1)
      CHARACTER*8       ZK8
      CHARACTER*16              ZK16
      CHARACTER*24                       ZK24
      CHARACTER*32                                ZK32
      CHARACTER*80                                         ZK80
      COMMON / KVARJE / ZK8(1), ZK16(1), ZK24(1), ZK32(1), ZK80(1)
C     ----- FIN COMMUNS NORMALISES  JEVEUX  ----------------------------
C
C
C
      INTEGER NOCC, IOCC, IOC2
C
      INTEGER LXLGUT, IRET,IFI,N1
      INTEGER NUMCHA,IBID,NUMMAI(2),IMAI
      INTEGER JCESD,JCESV,JCESL,IAD,NBPT,NBSP
      INTEGER JCONX,JPOIN,NNOE,INOEUD(4),IPOIN(2),INOE(2)
      INTEGER NUMNOE,TYPMA1,TYPMA2,JTYPEL,NBMAI
C
      REAL*8 PREC, BORSUP, BORINF, VERSI2, EPS
      REAL*8 VAL1,VAL2,VAL3,TEMPE
      REAL*8 R1(2),EP1(2),R2(2),EP2(2),RCOU(2),ANGLE(2)
      REAL*8 TOTO
C
      LOGICAL LRESU,LCOR,LMAX,LMIN,LINF,LSUP,LCASTS,LMOD,LGMSH,ULEXIS
C     ------------------------------------------------------------------
      CHARACTER*1  CBID
      CHARACTER*2  SIGCHA
      CHARACTER*8  K8B,NOMCMD,MAILLE(2),NOEUD,RESU,LICMP(3)
      CHARACTER*8  LISCMP(4)
      CHARACTER*8  MAILLA,CARGEO,MODELE,FICHIE
      CHARACTER*10 TYPCHA,NATCHA
      CHARACTER*16 CHAM
      CHARACTER*19 NOCH19,CHACES,CHARED,CARGE1,GEOCES,GEORED
      CHARACTER*16 NOMMAI(2)
      CHARACTER*32 JEXNUM,JEXNOM,JEXATR
      CHARACTER*40 CHAINE
C
C     ------------------------------------------------------------------
      CALL JEMARQ()
      CALL INFMAJ()
C
C     --- RECUPERATION DU NOM DE LA COMMANDE ---
      CALL GETRES ( K8B, K8B, NOMCMD )
C     --- RECUPERATION DU NOMBRE DE MISES EN FACTEUR DU MOT-CLE CHARGE
      CALL GETFAC ( 'CHARGE', NOCC )
C
      IFI = 0
      FICHIE = ' '
      CALL GETVIS ( ' ', 'UNITE'  , 1,1,1, IFI , N1 )
      IF ( .NOT. ULEXIS( IFI ) ) THEN
         CALL ULOPEN ( IFI, ' ', FICHIE, 'NEW', 'O' )
      ENDIF
C
C
C     -------------------------------------------
C     --- TRAITEMENT DE LA COMMANDE IMPR_OAR  ---
C     -------------------------------------------
      CALL GETVID ( ' ', 'MAILLAGE'  ,0,1,1, MAILLA, IBID)
      CALL GETVID ( ' ', 'MODELE'  ,0,1,1, MODELE, IBID)
      CALL GETVID ( ' ', 'MAILLE'    ,0,1,2, MAILLE  , IBID)
      CALL JENONU (JEXNOM (MAILLA//'.NOMMAI',MAILLE(1)),NUMMAI(1))
      CALL JENONU (JEXNOM (MAILLA//'.NOMMAI',MAILLE(2)),NUMMAI(2))
      CALL GETVID ( ' ', 'NOEUD'     ,0,1,1, NOEUD   , IBID)
      CALL JENONU (JEXNOM (MAILLA//'.NOMNOE',NOEUD),NUMNOE)
C
C  VERIFICATION QUE LE NOEUD APPARTIENT BIEN AUX DEUX MAILLES
C
      CALL JEVEUO (MAILLA//'.CONNEX','L',JCONX)
      CALL JEVEUO (JEXATR(MAILLA//'.CONNEX','LONCUM'),'L',JPOIN)
      DO 35 IMAI = 1,2
         IPOIN(IMAI) = ZI(JPOIN-1+NUMMAI(IMAI))
         NNOE = ZI(JPOIN-1+NUMMAI(IMAI)+1)-IPOIN(IMAI)
         CALL ASSERT(NNOE.EQ.2)
         INOEUD((IMAI-1)*2+1) = ZI(JCONX-1+IPOIN(IMAI))
         INOEUD((IMAI-1)*2+2) = ZI(JCONX-1+IPOIN(IMAI)+1)
         IF (INOEUD((IMAI-1)*2+1).EQ.NUMNOE) THEN
           INOE (IMAI) = 1
         ELSEIF (INOEUD((IMAI-1)*2+2).EQ.NUMNOE) THEN
           INOE (IMAI) = 2
         ELSE
           CALL UTMESS ('F','OP0040','LE NOEUD MENTIONNE EST INVALIDE')
         ENDIF
 35   CONTINUE
C
C  RECUPERATION DES CARACTERISTIQUES GEOMETRIQUES
C
      CALL GETVID ( ' ', 'CARA_ELEM' ,0,1,1, CARGEO  , IBID)
      CALL JELIRA (MAILLA//'.NOMMAI','NOMMAX',NBMAI,CBID)
      CALL IRTYEL (MODELE,NBMAI)
      CALL JEVEUO ('&&IRTYEL.TYPELEM','L',JTYPEL)
      TYPMA1 = ZI(JTYPEL-1+NUMMAI(1))
      TYPMA2 = ZI(JTYPEL-1+NUMMAI(2))
      CALL JENUNO(JEXNUM('&CATA.TE.NOMTE',TYPMA1),NOMMAI(1))
      CALL JENUNO(JEXNUM('&CATA.TE.NOMTE',TYPMA2),NOMMAI(2))
C
      DO 55 IMAI = 1,2
C
        IF (NOMMAI(IMAI).EQ.'MECA_POU_D_T'.OR.
     +      NOMMAI(IMAI).EQ.'MECA_POU_C_T') THEN
           CARGE1 = CARGEO//'.CARGEOPO'
           GEOCES = '&&OP0040.GEOCES'
           CALL CARCES ( CARGE1,'ELEM',' ','V',GEOCES,IBID)
C
C   TRANSFORMATION DU CHAMELEM EN CHAMELEM SIMPLE
C
           GEORED = '&&OP0040.GEOCER'
           LISCMP(1) = 'R1'
           LISCMP(2) = 'EP1'
           LISCMP(3) = 'R2'
           LISCMP(4) = 'EP2'
           CALL CESRED (GEOCES,1,NUMMAI(IMAI),4,LISCMP,'V',GEORED)
           CALL JEVEUO ( GEORED//'.CESD','L',JCESD)
           CALL JEVEUO ( GEORED//'.CESV','L',JCESV)
           CALL JEVEUO ( GEORED//'.CESL','L',JCESL)
           NBPT = ZI(JCESD-1+5+4*(NUMMAI(IMAI)-1)+1)
           CALL ASSERT (NBPT.EQ.1)
           NBSP = ZI(JCESD-1+5+4*(NUMMAI(IMAI)-1)+2)
           CALL ASSERT (NBSP.EQ.1)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,1,IAD)
           CALL ASSERT(IAD.GT.0)
           R1(IMAI) = ZR(JCESV-1+IAD)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,2,IAD)
           CALL ASSERT(IAD.GT.0)
           EP1(IMAI) = ZR(JCESV-1+IAD)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,3,IAD)
           CALL ASSERT(IAD.GT.0)
           R2(IMAI) = ZR(JCESV-1+IAD)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,4,IAD)
           CALL ASSERT(IAD.GT.0)
           EP2(IMAI) = ZR(JCESV-1+IAD)
        ENDIF
        IF(NOMMAI(IMAI).EQ.'MECA_POU_C_T') THEN
           CARGE1 = CARGEO//'.CARARCPO'
           GEOCES = '&&OP0040.GEOCES'
           CALL CARCES ( CARGE1,'ELEM',' ','V',GEOCES,IBID)
C
C   TRANSFORMATION DU CHAMELEM EN CHAMELEM SIMPLE
C
           GEORED = '&&OP0040.GEOCER'
           LISCMP(1) = 'RCOURB'
           LISCMP(2) = 'ORIE_ARC'
           CALL CESRED (GEOCES,1,NUMMAI(IMAI),2,LISCMP,'V',GEORED)
           CALL JEVEUO ( GEORED//'.CESD','L',JCESD)
           CALL JEVEUO ( GEORED//'.CESV','L',JCESV)
           CALL JEVEUO ( GEORED//'.CESL','L',JCESL)
           NBPT = ZI(JCESD-1+5+4*(NUMMAI(IMAI)-1)+1)
           CALL ASSERT (NBPT.EQ.1)
           NBSP = ZI(JCESD-1+5+4*(NUMMAI(IMAI)-1)+2)
           CALL ASSERT (NBSP.EQ.1)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,1,IAD)
           CALL ASSERT(IAD.GT.0)
           RCOU(IMAI) = ZR(JCESV-1+IAD)
           CALL CESEXI('C',JCESD,JCESL,NUMMAI(IMAI),1,1,2,IAD)
           CALL ASSERT(IAD.GT.0)
           ANGLE(IMAI) = ZR(JCESV-1+IAD)
           ANGLE(IMAI)= (ANGLE(IMAI)*180.D0)/(3.14D0)
        ENDIF
C
  55  CONTINUE
C
C  IMPRESSION DES CARACTERISTIQUES GEOMETRIQUES
C
      WRITE(IFI,'(A)') '<TUYAUTERIE>'
      IF(NOMMAI(1).EQ.'MECA_POU_D_T'.AND.
     + (ABS(EP1(1)-EP2(1)).GT.(1.D-10).OR.
     +  ABS(R1(1)-R2(1)).GT.(1.D-10)))
     +   NOMMAI(1) = 'MECA_POU_R_T'
      IF(NOMMAI(2).EQ.'MECA_POU_D_T'.AND.
     +   (ABS(EP1(2)-EP2(2)).GT.(1.D-10).OR.
     +   ABS(R1(2)-R2(2)).GT.(1.D-10)))
     +   NOMMAI(2) = 'MECA_POU_R_T'
      IF(NOMMAI(1).EQ.'MECA_POU_C_T'.AND.
     +   NOMMAI(2).EQ.'MECA_POU_C_T') THEN
         CHAINE = '<TYPE_JONCTION>CNC</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(2).EQ.'MECA_POU_C_T'.AND.
     +       NOMMAI(1).EQ.'MECA_POU_C_T') THEN
         CHAINE = '<TYPE_JONCTION>CNC</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(1).EQ.'MECA_POU_C_T'.AND.
     +       NOMMAI(2).EQ.'MECA_POU_D_T') THEN
         CHAINE =  '<TYPE_JONCTION>EC</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(2).EQ.'MECA_POU_C_T'.AND.
     +       NOMMAI(1).EQ.'MECA_POU_D_T') THEN
         CHAINE = '<TYPE_JONCTION>EC</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(1).EQ.'MECA_POU_R_T'.AND.
     +       NOMMAI(2).EQ.'MECA_POU_D_T') THEN
         CHAINE = '<TYPE_JONCTION>TRAN1</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(2).EQ.'MECA_POU_R_T'.AND.
     +       NOMMAI(1).EQ.'MECA_POU_D_T') THEN
         CHAINE = '<TYPE_JONCTION>TRAN1</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(1).EQ.'MECA_POU_D_T'.AND.
     +       NOMMAI(2).EQ.'MECA_POU_D_T') THEN
         CHAINE =  '<TYPE_JONCTION>TUY</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(2).EQ.'MECA_POU_D_T'.AND.
     +       NOMMAI(1).EQ.'MECA_POU_D_T') THEN
         CHAINE =  '<TYPE_JONCTION>TUY</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(1).EQ.'MECA_POU_C_T'.AND.
     +       NOMMAI(2).EQ.'MECA_POU_R_T') THEN
         CHAINE =  '<TYPE_JONCTION>CTRAN1</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ELSEIF(NOMMAI(2).EQ.'MECA_POU_R_T'.AND.
     +       NOMMAI(1).EQ.'MECA_POU_C_T') THEN
         CHAINE = '<TYPE_JONCTION>CTRAN1</TYPE_JONCTION>'
         WRITE(IFI,'(A)') CHAINE
      ENDIF
C
      DO 56 IMAI=1,2
        IF (IMAI.EQ.1) WRITE(IFI,'(A)') '<GEOM_MAILLE_1>'
        IF (IMAI.EQ.2) WRITE(IFI,'(A)') '<GEOM_MAILLE_2>'
        IF (NUMMAI(IMAI).LE.9) THEN
          WRITE(IFI,'(A,I1,A)') '<NUM>',NUMMAI(IMAI),'</NUM>'
        ELSEIF (NUMMAI(IMAI).LE.99.AND.NUMMAI(IMAI).GT.9) THEN
          WRITE(IFI,'(A,I2,A)') '<NUM>',NUMMAI(IMAI),'</NUM>'
        ELSEIF (NUMMAI(IMAI).LE.999.AND.NUMMAI(IMAI).GT.99) THEN
          WRITE(IFI,'(A,I3,A)') '<NUM>',NUMMAI(IMAI),'</NUM>'
        ENDIF
        IF (INOEUD((IMAI-1)*2+1).LE.9) THEN
          WRITE(IFI,'(A,I1,A)') '<NOEU_1>',INOEUD((IMAI-1)*2+1)
     +          ,'</NOEU_1>'
        ELSEIF (INOEUD((IMAI-1)*2+1).LE.99.AND.
     +    INOEUD((IMAI-1)*2+1).GT.9) THEN
          WRITE(IFI,'(A,I2,A)') '<NOEU_1>',INOEUD((IMAI-1)*2+1)
     +          ,'</NOEU_1>'
        ELSEIF (INOEUD((IMAI-1)*2+1).LE.999.AND.
     +    INOEUD((IMAI-1)*2+1).GT.99) THEN
          WRITE(IFI,'(A,I3,A)') '<NOEU_1>',INOEUD((IMAI-1)*2+1)
     +          ,'</NOEU_1>'
        ENDIF
        IF (INOEUD((IMAI-1)*2+2).LE.9) THEN
          WRITE(IFI,'(A,I1,A)') '<NOEU_2>',INOEUD((IMAI-1)*2+2)
     +          ,'</NOEU_2>'
        ELSEIF (INOEUD((IMAI-1)*2+2).LE.99.AND.
     +    INOEUD((IMAI-1)*2+2).GT.9) THEN
          WRITE(IFI,'(A,I2,A)') '<NOEU_2>',INOEUD((IMAI-1)*2+2)
     +          ,'</NOEU_2>'
        ELSEIF (INOEUD((IMAI-1)*2+2).LE.999.AND.
     +    INOEUD((IMAI-1)*2+2).GT.99) THEN
          WRITE(IFI,'(A,I3,A)') '<NOEU_2>',INOEUD((IMAI-1)*2+2)
     +          ,'</NOEU_2>'
        ENDIF
        IF(NOMMAI(IMAI).EQ.'MECA_POU_C_T') WRITE(IFI,'(A,A3,A)')
     +            '<TYP_ELEM>','COU','</TYP_ELEM>'
        IF(NOMMAI(IMAI).EQ.'MECA_POU_D_T') THEN
           R1(IMAI) = R1(IMAI)*2.D0
           WRITE(IFI,'(A,A3,A)') '<TYP_ELEM>','DRO','</TYP_ELEM>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<DIAM_EXT>',R1(IMAI),'</DIAM_EXT>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<EPAISSEUR>',EP1(IMAI),'</EPAISSEUR>'
        ENDIF
        IF(NOMMAI(IMAI).EQ.'MECA_POU_R_T') THEN
           WRITE(IFI,'(A,A3,A)') '<TYP_ELEM>','RED','</TYP_ELEM>'
           R1(IMAI) = R1(IMAI)*2.D0
           R2(IMAI) = R2(IMAI)*2.D0
           WRITE(IFI,'(A,E12.5,A)')
     +        '<DIAM_EXT_1>',R1(IMAI),'</DIAM_EXT_1>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<DIAM_EXT_2>',R1(IMAI),'</DIAM_EXT_2>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<EPAISSEUR_1>',EP1(IMAI),'</EPAISSEUR_1>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<EPAISSEUR_2>',EP2(IMAI),'</EPAISSEUR_2>'
        ENDIF
        IF(NOMMAI(IMAI).EQ.'MECA_POU_C_T') THEN
           R1(IMAI) = R1(IMAI)*2.D0
           WRITE(IFI,'(A,E12.5,A)')
     +        '<DIAM_EXT>',R1(IMAI),'</DIAM_EXT>'
           WRITE(IFI,'(A,E12.5,A)')
     +        '<EPAISSEUR>',EP1(IMAI),'</EPAISSEUR>'
             WRITE(IFI,'(A,E12.5,A)') '<ANGLE_COU>',ANGLE(IMAI),
     +               '</ANGLE_COU>'
             WRITE(IFI,'(A,E12.5,A)') '<RAYON_COURBURE>',RCOU(IMAI),
     +               '</RAYON_COURBURE>'
        ENDIF
        IF (IMAI.EQ.1) WRITE(IFI,'(A)') '</GEOM_MAILLE_1>'
        IF (IMAI.EQ.2) WRITE(IFI,'(A)') '</GEOM_MAILLE_2>'
  56  CONTINUE
C
C
      DO 200 IOCC = 1,NOCC
C
         WRITE(IFI,'(A)') '<CHAR>'
C
C
         CALL GETVID ( 'CHARGE', 'RESULTAT' ,IOCC,1,1, RESU, IBID)
         CALL GETVIS ( 'CHARGE', 'NUM_CHAR' ,IOCC,1,1, NUMCHA, IBID)
         IF (NUMCHA.LE.9) THEN
            WRITE(IFI,'(A,I1,A)') '<NUM_CHAR>',NUMCHA,'</NUM_CHAR>'
         ELSEIF (NUMCHA.LE.99.AND.NUMCHA.GT.9) THEN
            WRITE(IFI,'(A,I2,A)') '<NUM_CHAR>',NUMCHA,'</NUM_CHAR>'
         ELSEIF (NUMCHA.LE.999.AND.NUMCHA.GT.99) THEN
            WRITE(IFI,'(A,I3,A)') '<NUM_CHAR>',NUMCHA,'</NUM_CHAR>'
         ENDIF
         CALL GETVTX ( 'CHARGE', 'TYPE'     ,IOCC,1,1, TYPCHA, IBID)
C
C  IMPRESSION DE LA TEMPERATURE AUX NOEUDS
C
         IF (TYPCHA.EQ.'DILA') THEN
             CALL GETVR8 ( 'CHARGE', 'TEMP_NOEUD' ,IOCC,1,1, TEMPE,
     +                                IBID)
             WRITE(IFI,'(A,E12.5,A)') '<TEMP_NOEUD>',TEMPE,
     +                                              '</TEMP_NOEUD>'
         ENDIF
C
         IF (TYPCHA.EQ.'POIDS') THEN
             WRITE(IFI,'(A,A5,A)') '<TYPE>',TYPCHA,'</TYPE>'
         ELSEIF (TYPCHA.EQ.'DILA'.OR.TYPCHA.EQ.'DEPL'.OR.
     +           TYPCHA.EQ.'EFFO') THEN
             WRITE(IFI,'(A,A4,A)') '<TYPE>',TYPCHA,'</TYPE>'
         ELSEIF (TYPCHA.EQ.'CONDITIONNEL') THEN
             WRITE(IFI,'(A,A12,A)') '<TYPE>',TYPCHA,'</TYPE>'
         ELSEIF (TYPCHA.EQ.'COMBINAISON') THEN
             WRITE(IFI,'(A,A11,A)') '<TYPE>',TYPCHA,'</TYPE>'
         ELSEIF (TYPCHA.EQ.'SEISME'.OR.TYPCHA.EQ.'STRATIF') THEN
             WRITE(IFI,'(A,A6,A)') '<TYPE>',TYPCHA,'</TYPE>'
         ENDIF
         CALL GETVTX ( 'CHARGE', 'NATURE'   ,IOCC,1,1, NATCHA, IBID)
         IF (NATCHA.EQ.'PRIMAIRE') THEN
            WRITE(IFI,'(A,A8,A)') '<NATURE>',NATCHA,'</NATURE>'
         ELSEIF (NATCHA.EQ.'SECONDAIRE') THEN
            WRITE(IFI,'(A,A10,A)') '<NATURE>',NATCHA,'</NATURE>'
         ELSEIF (NATCHA.EQ.'TOTAL') THEN
            WRITE(IFI,'(A,A5,A)') '<NATURE>',NATCHA,'</NATURE>'
         ENDIF
         CALL GETVTX ( 'CHARGE', 'SIGNE'    ,IOCC,1,1, SIGCHA, IBID)
         IF (SIGCHA.EQ.'S') THEN
            WRITE(IFI,'(A,A1,A)') '<SIGNE>',SIGCHA,'</SIGNE>'
         ELSEIF (SIGCHA.EQ.'NS') THEN
            WRITE(IFI,'(A,A2,A)') '<SIGNE>',SIGCHA,'</SIGNE>'
         ENDIF
C
C   TRAITEMENT DES MOMENTS
C
         CHAM = 'EFGE_ELNO_DEPL'
         LICMP (1) = 'MT'
         LICMP (2) = 'MFY'
         LICMP (3) = 'MFZ'
         CALL RSEXCH(RESU,CHAM,1,NOCH19,IRET)
         IF (IRET.NE.0) THEN
         ENDIF
C
C   TRANSFORMATION DU CHAMELEM EN CHAMELEM SIMPLE
C
         CHACES = '&&OP0040.CES'
         CALL CELCES (NOCH19,'V',CHACES)
         CHARED = '&&OP0040.CER'
         CALL CESRED (CHACES,2,NUMMAI,3,LICMP,'V',CHARED)
C
C   IMPRESSION AU FORMAT OAR DES MOMENTS DES CHARGEMENTS
C
         CALL JEVEUO ( CHARED//'.CESD','L',JCESD)
         CALL JEVEUO ( CHARED//'.CESV','L',JCESV)
         CALL JEVEUO ( CHARED//'.CESL','L',JCESL)
C
C   IMPRESSION NOEUD 2 DE LA MAILLE 1
C
C
         NBPT = ZI(JCESD-1+5+4*(NUMMAI(1)-1)+1)
         CALL ASSERT (NBPT.EQ.2)
         NBSP = ZI(JCESD-1+5+4*(NUMMAI(1)-1)+2)
         CALL ASSERT (NBSP.EQ.1)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(1),INOE(1),1,1,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL1 = ZR(JCESV-1+IAD)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(1),INOE(1),1,2,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL2 = ZR(JCESV-1+IAD)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(1),INOE(1),1,3,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL3 = ZR(JCESV-1+IAD)
         WRITE(IFI,'(A)') '<TORSEUR_MAILLE_1>'
         WRITE(IFI,'(A,E12.5,A)') '<MX>',VAL1,'</MX>'
         WRITE(IFI,'(A,E12.5,A)') '<MY>',VAL2,'</MY>'
         WRITE(IFI,'(A,E12.5,A)') '<MZ>',VAL3,'</MZ>'
         WRITE(IFI,'(A)') '</TORSEUR_MAILLE_1>'
C
C   IMPRESSION NOEUD 1 DE LA MAILLE 2
C
         NBPT = ZI(JCESD-1+5+4*(NUMMAI(2)-1)+1)
         CALL ASSERT (NBPT.EQ.2)
         NBSP = ZI(JCESD-1+5+4*(NUMMAI(2)-1)+2)
         CALL ASSERT (NBSP.EQ.1)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(2),INOE(2),1,1,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL1 = ZR(JCESV-1+IAD)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(2),INOE(2),1,2,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL2 = ZR(JCESV-1+IAD)
         CALL CESEXI('C',JCESD,JCESL,NUMMAI(2),INOE(2),1,3,IAD)
         CALL ASSERT(IAD.GT.0)
         VAL3 = ZR(JCESV-1+IAD)
         WRITE(IFI,'(A)') '<TORSEUR_MAILLE_2>'
         WRITE(IFI,'(A,E12.5,A)') '<MX>',VAL1,'</MX>'
         WRITE(IFI,'(A,E12.5,A)') '<MY>',VAL2,'</MY>'
         WRITE(IFI,'(A,E12.5,A)') '<MZ>',VAL3,'</MZ>'
         WRITE(IFI,'(A)') '</TORSEUR_MAILLE_2>'
C
         WRITE(IFI,'(A)') '</CHAR>'
C
 200   CONTINUE
C
         WRITE(IFI,'(A)') '</TUYAUTERIE>'
C
 9999 CONTINUE

      CALL JEDEMA()
      END
