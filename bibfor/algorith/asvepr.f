      SUBROUTINE ASVEPR(LISCHA,VECELZ,TYPRES,NUMEDD)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 09/07/2012   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C
      IMPLICIT      NONE
      INCLUDE 'jeveux.h'
      CHARACTER*19  LISCHA
      CHARACTER*(*) VECELZ,NUMEDD
      CHARACTER*1   TYPRES
C
C ----------------------------------------------------------------------
C
C PREPARATION DE L'ASSEMBLAGE D'UN VECT_ELEM
C
C ----------------------------------------------------------------------
C
C
C IN  LISCHA : SD LISTE DES CHARGES
C IN  VECELE : NOM DU VECT_ELEM
C IN  TYPRES : TYPE DU RESULTAT 'R' OU 'C' (REELS OU COMPLEXES)
C IN  NUMEDD : NUME_DDL DU SYSTEME ASSEMBLE
C
C LE VACHAR CONTIENT LA LISTE DES CHAM_NO RESULTAT DE L'ASSEMBLAGE DES
C DIFFERENTS RESU_ELEM DU VECT_ELEM
C
C * POUR CHAQUE RESU_ELEM DU VECT_ELEM, ON CREE UN CHAM_NO PAR UN APPEL
C   A ASSVEC
C * SI LE VECT_ELEM EST TRUANDE (VOIR VECHME), CERTAINS DES RESU_ELEM
C   N'EN SONT PAS : CE SONT DEJA DES CHAM_NO (CHARGEMENT VECT_ASSE DANS
C   AFFE_CHAR_MECA). DANS CE CAS, ON NE L'ASSEMBLE PAS, MAIS ON LE
C   RECOPIE.
C * SI LE VECT_ELEM EST BIDON ON REND UN VACHAR BIDON CONTENANT
C     1 SEUL CHAM_NO NUL.
C     1 VECT_ELEM EST BIDON SI IL NE CONTIENT AUCUN CHAMP (LONUTI=0)
C
C ATTENTION : LE VECT_ELEM EST DETRUIT A LA FIN DE LA ROUTINE
C
C
C
C
      CHARACTER*19 VECELE,CHAMNO
      INTEGER      JVEC
      CHARACTER*24 VACHAR
      INTEGER      JVACHA
      CHARACTER*24 RESUEL
      CHARACTER*8  K8BID,NEWNOM,MODELE,TYPECH,TYPSCA
      INTEGER      IVACH,NBVACH
      INTEGER      NEQ,NBVEC
      INTEGER      IRET,IBID,IVEC,ICHAR,ITYPRS
      CHARACTER*4  TYRESL
      CHARACTER*1  TYPCHN
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- INITIALISATIONS
C
      NEWNOM = '.0000000'
      VECELE = VECELZ
      CALL ASSERT(TYPRES.EQ.'R'.OR.TYPRES.EQ.'C')
C
C --- LE VECT_ELEM EXISTE-IL ?
C
      CALL JEEXIN(VECELE//'.RELR',IRET)
      IF (IRET.EQ.0) THEN
        NBVEC = 0
      ELSE
        CALL JELIRA(VECELE//'.RELR','LONUTI',NBVEC,K8BID)
      ENDIF
C
C --- NOM DU CHAMNO
C
      CHAMNO = VECELE(1:8)//'.???????'
C
C --- NOM DU VACHAR
C
      VACHAR = VECELE(1:19)//'.CHNO'
C
C --- DESTRUCTION DU VACHAR
C
      CALL JEEXIN(VACHAR,IRET)
      IF (IRET.GT.0) THEN
        CALL JEVEUO(VACHAR,'L',JVACHA)
        CALL JELIRA(VACHAR,'LONMAX',NBVACH,K8BID)
        DO 10 IVACH = 1,NBVACH
          CALL DETRSD('CHAMP_GD',ZK24(JVACHA-1+IVACH)(1:19))
   10   CONTINUE
        CALL JEDETR(VACHAR)
      ENDIF
C
C --- CREATION DU VACHAR
C
      CALL WKVECT(VACHAR,'V V K24',MAX(NBVEC,1),JVACHA)
C
C --- SI IL N'Y A RIEN A FAIRE, ON CREE UN CHAM_NO BIDON
C
      IF (NBVEC.EQ.0) THEN
        CALL GCNCO2(NEWNOM)
        CHAMNO(10:16) = NEWNOM(2:8)
        CALL CORICH('E',CHAMNO,-2,IBID)
        CALL VTCREB(CHAMNO,NUMEDD,'V',TYPRES,NEQ)
        ZK24(JVACHA-1+1) = CHAMNO
        GOTO 99
      ENDIF
C
C --- CREER L'OBJET .RERR DU VECT_ELEM
C
      CALL DISMOI('F','NOM_MODELE',NUMEDD,'NUME_DDL',IBID,
     &            MODELE,IRET)
      CALL MEMARE('V','&&ASVEPR',MODELE,' ',' ','CHAR_MECA')
C
C --- INITIALISER L'OBJET .RELR DU VECT_ELEM
C
      CALL REAJRE('&&ASVEPR',' ','V')
      CALL JEVEUO(VECELE//'.RELR','E',JVEC)
C
C --- ASSEMBLAGE DES VECT_ELEM
C
      DO 20 IVEC = 1,NBVEC
C
C ----- NOM DU RESU_ELEM
C
        RESUEL = ZK24(JVEC-1+IVEC)
C
C ----- PREPARATION DU NOM DU CHAM_NO
C
        CALL GCNCO2(NEWNOM)
        CHAMNO(10:16) = NEWNOM(2:8)
        ZK24(JVACHA-1+IVEC) = CHAMNO
C
C ----- ENREGISTREMENT DU NUMERO DE LA CHARGE DANS LE CHAM_NO
C
        CALL CORICH('L',RESUEL,IBID ,ICHAR)
        CALL CORICH('E',CHAMNO,ICHAR,IBID )
C
C ----- TYPE DU RESU_ELEM
C
        CALL DISMOI('F','TYPE_CHAMP',RESUEL,'CHAMP',IBID,
     &              TYRESL,IBID)
        CALL ASSERT(TYRESL.EQ.'RESL'.OR.TYRESL.EQ.'NOEU')
C
C ----- SI LE RESU_ELEM EST UN VRAI RESU_ELEM (ISSU DE CALCUL)
C
        IF (TYRESL.EQ.'RESL') THEN
          CALL JEDETR('&&ASVEPR           .RELR')
          CALL REAJRE('&&ASVEPR',RESUEL,'V')
          CALL DISMOI('F','TYPE_SCA',RESUEL,'RESUELEM',IBID,
     &                TYPSCA,IBID)
          IF (TYPSCA.EQ.'R') THEN
            ITYPRS = 1
          ELSEIF (TYPSCA.EQ.'C') THEN
            ITYPRS = 2
          ELSE
            CALL ASSERT(.FALSE.)
          ENDIF
          CALL ASSVEC('V',CHAMNO,1,'&&ASVEPR           .RELR',
     &                 1.D0,NUMEDD,' ','ZERO',ITYPRS)
        ENDIF
C
C ----- SI LE RESU_ELEM EST UN FAUX RESU_ELEM (CHAM_NO)
C
        IF (TYRESL.EQ.'NOEU') THEN
          CALL LISLTC(LISCHA,ICHAR ,TYPECH)
          TYPCHN = 'R'
          IF (TYPECH.EQ.'COMP') TYPCHN = 'C'
          CALL VTCREB(CHAMNO,NUMEDD,'V',TYPCHN,NEQ)
          CALL VTCOPY(RESUEL,CHAMNO)
        ENDIF
C
  20  CONTINUE
      CALL JEDETR('&&ASVEPR           .RELR')
      CALL JEDETR('&&ASVEPR           .RERR')
C
C --- TRANSFORMATION EN COMPLEXE SI NECESSAIRE
C
      IF (TYPRES.EQ.'C') THEN
        CALL CHOR2C(LISCHA,VECELE)
      ENDIF
C
C --- DESTRUCTION DU VECT_ELEM
C
      CALL JEEXIN(VECELE//'.RELR',IRET)
      DO 40 IVEC = 1,NBVEC
        RESUEL = ZK24(JVEC-1+IVEC)
        CALL CORICH('S',RESUEL,IBID,IBID)
        CALL DETRSD('CHAMP_GD',RESUEL)
   40 CONTINUE
      CALL JEDETR(VECELE//'.RELR')
      CALL JEDETR(VECELE//'.RERR')
C
  99  CONTINUE
C
      CALL JEDEMA()
      END
