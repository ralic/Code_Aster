      SUBROUTINE ADHC00 ( NBOPT, TABENT, TABREE, TABCAR, LGCAR )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 05/10/2004   AUTEUR CIBHHLV L.VIVAN 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE GNICOLAS G.NICOLAS
C-----------------------------------------------------------------------
C TOLE CRP_20
C-----------------------------------------------------------------------
C      ADAPTATION PAR HOMARD - DECODAGE DE LA COMMANDE - PHASE 00
C      --             -                       -                --
C      DECODAGE DES OPTIONS
C-----------------------------------------------------------------------
C
      IMPLICIT NONE
C
C 0.1. ==> ARGUMENTS
C
      INTEGER NBOPT
      INTEGER TABENT(NBOPT), LGCAR(NBOPT)
C
      REAL*8 TABREE(NBOPT)
C
      CHARACTER*(*) TABCAR(NBOPT)
C
C 0.2. ==> COMMUNS
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
      INTEGER      ZI
      COMMON /IVARJE/ZI(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'ADHC00' )
C
      INTEGER NBMCF
      PARAMETER ( NBMCF = 3 )
C
      INTEGER LXLGUT
C
      INTEGER CODRET
      INTEGER IAUX, JAUX, KAUX, IOCC
      INTEGER IER
      INTEGER IFM, NIVINF
      INTEGER ADTRAV
      INTEGER NBGRMA
      INTEGER NUFICO, NUFIDO
      INTEGER MODHOM, TYPRAF, TYPDER
      INTEGER TYPCRR, TYPCRD
      INTEGER NIVMIN, NIVMAX
      INTEGER BILNBR, BILQUA, BILINT, BILCXT, BILTAI
      INTEGER CVSOLU, LGSOLU
      INTEGER ADCHNO, ADCHNU
      INTEGER NITER
      INTEGER NUMORD
      INTEGER NUMPIN, NUMOIN
      INTEGER NOSMPX
      INTEGER LGSN, LGSNP1
      INTEGER LCN, LCNP1
      INTEGER LOMN, LOMNP1
      INTEGER LMMN, LMMNP1
      INTEGER LHMN, LHMNP1
      INTEGER LLISTE
      INTEGER LNMMN, LNMMN1
      INTEGER LNMDIN
      INTEGER LNMDFR
      INTEGER LNCPIN
      INTEGER LLANGU
C
      REAL*8 CRITDE, CRITRA
      REAL*8 INST
      REAL*8 PREC
C
      CHARACTER*2 SUFN, SUFNP1
      CHARACTER*8 OMN, OMNP1
      CHARACTER*8 NCPIN
      CHARACTER*8 CRIT
      CHARACTER*8 SAUX08
      CHARACTER*16 CN, CNP1
      CHARACTER*16 MCLF(NBMCF)
      CHARACTER*16 SAUX16
      CHARACTER*24 NTRAVA
      CHARACTER*24 LIGRMA
      CHARACTER*24 NCHNOM, NCHNUM
      CHARACTER*32 NMDMN, NMDMN1
      CHARACTER*32 NMDIN
      CHARACTER*32 NMDFR
      CHARACTER*32 SAUX32
      CHARACTER*72 FMMN, FMMNP1
      CHARACTER*72 FHMN, FHMNP1
      CHARACTER*72 FLISTE
      CHARACTER*72 REP
      CHARACTER*128 LANGUE
C
C====
C 1. PREALABLES
C====
C
      CODRET = 0
C
C 1.1. ==>  MOTS-CLES FACTEURS DE LA COMMANDE
C
C                1234567890123456
      MCLF(1) = 'TRAITEMENT      '
      MCLF(2) = 'MAJ_CHAM        '
      MCLF(3) = 'ANALYSE         '
C
C 1.2. ==> L'INFO
C
      CALL INFNIV ( IFM, NIVINF )
C
C 1.3. ==> VALEURS PAR DEFAUT
C
      NITER  = 0
      CVSOLU = 0
      LNMMN  = 0
      LNMMN1 = 0
      LNMDIN = 0
      LNMDFR = 0
      TYPCRR = -1
      TYPCRD = -1
      NIVMAX = -1
      NIVMIN = -1
      LNCPIN = 0
      NBGRMA = 0
      NUFICO = 0
      NUFIDO = 0
      CRITRA = 0.D0
      CRITDE = 0.D0
C
C 1.3. ==> ALLOCATIONS DES TABLEAUX DE TRAVAIL POUR LA MEMORISATION DES
C          CHAMPS A INTERPOLER
C          A PRIORI, ON SUPPOSE QU'IL Y EN A MOINS DE 10. SI BESOIN, ON
C          ALLONGERA CES TABLEAUX.
C
      LGSOLU = 10
C               12   345678   9012345678901234
      NCHNOM = '&&'//NOMPRO//'.NOM_CHAMPS     '
      CALL WKVECT ( NCHNOM,'G V K80',LGSOLU,ADCHNO )
      CALL JEECRA ( NCHNOM,'LONUTI',LGSOLU,SAUX08 )
C               12   345678   9012345678901234
      NCHNUM = '&&'//NOMPRO//'.NUM_CHAMPS     '
      CALL WKVECT ( NCHNUM,'G V I',3*LGSOLU,ADCHNU )
      CALL JEECRA ( NCHNUM,'LONUTI',3*LGSOLU,SAUX08 )
C
C====
C 2. LE MODE OPERATOIRE
C====
C
      CALL GETFAC ( MCLF(1), IOCC )
C
      IF ( IOCC.NE.0 ) THEN
C
      CALL GETVTX ( MCLF(1), 'ADAPTATION' , 1,1,1, REP, IAUX )
      IF ( IAUX.EQ.0 ) THEN
        CALL GETVTX ( MCLF(1), 'UNIFORME', 1,1,1, REP, IAUX )
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVTX ( MCLF(1), 'INFORMATION', 1,1,1, REP, IAUX )
          IF ( IAUX.EQ.0 ) THEN
            CODRET = CODRET + 1
C
C 2.1. ==> INFORMATION
C
          ELSE
            MODHOM = 2
          ENDIF
C
C 2.2. ==> ADAPTATION UNIFORME
C
        ELSE
          MODHOM = 1
          IF ( REP.EQ.'RAFFINEMENT' ) THEN
            TYPRAF = -1
            TYPDER = 0
          ELSEIF ( REP.EQ.'DERAFFINEMENT' ) THEN
            TYPRAF = 0
            TYPDER = -1
          ELSEIF ( REP.EQ.'RIEN' ) THEN
            TYPRAF = 0
            TYPDER = 0
          ENDIF
        ENDIF
C
C 2.3. ==> ADAPTATION LIBRE
C
      ELSE
        MODHOM = 1
        IF ( REP.EQ.'RAFF_DERA' ) THEN
          TYPRAF = 1
          TYPDER = 1
        ELSEIF ( REP.EQ.'RAFFINEMENT' ) THEN
          TYPRAF = 1
          TYPDER = 0
        ELSEIF ( REP.EQ.'DERAFFINEMENT' ) THEN
          TYPRAF = 0
          TYPDER = 1
        ENDIF
      ENDIF
C
      ELSE
C
        CODRET = CODRET + 1
C
      ENDIF
C
C====
C 3. LES INFORMATIONS GENERALES
C====
C
C 3.1. ==> LANGUE DES MESSAGES DE HOMARD
C
      CALL GETVTX ( ' ', 'LANGUE', 1,1,1, LANGUE, IAUX )
      LLANGU = LXLGUT(LANGUE)
C
C 3.2. ==> LES FICHIERS LOCAUX ET LES NUMEROS D'UNITE LOGIQUE
C 3.2.1. ==> FICHIER DE CONFIGURATION
C
      CALL GETVIS ( ' ', 'UNITE_CONF', 1,1,1, NUFICO, IAUX )
C
C 3.2.2. ==> FICHIER DE DONNEES
C
      IF ( MODHOM.NE.1 ) THEN
C
        CALL GETVIS ( ' ', 'UNITE_DONN', 1,1,1, NUFIDO, IAUX )
C
      ENDIF
C
C====
C 4. POUR UNE ADAPTATION LIBRE, LES CARACTERISTIQUES DES CHAMPS
C    . L'INDICATEUR
C    . LES CHAMPS A METRE A JOUR
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
      IF ( TYPRAF.GT.0 .OR. TYPDER.GT.0 ) THEN
C
      DO 40 , KAUX = 1 , 2
C
        CALL GETFAC ( MCLF(KAUX), JAUX )
C
        DO 400 , IOCC = 1 , JAUX
C
C 4.1. ==> NOM MED DU CHAMP
C
          CALL GETVTX ( MCLF(KAUX), 'NOM_MED' , IOCC, 1, 1,
     >                  SAUX32, IAUX )
C
          IAUX = LXLGUT(SAUX32)
          IF ( KAUX.EQ.1 ) THEN
            NMDIN = SAUX32
            LNMDIN = IAUX
          ELSE
            CVSOLU = CVSOLU + 1
            IF ( CVSOLU.GT.LGSOLU ) THEN
              LGSOLU = 2*LGSOLU
              CALL JUVECA ( NCHNOM,LGSOLU )
              CALL JEVEUO ( NCHNOM,'E',ADCHNO )
              CALL JUVECA ( NCHNUM,3*LGSOLU )
              CALL JEVEUO ( NCHNUM,'E',ADCHNU )
            ENDIF
            ZK80(ADCHNO+CVSOLU-1)(1:IAUX) = SAUX32(1:IAUX)
            ZI(ADCHNU+3*CVSOLU-3) = IAUX
          ENDIF
C
C 4.2. ==> NOM DE LA COMPOSANTE DANS LE CAS DE L'INDICATEUR
C
          IF ( KAUX.EQ.1 ) THEN
            CALL GETVTX ( MCLF(KAUX), 'COMPOSANTE' , IOCC, 1, 1,
     >                    NCPIN, IAUX)
            LNCPIN = LXLGUT(NCPIN)
          ENDIF
C
C 4.3. ==> NUMERO D'ORDRE
C
          CALL GETVIS ( MCLF(KAUX), 'NUME_ORDRE', IOCC, 1, 1,
     >                  NUMORD, IAUX )
CGN       PRINT *,'=========== NUMORD : ', NUMORD, ', iaux = ',iaux
C
C 4.3.1. ==> SANS NUMERO D'ORDRE, ON CHERCHE SI UN INSTANT EST PRESENT
C
          IF ( IAUX.EQ.0 ) THEN
C
C 4.3.1.1. ==> PREPARATION
C
C                     12   345678   9012345678901234
            NTRAVA = '&&'//NOMPRO//'.LISTE_NUMO     '
C
            CALL GETVID ( MCLF(KAUX), 'RESULTAT' , IOCC, 1, 1,
     >                    SAUX08, IAUX )
C
            CALL GETVR8 ( MCLF(KAUX), 'INST', IOCC, 1, 1, INST, IAUX )
C
C 4.3.1.2. ==> AVEC UN INSTANT, ON CHERCHE LE NUMERO D'ORDRE ASSOCIE
C
            IF ( IAUX.NE.0 ) THEN
C
              CALL GETVR8 ( MCLF(KAUX), 'PRECISION', IOCC, 1, 1,
     >                      PREC, IAUX )
              CALL GETVTX ( MCLF(KAUX), 'CRITERE'  , IOCC, 1, 1,
     >                      CRIT, IAUX )
              CALL RSUTNU ( SAUX08, MCLF(KAUX), IOCC, NTRAVA, JAUX,
     >                      PREC, CRIT, IER )
C
C 4.3.1.3. ==> SANS NUMERO D'ORDRE NI INSTANT, ON CHERCHE CE QUI EST
C              PRESENT DANS LA STRUCTURE ; ON PRENDRA LE SEUL QUI
C              EXISTE
C
            ELSE
C
              CALL GETVTX ( MCLF(KAUX), 'NOM_CHAM' , IOCC, 1, 1,
     >                      SAUX16, IAUX )
C
              CALL RSCHOR ( SAUX08, SAUX16, JAUX, NTRAVA, IER )
C
            ENDIF
C
C 4.3.1.4. ==> RECUPERATION DU NUMERO D'ORDRE
C
            IF ( IER.EQ.0 ) THEN
              IF ( JAUX.EQ.1 ) THEN
                CALL JEVEUO ( NTRAVA, 'L', ADTRAV )
                NUMORD = ZI(ADTRAV)
              ELSE
                CALL UTMESS ( 'E', NOMPRO,
     >  'QUEL NUMERO D''ORDRE CHOISIR POUR LE CHAMP ? ('//SAUX08//','
     > //SAUX16//')' )
                CODRET = CODRET + 1
              ENDIF
            ELSE
              CALL UTMESS ( 'E', NOMPRO, 'PROBLEME DE DECODAGE.' )
              CODRET = CODRET + 1
            ENDIF
C
            CALL JEDETR(NTRAVA)
C
          ENDIF
C
C 4.4. ==> LE NUMERO DE PAS DE TEMPS EST IDENTIFIE AU NUMERO D'ORDRE
C
CGN         PRINT *,'================== NUMORD : ', NUMORD
          IF ( KAUX.EQ.1 ) THEN
            NUMOIN = NUMORD
            NUMPIN = NUMORD
          ELSE
            ZI(ADCHNU+3*CVSOLU-2) = NUMORD
            ZI(ADCHNU+3*CVSOLU-1) = NUMORD
          ENDIF
C
  400   CONTINUE
C
   40 CONTINUE
C
      ENDIF
C
      ENDIF
C
C====
C 5. SI ADAPTATION LIBRE, LES CRITERES
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
C 5.1. ==> CRITERE POUR LE RAFFINEMENT LIBRE
C
      IF ( TYPRAF.GT.0 ) THEN
C
        CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_ABS', 1,1,1, CRITRA, IAUX)
C
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_REL', 1,1,1, CRITRA, IAUX)
C
          IF ( IAUX.EQ.0 ) THEN
            CALL GETVR8 ( MCLF(1), 'CRIT_RAFF_PE', 1,1,1, CRITRA, IAUX)
C
            IF ( IAUX.EQ.0 ) THEN
              CALL UTMESS ( 'E', NOMPRO,
     >                      'IL FAUT LE CRITERE DE RAFFINEMENT')
              CODRET = CODRET + 1
            ELSE
              TYPCRR = 3
            ENDIF
          ELSE
            TYPCRR = 2
          ENDIF
C
        ELSE
          TYPCRR = 1
        ENDIF
C
      ENDIF
C
C 5.2. ==> CRITERE POUR LE DERAFFINEMENT LIBRE
C
      IF ( TYPDER.GT.0 ) THEN
C
        CALL GETVR8 ( MCLF(1), 'CRIT_DERA_ABS', 1,1,1, CRITDE, IAUX)
C
        IF ( IAUX.EQ.0 ) THEN
          CALL GETVR8 ( MCLF(1), 'CRIT_DERA_REL', 1,1,1, CRITDE, IAUX)
C
          IF ( IAUX.EQ.0 ) THEN
            CALL GETVR8 ( MCLF(1), 'CRIT_DERA_PE', 1,1,1, CRITDE, IAUX)
C
            IF ( IAUX.EQ.0 ) THEN
              CALL UTMESS ( 'E', NOMPRO,
     >                      'IL FAUT LE CRITERE DE DERAFFINEMENT' )
              CODRET = CODRET + 1
            ELSE
              TYPCRD = 3
            ENDIF
C
          ELSE
            TYPCRD = 2
          ENDIF
C
        ELSE
          TYPCRD = 1
        ENDIF
C
      ENDIF
C
      ENDIF
C
C====
C 6. SI ADAPTATION, LES NIVEAUX EXTREMES
C====
C
      IF ( MODHOM.EQ.1 ) THEN
C
C 6.1. ==> NIVEAU MAXIMUM POUR LE RAFFINEMENT
C
      IF ( TYPRAF.NE.0 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NIVE_MAX', 1,1,1, NIVMAX, IAUX )
C
        IF ( IAUX.NE.0 ) THEN
          IF ( NIVMAX.LE.0 ) THEN
            CALL UTMESS ( 'E', NOMPRO,
     >      'LE NIVEAU MAXIMUM DOIT ETRE STRICTEMENT POSITIF.' )
            CODRET = CODRET + 1
          ENDIF
        ENDIF
C
      ENDIF
C
C 6.2. ==> NIVEAU MINIMUM POUR LE DERAFFINEMENT
C
      IF ( TYPDER.NE.0 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NIVE_MIN', 1,1,1, NIVMIN, IAUX )
C
        IF ( IAUX.NE.0 ) THEN
          IF ( NIVMIN.LT.0 ) THEN
            CALL UTMESS ( 'E', NOMPRO,
     >      'LE NIVEAU MINIMUM DOIT ETRE POSITIF.' )
            CODRET = CODRET + 1
          ENDIF
        ENDIF
C
      ENDIF
C
C 6.3. ==> COHERENCE
C
      IF ( TYPRAF.NE.0 .AND. TYPDER.NE.0 ) THEN
C
        IF ( NIVMAX.LT.NIVMIN ) THEN
          CALL UTMESS ( 'E', NOMPRO,
     >    'LE NIVEAU MAXIMUM DOIT ETRE > AU NIVEAU MINIMUM.')
          CODRET = CODRET + 1
        ENDIF
C
      ENDIF
C
      ENDIF
C
C====
C 7. SUIVI DE FRONTIERE ?
C====
C
C 7.1. ==> SUIT-ON LA FRONTIERE ?
C
      CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_FRONTIERE' , 1,1,1,
     >              NMDFR, IAUX )
C
C 7.2. ==> SI OUI, EST-CE SELON DES GROUPES DE MAILLES ?
C
      IF ( IAUX.NE.0 ) THEN
C
        LNMDFR = LXLGUT(NMDFR)
C
        CALL GETVID ( MCLF(1), 'GROUP_MA', 1,1,1, SAUX08, IAUX )
C
        IF ( IAUX.EQ.0 ) THEN
C
          NBGRMA = 0
C
        ELSE
          NBGRMA = ABS(IAUX)
C                   12   345678   9012345678901234
          LIGRMA = '&&'//NOMPRO//'.LIST_GRMA      '
          CALL WKVECT ( LIGRMA, 'V V K8', NBGRMA, JAUX )
          CALL GETVID ( MCLF(1), 'GROUP_MA', 1,1,NBGRMA,
     >                  ZK8(JAUX), IAUX )
        ENDIF
C
      ENDIF
C
C====
C 8. QUE FAIRE DES NON SIMPLEXES ?
C====
C
      CALL GETVIS ( ' ', 'NON_SIMPLEXE' , 1,1,1, NOSMPX, IAUX )
C
C====
C 9. SI PAS DE L'INFORMATION : NUMERO DE L'ITERATION
C====
C
      IF ( MODHOM.NE.2 ) THEN
C
        CALL GETVIS ( MCLF(1), 'NITER' , 1,1,1, NITER, IAUX )
C
        IF ( IAUX.EQ.0 ) THEN
          CODRET = CODRET + 1
        ENDIF
C
      ENDIF
C
C====
C 10. L'ANALYSE
C====
C
      CALL GETFAC ( MCLF(3), IOCC )
C
      IF ( IOCC.NE.0 ) THEN
C
C 10.1. CONTROLE DES NOMBRES D'ENTITES
C
        CALL GETVTX ( MCLF(3), 'NOMBRE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILNBR = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILNBR = 0
          ENDIF
        ELSE
          BILNBR = 0
        ENDIF
C
C 10.2. ==> QUALITE DU MAILLAGE
C
        CALL GETVTX ( MCLF(3), 'QUALITE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILQUA = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILQUA = 0
          ENDIF
        ELSE
          BILQUA = 0
        ENDIF
C
C 10.3. CONTROLE DE LA CONNEXITE DU MAILLAGE
C
        CALL GETVTX ( MCLF(3), 'CONNEXITE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILCXT = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILCXT = 0
          ENDIF
        ELSE
          BILCXT = 0
        ENDIF
C
C 10.4. TAILLE DES SOUS-DOMAINES
C
        CALL GETVTX ( MCLF(3), 'TAILLE' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILTAI = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILTAI = 0
          ENDIF
        ELSE
          BILTAI = 0
        ENDIF
C
C 10.5. CONTROLE DE LA NON-INTERPENETRATION DES ELEMENTS
C
        CALL GETVTX ( MCLF(3), 'INTERPENETRATION' , 1,1,1, REP, IAUX )
        IF ( IAUX.NE.0 ) THEN
          IF ( REP(1:3).EQ.'OUI' ) THEN
            BILINT = 1
          ELSEIF ( REP(1:3).EQ.'NON' ) THEN
            BILINT = 0
          ENDIF
        ELSE
          BILINT = 0
        ENDIF
C
      ELSE
C
        BILNBR = 1
        BILQUA = 0
        BILINT = 0
        BILCXT = 0
        BILTAI = 0
C
      ENDIF
C
C====
C 11. LES NOMS MED DES MAILLAGES
C     REMARQUE : ON NE LE FAIT QU'ICI CAR ON NE CONNAIT TOUTES LES
C                DIFFERENTES OPTIONS QUE MAINTENANT
C====
C
C 11.1. ==> MAILLAGE D'ENTREE :
C            . SI INFORMATION
C            . SI ADAPTATION LIBRE
C            . SI ADAPTATION ET ITERATION = 0
C            . SI ADAPTATION ET MAJ DE SOLUTION
C
      IF ( MODHOM.EQ.2 .OR.
     >     ( MODHOM.EQ.1 .AND. ( TYPRAF.EQ.1 .OR. TYPDER.EQ.1 ) ) .OR.
     >     ( MODHOM.EQ.1 .AND. NITER.EQ.0 ) .OR.
     >     ( MODHOM.EQ.1 .AND. CVSOLU.NE.0 ) ) THEN
C
        CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_N' , 1,1,1,
     >                NMDMN, IAUX )
C
        LNMMN = LXLGUT(NMDMN)
C
      ENDIF
C
C 11.2. ==> MAILLAGE DE SORTIE : SI ADAPTATION
C
      IF ( MODHOM.EQ.1 ) THEN
C
        CALL GETVTX ( MCLF(1), 'NOM_MED_MAILLAGE_NP1' , 1,1,1,
     >                NMDMN1, IAUX )
C
        LNMMN1 = LXLGUT(NMDMN1)
C
      ENDIF
C
C====
C 12. LES NOMS DES FICHIERS
C====
C 12.1. ==> SUFFIXES EN FONCTION DU NUMERO DE L'ITERATION
C
      CALL CODENT ( NITER, 'G', SUFN )
      LGSN = LXLGUT(SUFN)
C
      CALL CODENT ( NITER+1, 'G', SUFNP1 )
      LGSNP1 = LXLGUT(SUFNP1)
C
      CN(1:LGSN) = SUFN(1:LGSN)
      LCN = LGSN + 4
      CN(LGSN+1:LCN) = '.MED'
C
      CNP1(1:LGSNP1) = SUFNP1(1:LGSNP1)
      LCNP1 = LGSNP1 + 4
      CNP1(LGSNP1+1:LCNP1) = '.MED'
C
C 12.2. ==> LA LISTE DE SORTIE
C
      FLISTE(1:6) = 'LISTE.'
      IAUX = 6 + LGSN
      FLISTE(7:IAUX) = SUFN(1:LGSN)
      IF ( MODHOM.EQ.1 ) THEN
        FLISTE(IAUX+1:IAUX+6) = '.VERS.'
        LLISTE = IAUX+6+LGSNP1
        FLISTE(IAUX+7:LLISTE) = SUFNP1(1:LGSNP1)
      ELSEIF ( MODHOM.EQ.2 ) THEN
        LLISTE = IAUX+5
        FLISTE(IAUX+1:LLISTE) = '.INFO'
      ELSE
        FLISTE(IAUX+1:IAUX+6) = '.MJSO.'
        LLISTE = IAUX+6+LGSNP1
        FLISTE(IAUX+7:LLISTE) = SUFNP1(1:LGSNP1)
      ENDIF
C
C 12.3. ==> LES FICHIERS ET LES OBJETS
C          OMN    : OBJET MAILLAGE HOMARD A L'ITERATION N
C          OMNP1  : OBJET MAILLAGE HOMARD A L'ITERATION N+1
C          LOMN OU LOMNP1 : LONGUEUR DU NOM DE L'OBJET MAILLAGE HOMARD
C          FMMN   : FICHIER MED A L'ITERATION N
C          FHMN   : FICHIER HOMARD A L'ITERATION N
C          FMMNP1 : FICHIER MED A L'ITERATION N+1
C          FHMNP1 : FICHIER HOMARD A L'ITERATION N+1
C          LYMN OU LYMNP1 : LONGUEUR DU NOM DU FICHIER DE TYPE Y
C          REMARQUE : ON DETERMINE TOUS LES NOMS ET ON FILTRERA AU
C                     MOMENT DE L'ARCHIVAGE
C
      FMMN(1:6) = 'MAILL.'
      FMMN(7:6+LCN) = CN(1:LCN)
      LMMN = LCN + 6
      LHMN= LMMN
      FHMN = FMMN
      FHMN(LHMN-2:LHMN) = 'HOM'
C
      OMN(1:3) = 'MAI'
      OMN(4:3+LGSN) = SUFN(1:LGSN)
      LOMN = LGSN + 3
C
      FMMNP1(1:6) = 'MAILL.'
      FMMNP1(7:6+LCNP1) = CNP1(1:LCNP1)
      LMMNP1 = LCNP1 + 6
      LHMNP1= LMMNP1
      FHMNP1 = FMMNP1
      FHMNP1(LHMNP1-2:LHMNP1) = 'HOM'
C
      OMNP1(1:3) = 'MAI'
      OMNP1(4:3+LGSNP1) = SUFNP1(1:LGSNP1)
      LOMNP1 = LGSNP1 + 3
C
C====
C 13. STOCKAGE DES ARGUMENTS
C====
C
C 13.1. ==> ENTIERS
C
      TABENT(1) = NUFICO
      TABENT(2) = MODHOM
      TABENT(3) = NITER
      TABENT(4) = TYPRAF
      TABENT(5) = TYPDER
      TABENT(6) = TYPCRR
      TABENT(7) = TYPCRD
      TABENT(8) = CVSOLU
      TABENT(9) = NBGRMA
      TABENT(10) = NOSMPX
      TABENT(11) = NIVMAX
      TABENT(12) = NIVMIN
      TABENT(15) = NUMPIN
      TABENT(16) = NUMOIN
      TABENT(30) = NIVINF
      TABENT(31) = BILNBR
      TABENT(32) = BILQUA
      TABENT(33) = BILCXT
      TABENT(34) = BILTAI
      TABENT(35) = BILINT
      TABENT(40) = NUFIDO
C
C 13.2. ==> CARACTERES
C
      LGCAR(1) = LLISTE
      TABCAR(1)(1:LLISTE) = FLISTE(1:LLISTE)
C
      LGCAR(6) = LNCPIN
      IF ( LNCPIN.GT.0 ) THEN
        TABCAR(6)(1:LNCPIN) = NCPIN(1:LNCPIN)
      ENDIF
C
      LGCAR(7) = LXLGUT(NCHNOM)
      TABCAR(7)(1:LGCAR(7)) = NCHNOM
      LGCAR(8) = LXLGUT(NCHNUM)
      TABCAR(8)(1:LGCAR(8)) = NCHNUM
C
      LGCAR(11) = LMMN
      TABCAR(11)(1:LMMN) = FMMN(1:LMMN)
C
      IF ( MODHOM.EQ.1 ) THEN
        LGCAR(12) = LMMNP1
        TABCAR(12)(1:LMMNP1) = FMMNP1(1:LMMNP1)
      ELSE
        LGCAR(12) = 0
      ENDIF
C
      LGCAR(19) = LHMN
      TABCAR(19)(1:LHMN) = FHMN(1:LHMN)
C
      LGCAR(21) = LOMN
      TABCAR(21)(1:LOMN) = OMN(1:LOMN)
C
      IF ( MODHOM.NE.2 ) THEN
        LGCAR(20) = LHMNP1
        TABCAR(20)(1:LHMNP1) = FHMNP1(1:LHMNP1)
        LGCAR(22) = LOMNP1
        TABCAR(22)(1:LOMNP1) = OMNP1(1:LOMNP1)
      ELSE
        LGCAR(20) = 0
        LGCAR(22) = 0
        LGCAR(24) = 0
      ENDIF
C
      LGCAR(31) = LNMMN
      IF ( LNMMN.GT.0 ) THEN
        TABCAR(31)(1:LNMMN) = NMDMN(1:LNMMN)
      ENDIF
C
      LGCAR(32) = LNMMN1
      IF ( LNMMN1.GT.0 ) THEN
        TABCAR(32)(1:LNMMN1) = NMDMN1(1:LNMMN1)
      ENDIF
C
      LGCAR(33) = LNMDIN
      IF ( LNMDIN.GT.0 ) THEN
        TABCAR(33)(1:LNMDIN) = NMDIN(1:LNMDIN)
      ENDIF
C
      LGCAR(34) = LNMDFR
      IF ( LNMDFR.GT.0 ) THEN
        TABCAR(34)(1:LNMDFR) = NMDFR(1:LNMDFR)
      ENDIF
C
      LGCAR(38) = LLANGU
      IF ( LLANGU.GT.0 ) THEN
        TABCAR(38)(1:LLANGU) = LANGUE(1:LLANGU)
      ENDIF
C
      IF ( NBGRMA.GT.0 ) THEN
        LGCAR(39) = 24
        TABCAR(39)(1:24) = LIGRMA
      ENDIF
C
C 13.3. ==> REELS
C
      TABREE(1) = CRITRA
      TABREE(2) = CRITDE
C
C====
C 14. ARRET SI PROBLEME
C====
C
      IF ( CODRET .GT. 0 ) THEN
        CALL UTMESS ('F',NOMPRO,'ERREURS CONSTATEES')
      ENDIF
C
      END
