      SUBROUTINE ALGOCG(SDSTAT,DEFICO,RESOCO,SOLVEU,MATASS,
     &                  CTCCVG)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 02/04/2012   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      CHARACTER*24 SDSTAT
      CHARACTER*24 DEFICO,RESOCO
      CHARACTER*19 MATASS,SOLVEU
      INTEGER      CTCCVG
C
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (METHODES DISCRETES - RESOLUTION)
C
C ALGO. POUR CONTACT    : GRADIENT CONJUGUE PROJETE
C ALGO. POUR FROTTEMENT : SANS
C
C ----------------------------------------------------------------------
C
C
C
C RESOLUTION DE : C.DU + AT.MU  = F
C                 A(U+DU)      <= E (= POUR LES LIAISONS ACTIVES)
C
C AVEC E = JEU COURANT (CORRESPONDANT A U/I/N)
C
C      A = MATRICE DE CONTACT
C
C      C = ( K  BT ) MATRICE DE RIGIDITE INCLUANT LES LAGRANGE
C          ( B  0  )
C
C      U = ( DEPL )
C          ( LAM  )
C
C      F = ( DL  ) DANS LA PHASE DE PREDICTION
C          ( DUD )
C
C      F = ( L - QT.SIG - BT.LAM  ) AU COURS D'UNE ITERATION DE NEWTON
C          (           0          )
C
C IN  SDSTAT : SD STATISTIQUES
C IN  DEFICO : SD DE DEFINITION DU CONTACT
C IN  RESOCO : SD DE TRAITEMENT NUMERIQUE DU CONTACT
C IN  SOLVEU : SD SOLVEUR
C IN  MATASS : NOM DE LA MATRICE DU PREMIER MEMBRE ASSEMBLEE
C OUT CTCCVG : CODE RETOUR CONTACT DISCRET
C                -1 : PAS DE CALCUL DU CONTACT DISCRET
C                 0 : CAS DU FONCTIONNEMENT NORMAL
C                 1 : NOMBRE MAXI D'ITERATIONS
C                 2 : MATRICE SINGULIERE
C
C --------------- DEBUT DECLARATIONS NORMALISEES JEVEUX ---------------
C
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      INTEGER      IFM,NIV
      INTEGER      CFDISI,CFDISD
      LOGICAL      CONJUG
      INTEGER      ILIAI,ITER,PREMAX
      INTEGER      NEQ,NBLIAC,NBLIAI
      INTEGER      GCPMAX
      CHARACTER*16 PRECON,SEARCH,PCEFFE
      CHARACTER*19 SGRADM,SGRADP,SGRPRM,SGRPRP,MUM
      INTEGER      JSGRAM,JSGRAP,JSGPRM,JSGPRP,JMUM
      CHARACTER*19  MU
      INTEGER      JMU
      CHARACTER*19 DDEPLC, DDELT
      INTEGER      JDDEPC,JDDELT
      REAL*8       R8PREM
      REAL*8       TOLE,COEFRS,CFDISR
      REAL*8       NINF,NINFPC,ALPHA,EPSI
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
      CALL INFDBG('CONTACT',IFM,NIV)
C
C --- AFFICHAGE
C
      IF (NIV.GE.2) THEN
        WRITE(IFM,*) '<CONTACT><CALC> ALGO_CONTACT   : GRADIENT '//
     &    'CONJUGUE PROJETE'
        WRITE(IFM,*) '<CONTACT><CALC> ALGO_FROTTEMENT: SANS'
      ENDIF
C
C --- INITIALISATION DES VARIABLES
C
      NBLIAI = CFDISD(RESOCO,'NBLIAI')
      NEQ    = CFDISD(RESOCO,'NEQ'   )
      CTCCVG = 0
C
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C
      MU     = RESOCO(1:14)//'.MU'
      SGRADM = RESOCO(1:14)//'.SGDM'
      SGRADP = RESOCO(1:14)//'.SGDP'
      SGRPRM = RESOCO(1:14)//'.SGPM'
      SGRPRP = RESOCO(1:14)//'.SGPP'
      MUM    = RESOCO(1:14)//'.MUM'
      CALL JEVEUO(MU    ,'E',JMU   )
      CALL JEVEUO(SGRADM,'E',JSGRAM)
      CALL JEVEUO(SGRADP,'E',JSGRAP)
      CALL JEVEUO(SGRPRM,'E',JSGPRM)
      CALL JEVEUO(SGRPRP,'E',JSGPRP)
C
C --- ACCES AUX CHAMPS DE TRAVAIL
C --- DDEPLC: INCREMENT DE SOLUTION APRES CORRECTION DU CONTACT
C --- DDELT : INCREMENT DE SOLUTION ITERATION DE CONTACT
C
      DDEPLC = RESOCO(1:14)//'.DELC'
      DDELT  = RESOCO(1:14)//'.DDEL'
C
C --- INITIALISATION DES VECTEURS DE TRAVAIL
C
      CALL JEDUPO(MU,'V',MUM   ,.FALSE.)
      CALL JEVEUO(MUM   ,'E',JMUM  )
C
C ======================================================================
C                             INITIALISATIONS
C ======================================================================
C
      ITER   = 1
      CONJUG = .FALSE.
      TOLE   = R8PREM()
      NINFPC = 0.D0
C
C --- RECUPERATION DU CRITERE DE CONVERGENCE
C
      EPSI   = CFDISR(DEFICO,'RESI_ABSO')
      COEFRS = CFDISR(DEFICO,'COEF_RESI')
      GCPMAX = 10*NBLIAI
      PREMAX = CFDISI(DEFICO,'ITER_PRE_MAXI')
      IF (CFDISI(DEFICO,'ITER_GCP_MAXI').NE.0) THEN
        GCPMAX = MAX(GCPMAX,CFDISI(DEFICO,'ITER_GCP_MAXI'))
      ENDIF
      IF (CFDISI(DEFICO,'PRE_COND').EQ.1) THEN
        PRECON = 'DIRICHLET'
      ELSE
        PRECON = 'SANS'
      ENDIF
      IF (CFDISI(DEFICO,'RECH_LINEAIRE').EQ.1) THEN
        SEARCH = 'NON_ADMISSIBLE'
      ELSE
        SEARCH = 'ADMISSIBLE'
      ENDIF
C
      IF (NIV.GE.2) THEN
        WRITE (IFM,9010) GCPMAX
      ENDIF
C
C --- INITIALISATION A PARTIR DU CHAMP DE MULTIPLICATEURS INITIAL
C
      CALL CFGCIN(RESOCO,MATASS,SOLVEU,NEQ   ,NBLIAI)
C
C ======================================================================
C                    REPRISE DE LA BOUCLE PRINCIPALE
C ======================================================================
C
  40  CONTINUE
C
      IF (NIV.EQ.2) THEN
        WRITE (IFM,*) '<CONTACT><CALC> --------------------------------'
        WRITE (IFM,*) '<CONTACT><CALC> ITERATION DE GCP = ',ITER
      END IF
C
C --- CALCUL DU SOUS-GRADIENT
C
      CALL CFGCSG(RESOCO,NEQ   ,NBLIAI,TOLE  ,NINF  )
C
C --- A-T-ON CONVERGE ?
C
      IF (NIV.EQ.2) THEN
        WRITE (IFM,9060) NINF,EPSI
      ENDIF
C
      IF (NINF.LT.EPSI) THEN
        GOTO 160
      ENDIF
C
C --- PRECONDITIONNEMENT UNIQUEMENT AU VOISINAGE DE LA SOLUTION
C --- LE VOISINAGE EST DEFINI PAR COEF_RESI
C
      IF (ITER.EQ.1) THEN
        NINFPC = COEFRS*NINF
      ENDIF
      PCEFFE = PRECON
      IF (NINFPC.GT.0.D0) THEN
        IF (NINF.GT.NINFPC) THEN
          PCEFFE = 'SANS'
        ENDIF
      ENDIF
C
C --- PRECONDITIONNEMENT
C
      CALL CFGCPC(RESOCO,MATASS,SOLVEU,NEQ   ,NBLIAI,
     &            PCEFFE,TOLE  ,PREMAX,EPSI  )
C
C --- CONJUGAISON
C
      CALL CFGCCJ(RESOCO,NBLIAI,CONJUG)
C
C --- RECHERCHE LINEAIRE: PAS D'AVANCEMENT
C
      CALL CFGCRL(RESOCO,NEQ   ,NBLIAI,MATASS,SOLVEU,
     &            ALPHA)
C
C --- PROJECTION DU PAS D'AVANCEMENT
C
      CALL CFGCPR(RESOCO,MATASS,SOLVEU,NEQ   ,NBLIAI,
     &            SEARCH,ALPHA )
C
C --- ACTUALISATION DE {DDEPLC} = {DDEPLC} - ALPHA . {DDELT}
C
      CALL JEVEUO(DDELT(1:19) //'.VALE','L',JDDELT)
      CALL JEVEUO(DDEPLC(1:19)//'.VALE','E',JDDEPC)
      CALL DAXPY(NEQ   ,-ALPHA,ZR(JDDELT),1,ZR(JDDEPC),1)
C
C --- ON VERIFIE SI L'ETAT DE CONTACT A CHANGE (ON NE CONJUGUE PAS)
C
      CONJUG = .TRUE.
      DO 90 ILIAI = 1,NBLIAI
        IF (((ZR(JMUM-1+ILIAI).LE.TOLE).AND.
     &       (ZR(JMU -1+ILIAI).GT.TOLE))
     &  .OR.((ZR(JMUM-1+ILIAI).GT.TOLE).AND.
     &       (ZR(JMU -1+ILIAI).LE.TOLE))) THEN
          CONJUG = .FALSE.
          IF (NIV.EQ.2) THEN
            WRITE (IFM,*) '<CONTACT><CALC>'//
     &        ' CHANGEMENT DE L''ETAT DE CONTACT'
          END IF
          GOTO 100
        END IF
   90 CONTINUE
  100 CONTINUE
C
C --- MISE A JOUR DES GRADIENTS ET DES DIRECTIONS DE RECHERCHE
C
      CALL DCOPY(NBLIAI,ZR(JSGRAP),1,ZR(JSGRAM),1)
      CALL DCOPY(NBLIAI,ZR(JSGPRP),1,ZR(JSGPRM),1)
      CALL DCOPY(NBLIAI,ZR(JMU),1,ZR(JMUM),1)
C
C --- ON PASSE A L'ITERATION SUIVANTE
C
      ITER = ITER + 1
C
C --- A-T-ON DEPASSE LE NOMBRE D'ITERATIONS DE CONTACT AUTORISE ?
C
      IF (ITER.GE.GCPMAX) THEN
        CTCCVG = 1
        GOTO 160
      END IF
C
      GOTO 40
C
C ======================================================================
C                            ON A CONVERGE
C ======================================================================
C
  160 CONTINUE
C
C --- ACTIVATION DES LIAISONS ET CALCUL DE LA FORCE DE CONTACT
C
      CALL CFGCAC(RESOCO,TOLE  ,NEQ   ,NBLIAI,NBLIAC)
C
C --- ETAT DES VARIABLES DE CONTROLE DU CONTACT
C
      CALL CFECRD(RESOCO,'NBLIAC',NBLIAC)
C
      IF ( NIV .GE. 2 ) THEN
        WRITE(IFM,9020) ITER
      END IF
C
C --- SAUVEGARDE DES INFOS DE DIAGNOSTIC
C
      CALL NMRVAI(SDSTAT,'CTCD_ALGO_ITER','E',ITER  )
      CALL NMRVAI(SDSTAT,'CONT_NBLIAC'   ,'E',NBLIAC)
C
      CALL JEDEMA()
C
 9010 FORMAT (' <CONTACT><CALC> DEBUT DES ITERATIONS (MAX: ',I8,')')
 9020 FORMAT (' <CONTACT><CALC> FIN DES ITERATIONS (NBR: ',I8,')')


 9060 FORMAT (' <CONTACT><CALC> NORME INFINIE DU RESIDU : ',
     &        1PE12.5,' (CRITERE: ',1PE12.5,')')
      END
