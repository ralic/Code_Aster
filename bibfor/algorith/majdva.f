      SUBROUTINE MAJDVA(NUMEDD,SDNURO,SDDYNA,VALMOI,VALPLU,
     &                  POUGD ,SOLALG)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 01/12/2008   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      CHARACTER*24  NUMEDD
      CHARACTER*19  SDDYNA,SDNURO,SOLALG(*)
      CHARACTER*24  VALMOI(8),VALPLU(8),POUGD (8)
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - UTILITAIRE - DYNAMIQUE)
C
C MET A JOUR LES ACCELERATIONS/VITESSES/ROTATIONS DANS
C LE CAS DES POUTRES EN GRANDES ROTATIONS
C
C ----------------------------------------------------------------------
C
C
C IN  NUMEDD : NUME_DDL
C IN  SDNURO : SD POUTRES EN GRANDES ROTATIONS
C IN  SDDYNA : SD DYNAMIQUE
C IN  VALMOI : VARIABLE CHAPEAU POUR ETAT EN T-
C IN  VALPLU : VARIABLE CHAPEAU POUR ETAT EN T+
C IN  POUGD  : VARIABLE CHAPEAU POUR POUTRES EN GRANDES ROTATIONS
C IN  SOLALG : VARIABLE CHAPEAU POUR INCREMENTS SOLUTIONS
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      CHARACTER*24 K24BID
      CHARACTER*19 NMCHEX
      CHARACTER*24 VITPLU,ACCPLU
      INTEGER      JVITP,JACCP
      CHARACTER*24 DDEPLA,DVITLA,DACCLA
      INTEGER      JDDEPL,JDVITE,JDACCE
      CHARACTER*24 ROMK
      INTEGER      JROMK
      INTEGER      I,ICOMP,IRAN(3),INDRO
      INTEGER      NEQ,IRET
      CHARACTER*8  K8BID
      REAL*8       THETA1(3),THETA2(3),DELDET(3)
      CHARACTER*24 DEPPLU,DEPDEL
      INTEGER      JDEPP,JDEPDE
      CHARACTER*24 DEPKM1,VITKM1,ACCKM1,ROMKM1
      INTEGER      JDEPKM,JVITKM,JACCKM,JROMKM
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- POUTRES EN GRANDES ROTATIONS
C
      CALL JEVEUO(SDNURO//'.NDRO','L',INDRO)
C
C --- INITIALISATIONS
C
      CALL DISMOI('F','NB_EQUA',NUMEDD,'NUME_DDL',NEQ,K8BID,IRET)
C
C --- DECOMPACTION VARIABLES CHAPEAUX
C
      CALL DESAGG(POUGD ,DEPKM1,VITKM1,ACCKM1,ROMKM1,
     &            ROMK  ,K24BID,K24BID,K24BID)
      CALL DESAGG(VALPLU,DEPPLU,K24BID,K24BID,K24BID,
     &            VITPLU,ACCPLU,K24BID,K24BID)
      DEPDEL = NMCHEX(SOLALG,'SOLALG','DEPDEL')
      DDEPLA = NMCHEX(SOLALG,'SOLALG','DDEPLA')
      DVITLA = NMCHEX(SOLALG,'SOLALG','DVITLA')
      DACCLA = NMCHEX(SOLALG,'SOLALG','DACCLA')
C
C --- RECUPERATION DES ADRESSES
C
      CALL JEVEUO(DDEPLA(1:19)//'.VALE','L',JDDEPL)
      CALL JEVEUO(DVITLA(1:19)//'.VALE','L',JDVITE)
      CALL JEVEUO(DACCLA(1:19)//'.VALE','L',JDACCE)
      CALL JEVEUO(DEPDEL(1:19)//'.VALE','E',JDEPDE)
      CALL JEVEUO(DEPPLU(1:19)//'.VALE','E',JDEPP )
      CALL JEVEUO(VITPLU(1:19)//'.VALE','E',JVITP )
      CALL JEVEUO(ACCPLU(1:19)//'.VALE','E',JACCP )
      CALL JEVEUO(DEPKM1(1:19)//'.VALE','E',JDEPKM)
      CALL JEVEUO(VITKM1(1:19)//'.VALE','E',JVITKM)
      CALL JEVEUO(ACCKM1(1:19)//'.VALE','E',JACCKM)
      CALL JEVEUO(ROMKM1(1:19)//'.VALE','E',JROMKM)
      CALL JEVEUO(ROMK(1:19)  //'.VALE','L',JROMK )
C
C --- MISE A JOUR DEPL/VITE/ACCE
C
      ICOMP  = 0
      DO 20 I = 1,NEQ
        IF (ZI(INDRO+I-1).EQ.0) THEN
          ZR(JDEPDE+I-1) = ZR(JDEPDE+I-1) + ZR(JDDEPL+I-1)
          ZR(JDEPP+I-1)  = ZR(JDEPP+I-1) + ZR(JDDEPL+I-1)
          ZR(JVITP+I-1)  = ZR(JVITP+I-1) + ZR(JDVITE+I-1)
          ZR(JACCP+I-1)  = ZR(JACCP+I-1) + ZR(JDACCE+I-1)
        ELSE IF (ZI(INDRO+I-1).EQ.1) THEN
          ZR(JDEPKM+I-1) = ZR(JDEPP+I-1)
          ZR(JVITKM+I-1) = ZR(JVITP+I-1)
          ZR(JACCKM+I-1) = ZR(JACCP+I-1)
          ZR(JROMKM+I-1) = ZR(JROMK+I-1)
          ICOMP         = ICOMP + 1
          IRAN(ICOMP)   = I
          DELDET(ICOMP) = ZR(JDDEPL+I-1)
          THETA1(ICOMP) = ZR(JDEPP+I-1)
          THETA2(ICOMP) = ZR(JROMK+I-1)
          IF (ICOMP.EQ.3) THEN
            ICOMP = 0
            CALL NDGROT(SDDYNA,VALMOI,VALPLU,POUGD ,SOLALG,
     &                  DELDET,THETA1,THETA2,IRAN  )
          ENDIF
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
20    CONTINUE
C
      CALL JEDEMA()
      END
