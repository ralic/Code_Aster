      SUBROUTINE NMDCEX(SDDISC,IC,ITERAT,DELTAT,LENIVO,
     &                  NBRPAS,RATIO ,RETOUR)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 26/04/2011   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT       NONE
      CHARACTER*19   SDDISC
      INTEGER        ITERAT,RETOUR,NBRPAS,LENIVO,IC
      REAL*8         RATIO,DELTAT
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - DECOUPE)
C
C DECOUPE PAR EXTRAPOLATION SUR INTERVALLE [DEBUT,ITERAT]
C
C ----------------------------------------------------------------------
C
C
C IN  SDDISC : SD DISCRETISATION
C IN  IC     : NUMERO DE L'OCCURENCE DE LA METHODE DE DECOUPAGE
C IN  ITERAT : NUMERO D'ITERATION DE NEWTON
C IN  DELTAT : INCREMENT DE TEMPS
C IN  LENIVO : NIVEAU DE SOUS-DECOUPE COURANT
C IN  DEPART : NUMERO ITERATION POUR CALCUL EXTRAPOLATION
C OUT NBRPAS : NOMBRE DE PAS A CREER
C OUT RATIO  : RATIO DE CREATION DES PAS
C OUT RETOUR : CODE RETOUR ALGORITHME EXTRAPOLATION
C                0 - ON DECOUPE
C                3 - ON AUTORISE DES ITERATIONS EN PLUS
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
      INTEGER         ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8          ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16      ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL         ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8     ZK8
      CHARACTER*16           ZK16
      CHARACTER*24                   ZK24
      CHARACTER*32                           ZK32
      CHARACTER*80                                   ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      REAL*8       ZERO,UN,DEUX
      PARAMETER   (ZERO=0.0D0, UN=1.0D0, DEUX=2.0D0)
C
      INTEGER      NBIGNO,NBFIN,DEPART,I,REGRES,IBID,JERRE
      REAL*8       VRELA,VMAXI,R8PREM,R8B,RGRELA,RGMAXI
      REAL*8       CIBLE,CIBLEN,SX,SY,SX2,SYX
      REAL*8       XDET,XA0,XA1,XX,XXBB,XN,R8BID
      INTEGER      NBITER,MXITER,MNITER
      REAL*8       VALRM(4)
      INTEGER      VALIM(2)
      CHARACTER*40 VALKM(1)
      CHARACTER*16 METHOD
      CHARACTER*8  K8B
      LOGICAL      LEXTRA
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()

C --- NOM DE LA METHODE DE SUBDIVISION (CF. NMCRSU)
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_METH',R8B,IBID,METHOD)
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_ITER_IGNO',R8B,NBIGNO,K8B)
      CALL UTDIDT('L',SDDISC,'ECHE',IC,'SUBD_ITER_FIN',R8B,NBFIN,K8B)

C --- LA METHODE UTILISE L'EXTRAPOLATION
C --- ON NE L'ACTIVE QUE SI SUBD_ITER_IGNO/SUBD_ITER_FIN OK
      LEXTRA = .FALSE.
      IF (     (METHOD.EQ.'EXTRAP_IGNO').AND.
     &         ((NBIGNO+3).LE.ITERAT) ) THEN
         LEXTRA = .TRUE.
         DEPART = NBIGNO
      ELSEIF ( (METHOD.EQ.'EXTRAP_FIN').AND.
     &         ((NBFIN+3).LE.ITERAT) ) THEN
         LEXTRA = .TRUE.
         DEPART = ITERAT - NBFIN
      ENDIF

      IF (.NOT.LEXTRA) GOTO 9999
C
C --- INITIALISATIONS
      RETOUR = 0
      CIBLEN = 0.D0
C     PAS D'ITERATION EN PLUS
      CALL NMLERR(SDDISC,'E','ITERSUP',ITERAT,R8BID,RETOUR)
C
C --- LECTURE DES INFOS SUR LES CONVERGENCES
      CALL NMLERR(SDDISC,'L','MXITER'        ,ITERAT,R8BID,MXITER)
      CALL NMLERR(SDDISC,'L','MNITER'        ,ITERAT,R8BID,MNITER)
      CALL NMLERR(SDDISC,'L','NBITER'        ,ITERAT,R8BID,NBITER)
      CALL NMLERR(SDDISC,'L','RESI_GLOB_RELA',ITERAT,RGRELA,IBID)
      CALL NMLERR(SDDISC,'L','RESI_GLOB_MAXI',ITERAT,RGMAXI,IBID)
C
C --- REGRESSION SUR GLOB_RELA OU GLOB_MAXI ?
      CALL NMLERR(SDDISC,'L','TYPE_RESI',ITERAT,R8BID,REGRES)
      CALL NMLERR(SDDISC,'L','VRELA',ITERAT,VRELA,IBID)
      CALL NMLERR(SDDISC,'L','VMAXI',ITERAT,VMAXI,IBID)
C
C --- SI REGRES=3 REGRESSION SUR GLOB_RELA ET GLOB_MAXI
C     ON COMMENCE PAR GLOB_RELA
C        SI VRELA > RGRELA : REGRES=1 REGRESSION SUR GLOB_RELA
C        SI VMAXI > RGMAXI : REGRES=2 REGRESSION SUR GLOB_MAXI
      IF  ( REGRES .EQ. 3 ) THEN
         REGRES = 0
         IF      ( VRELA .GT. RGRELA ) THEN
            REGRES = 1
         ELSE IF ( VMAXI .GT. RGMAXI ) THEN
            REGRES = 2
         ENDIF
      ENDIF
C
C --- LES CRITERES D'ERREUR SONT OK, MAIS PAS DETECTE DANS LE
C     STAT_NON_LINE. CELA PEUT SE PRODUIRE QUAND IL Y A DU CONTACT
C     AVEC DE LA REACTUALISATION GEOMETRIQUE.
C     ON SORT SANS FAIRE DE SUBDIVISION ==> RETOUR=0
      IF ( REGRES .EQ. 0 ) THEN
         VALRM(1) = VRELA
         VALRM(2) = RGRELA
         VALRM(3) = VMAXI
         VALRM(4) = RGMAXI
         VALIM(1) = ITERAT
         CALL U2MESG('I','SUBDIVISE_9',0,VALKM,1,VALIM,4,VALRM)
         RETOUR = 0
         GOTO 9999
      ENDIF
C
C     TOUTES LES ERREURS AU COURS DES ITERATIONS [0,ITERAT]
      CALL WKVECT('&&NMDCEX.ERREURS','V V R8',ITERAT+1,JERRE)
      IF      ( REGRES .EQ. 1 ) THEN
         CIBLE = RGRELA
         CALL NMLERR(SDDISC,'L','VRELA_TOUS',ITERAT,ZR(JERRE),IBID)
      ELSE IF ( REGRES .EQ. 2 ) THEN
         CIBLE = RGMAXI
         CALL NMLERR(SDDISC,'L','VMAXI_TOUS',ITERAT,ZR(JERRE),IBID)
      ENDIF
C
C --- CALCUL DE LA REGRESSION
C     ON DONNE UN POIDS DOUBLE AU 3 DERNIERS POINTS CELA REVIENT
C     A AJOUTER DES POINTS => MEILLEURE EXTRAPOLATION
      SX  = ZERO
      SY  = ZERO
      SX2 = ZERO
      SYX = ZERO
      XN  = ZERO
      DO 110 I = DEPART, ITERAT
        XX = LOG( ZR(JERRE + I) )
        IF ( I .GT. (ITERAT - 3) ) THEN
           XN   = XN  + DEUX
           SX   = SX  + DEUX*XX
           SY   = SY  + DEUX*I
           SX2  = SX2 + DEUX*(XX**2)
           SYX  = SYX + DEUX*XX*I
        ELSE
           XN   = XN  + UN
           SX   = SX  + XX
           SY   = SY  + I
           SX2  = SX2 + XX**2
           SYX  = SYX + XX*I
        ENDIF
110   CONTINUE
      XDET   = -SX**2 + SX2*XN
      XA0    =  SX2*SY - SX*SYX
      XA1    = -(SX*SY) + SYX*XN
      CALL JEDETR('&&NMDCEX.ERREURS')

      IF (XDET.LE.R8PREM()) THEN
         RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
         RETOUR   = 0
         VALIM(1) = NBRPAS
         VALIM(2) = LENIVO
         VALRM(1) = RATIO
         VALRM(2) = DELTAT
         VALRM(3) = CIBLEN
         VALRM(4) = MNITER
         IF ( REGRES .EQ. 1 ) THEN
            VALKM(1) = 'RESI_GLOB_RELA'
         ELSE
            VALKM(1) = 'RESI_GLOB_MAXI'
         ENDIF
         CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
         GOTO 9999
      ENDIF
C
C --- NOMBRE D'ITERATIONS TROUVEES
      CIBLEN = (XA0 + XA1*LOG(CIBLE) )/XDET
C
C     LA METHODE TROUVE UN NOMBRE D'ITERATION < LIMITE ITERATION
C     CELA SE PRODUIT SI ON DONNE ITER_GLOB_MAXI ET ITER_GLOB_ELAS.
C     SI ITER_GLOB_ELAS EST < ITER_GLOB_MAXI ALORS L'EXTRAPOLATION
C     QUI EST FAITE LORS DE ITER_GLOB_ELAS PEUT DONNER UN NOMBRE
C     ENTRE CES 2 VALEURS.
C     ON COMPARE PAR RAPPORT AU MIN DES 2 VALEURS ITER_GLOB
C     IL FAUT FAIRE ATTENTION AUX ARRONDIS PAR SECURITE AJOUT 20%
      IF ( (CIBLEN*1.20D0) .LT. MNITER ) THEN
         RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
         VALIM(1) = NBRPAS
         VALIM(2) = LENIVO
         VALRM(1) = RATIO
         VALRM(2) = DELTAT
         VALRM(3) = CIBLEN
         VALRM(4) = MNITER
         IF ( REGRES .EQ. 1 ) THEN
            VALKM(1) = 'RESI_GLOB_RELA'
         ELSE
            VALKM(1) = 'RESI_GLOB_MAXI'
         ENDIF
         CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
         GOTO 9999
      ENDIF

      VALIM(1) = NINT(CIBLEN)
      VALIM(2) = NBITER
      CALL U2MESI('I','SUBDIVISE_16',2,VALIM)
      IF ( CIBLEN .LT. NBITER ) THEN
         IF ( CIBLEN .LE. ITERAT ) THEN
            VALIM(1) = ITERAT
            CALL U2MESI('I','SUBDIVISE_17',1,VALIM)
         ENDIF
         RETOUR = 3
         CALL NMLERR(SDDISC,'E','ITERSUP',ITERAT,R8BID,RETOUR)
      ELSE
C
C        CALCUL DU RATIO POUR ATTEINDRE LA CIBLE
         IF (XA1.LE.R8PREM()) THEN
            RATIO    = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
            RETOUR   = 0
            VALIM(1) = NBRPAS
            VALIM(2) = LENIVO
            VALRM(1) = RATIO
            VALRM(2) = DELTAT
            VALRM(3) = CIBLEN
            VALRM(4) = NBITER
            IF ( REGRES .EQ. 1 ) THEN
               VALKM(1) = 'RESI_GLOB_RELA'
            ELSE
               VALKM(1) = 'RESI_GLOB_MAXI'
            ENDIF
            CALL U2MESG('I','SUBDIVISE_11',1,VALKM,2,VALIM,4,VALRM)
            GOTO 9999
         ENDIF
         IF ( (CIBLEN-NBITER) .LE. (-10.0D0*XA1/XDET) ) THEN
            RATIO = EXP( (CIBLEN-NBITER)*XDET/XA1 )
         ELSE
            RATIO = EXP( -10.0D0 )
         ENDIF
         RATIO = 0.48485D0*RATIO
         XXBB = ( -UN + (UN+24.0D0/RATIO)**0.5D0 )/3.0D0
         IF ( XXBB .LT. 2.0D0 ) THEN
            NBRPAS = 2
            RATIO  = 0.50D0
         ELSE
            NBRPAS = NINT( XXBB )
         ENDIF
         VALIM(1) = NBRPAS
         VALIM(2) = LENIVO
         VALRM(1) = RATIO
         VALRM(2) = DELTAT
         CALL U2MESG('I','SUBDIVISE_18',0,VALKM,2,VALIM,2,VALRM)
      ENDIF
C
9999  CONTINUE
      CALL JEDEMA()
      END
