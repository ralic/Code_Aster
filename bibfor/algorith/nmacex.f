      SUBROUTINE NMACEX(SDDISC,ITERAT,LEXTRA,VALEXT)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 02/04/2012   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      CHARACTER*19 SDDISC
      INTEGER      ITERAT
      LOGICAL      LEXTRA
      REAL*8       VALEXT(4)
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - GESTION DES EVENEMENTS)
C
C EXTRAPOLATION LINEAIRE DES RESIDUS
C
C ----------------------------------------------------------------------
C
C
C IN  SDDISC : SD DISCRETISATION TEMPORELLE
C IN  ITERAT : NUMERO D'ITERATION DE NEWTON
C OUT LEXTRA : .TRUE. SI EXTRAPOLATION OK
C OUT VALEXT : VALEURS DE L'EXTRAPOLATION (XA0 + ITER*XA1) / XDET
C               VALEXT(1): XA0
C               VALEXT(2): XA1
C               VALEXT(3): XDET
C               VALEXT(4): CRESI (RESIDU CIBLE)
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      INTEGER      IBID,REGRES,DEPART,JVRESI
      REAL*8       CRESI,CRELA,CMAXI
      REAL*8       VRELA,VMAXI
      REAL*8       R8PREM,R8BID
      REAL*8       XA0,XA1,XDET
      INTEGER      NBITER,MNITER,MXITER
      INTEGER      NBIGNO
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- INITIALISATIONS
C
      REGRES    = 0
      LEXTRA    = .FALSE.
      VALEXT(1) = 0.D0
      VALEXT(2) = 0.D0
      VALEXT(3) = 0.D0
      VALEXT(4) = 0.D0
C
C --- AFFICHAGE
C
      CALL U2MESS('I','EXTRAPOLATION_1')
C
C --- LECTURE DES INFOS SUR LES CONVERGENCES
C
      CALL NMLERR(SDDISC,'L','MXITER'        ,R8BID ,MXITER)
      CALL NMLERR(SDDISC,'L','MNITER'        ,R8BID ,MNITER)
      CALL NMLERR(SDDISC,'L','NBITER'        ,R8BID ,NBITER)
      CALL NMLERR(SDDISC,'L','RESI_GLOB_RELA',CRELA ,IBID  )
      CALL NMLERR(SDDISC,'L','RESI_GLOB_MAXI',CMAXI ,IBID  )
C
C --- REGRESSION SUR GLOB_RELA OU GLOB_MAXI ?
C
      CALL NMLERR(SDDISC,'L','TYPE_RESI'     ,R8BID ,REGRES)
      CALL NMLERE(SDDISC,'L','VRELA'         ,ITERAT,VRELA )
      CALL NMLERE(SDDISC,'L','VMAXI'         ,ITERAT,VMAXI )
C
C --- SI REGRES=3 ON DOIT FAIRE LA REGRESSION SUR LES 2, MAIS ON
C --- COMMENCE PAR LA FAIRE SUR GLOB_RELA
C --- SI VRELA > RGRELA ON MET REGRES=1 POUR FAIRE LA REGRESSION
C ---  SUR GLOB_RELA
C --- SI VMAXI > RGMAXI ON MET REGRES=2 POUR FAIRE LA REGRESSION
C ---  SUR GLOB_MAXI
C
      IF  ( REGRES .EQ. 3 ) THEN
        REGRES = 0
        IF      ( VRELA .GT. CRELA ) THEN
          REGRES = 1
        ELSE IF ( VMAXI .GT. CMAXI ) THEN
          REGRES = 2
        ENDIF
      ENDIF
C
C --- LES CRITERES D'ERREUR SONT OK, MAIS PAS DETECTE DANS LE
C --- STAT_NON_LINE -> NI GLOB_RELA, NI GLOB_MAXI !
C
      IF ( REGRES .EQ. 0 ) THEN
        CALL U2MESS('A','EXTRAPOLATION_2')
        LEXTRA = .FALSE.
        GOTO 999
      ENDIF
C
C --- PARAMETRES DE LA METHODE D'EXTRAPOLATION
C
      NBIGNO = 3
C
C --- ASSEZ D'ITERATIONS POUR FAIRE L'EXTRAPOLATION ?
C
      IF ((NBIGNO+3).LE.ITERAT) THEN
        DEPART = NBIGNO
      ELSE
        LEXTRA = .FALSE.
        CALL U2MESS('I','EXTRAPOLATION_3')
        GOTO 999
      ENDIF
C
C --- TOUTES LES RESIDUS AU COURS DES ITERATIONS [0,ITERAT]
C
      CALL WKVECT('&&NMACEX.ERREURS','V V R8',ITERAT+1,JVRESI)
      IF      ( REGRES .EQ. 1 ) THEN
        CRESI = CRELA
        CALL NMLERE(SDDISC,'L','VRELA_TOUS',ITERAT,ZR(JVRESI))
      ELSE IF ( REGRES .EQ. 2 ) THEN
        CRESI = CMAXI
        CALL NMLERE(SDDISC,'L','VMAXI_TOUS',ITERAT,ZR(JVRESI))
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- CALCUL DE L'EXTRAPOLATION LINEAIRE
C
      CALL NMDCRG(DEPART,ITERAT,ZR(JVRESI),XA0   ,XA1   ,
     &            XDET  )
      CALL JEDETR('&&NMACEX.ERREURS')
C
C --- EXTRAPOLATION REUSSIE ?
C
      IF (XDET.LE.R8PREM()) THEN
        CALL U2MESS('I','EXTRAPOLATION_10')
        LEXTRA = .FALSE.
      ELSE
        VALEXT(1) = XA0
        VALEXT(2) = XA1
        VALEXT(3) = XDET
        VALEXT(4) = CRESI
        LEXTRA = .TRUE.
      ENDIF
C
 999  CONTINUE
C
      CALL JEDEMA()
      END
