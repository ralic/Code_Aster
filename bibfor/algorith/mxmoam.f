      SUBROUTINE MXMOAM(SDDYNA,RESULT,INSTAM)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 18/03/2008   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE BOYERE E.BOYERE
C
      IMPLICIT     NONE
      CHARACTER*8  RESULT
      CHARACTER*19 SDDYNA
      REAL*8       INSTAM
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - EXPLICITE)
C
C
C
C ----------------------------------------------------------------------
C
C
C IN  SDDYNA : SD DEDIEE A LA DYNAMIQUE (CF NDLECT)
C IN  RESULT : SD RESULTAT
C IN  INSTAM : INSTANT COURANT
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      CHARACTER*32       JEXNUM
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      COMPLEX*16   CBID
      REAL*8       PREC,EPS0
      LOGICAL      NDYNLO
      INTEGER      NBMD,NBMG,NEQ,NBMODE,NBMAX,NBRG,NBAG,NFONC
      INTEGER      NBINST,NUMA
      INTEGER      IADRIF,IDDEEQ,JVALM,JBASMO,JVAL
      INTEGER      JACCGM,JACCGP,JVITGM,JVITGP,JDEPGM,JDEPGP
      INTEGER      JRIGGE,JAMOGE,JFONGE,JLIFGE,JFORGE,JFGE
      INTEGER      JNBPA,JINST0,JRESTD,JRESTV,JRESTA
      INTEGER      LDBLO,LDBLO1,LDBLO2
      INTEGER      IBID,IRET,NM,NF,NL,LPAR,I,J,N,NBR
      CHARACTER*8  K8BID
      CHARACTER*8  MODMEC, MAGENE, AMGENE, RIGENE
      CHARACTER*14 NUMDDL
      CHARACTER*19 RESU, RESU1, RESU2, LISINS
      CHARACTER*24 DEEQ,KPRMO, NDYNKK
      CHARACTER*24 MATRIC, NOMCHA
      CHARACTER*24 EXPL
      INTEGER      JEXPL
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()

      IF (NDYNLO(SDDYNA,'PROJ_MODAL')) THEN
        KPRMO  = NDYNKK(SDDYNA,'PROJ_MODAL')
      ELSE
        GOTO 9999
      ENDIF

      CALL GETVID('PROJ_MODAL','MODE_MECA',1,1,1,MODMEC,NBMD)
      CALL GETVID('PROJ_MODAL','MASS_GENE',1,1,1,MAGENE,NBMG)
C
C --- ACCES SD DYNAMIQUE
C
      EXPL = SDDYNA(1:15)//'.EXPL_MOD'
      CALL JEVEUO(EXPL,'E',JEXPL)

      IF (NBMG.NE.0) THEN
        GOTO 9998
      ENDIF
C
C --- INFORMATIONS SUR MATRICE DES MODES MECANIQUES
C
      CALL JEVEUO(MODMEC//'           .REFD','L',IADRIF)
      MATRIC =  ZK24(IADRIF)(1:8)
      CALL DISMOI('F','NOM_NUME_DDL',MATRIC,'MATR_ASSE',IBID  ,
     &            NUMDDL,IRET)
      DEEQ = NUMDDL//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
      CALL DISMOI('F','NB_EQUA'     ,MATRIC,'MATR_ASSE',NEQ   ,
     &            K8BID ,IRET)
C
C --- NOMBRE DE MODES
C
      CALL JELIRA(MODMEC//'           .ORDR','LONMAX',NBMODE,K8BID)
      CALL GETVIS('PROJ_MODAL','NB_MODE',1,1,1,NBMAX,NM)
      NBMODE = MIN(NBMODE,NBMAX)
C
C --- CREATION MASSES GENERALISEES
C
      CALL WKVECT(KPRMO(1:19)//'.MASG','V V R',NBMODE,JVALM)
      DO 10 I = 1,NBMODE
        CALL RSADPA(MODMEC,'L',1,'MASS_GENE',I,0,LPAR,K8BID)
        ZR(JVALM+I-1) = ZR(LPAR)
 10   CONTINUE
C
C --- CREATION BASE MODALE
C
      CALL WKVECT(KPRMO(1:19)//'.BASM','V V R',NBMODE*NEQ,JBASMO)
      DO 61 I=1,NBMODE
        CALL RSEXCH(MODMEC,'DEPL',I,NOMCHA,IRET)
        CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
        CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(I-1)*NEQ),1)
        CALL ZERLAG(ZR(JBASMO+(I-1)*NEQ),NEQ,ZI(IDDEEQ))
 61   CONTINUE
      GOTO 9999
C
 9998 CONTINUE
C
C --- INFORMATIONS SUR MATRICE DES MODES MECANIQUES
C
      CALL JEVEUO(MODMEC//'           .REFD','L',IADRIF)
      NUMDDL =  ZK24(IADRIF+3)(1:14)
      DEEQ   = NUMDDL//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
      CALL DISMOI('F','NB_EQUA',NUMDDL,'NUME_DDL',NEQ,K8BID,IRET)
C
C --- NOMBRE DE MODES
C
      CALL JELIRA(MODMEC//'           .ORDR','LONMAX',NBMODE,K8BID)
      CALL GETVIS('PROJ_MODAL','NB_MODE',1,1,1,NBMAX,NM)
      NBMODE = MIN(NBMODE,NBMAX)
C
      CALL GETVID('PROJ_MODAL','RIGI_GENE',1,1,1,RIGENE,NBRG)
      CALL GETVID('PROJ_MODAL','AMOR_GENE',1,1,1,AMGENE,NBAG)
      CALL GETFAC('EXCIT_GENE',NFONC)
      CALL WKVECT(KPRMO(1:19)//'.MASG','V V R',NBMODE,JVALM)
      CALL WKVECT(KPRMO(1:19)//'.AGEM','V V R',NBMODE,JACCGM)
      CALL WKVECT(KPRMO(1:19)//'.AGEP','V V R',NBMODE,JACCGP)
      CALL WKVECT(KPRMO(1:19)//'.VGEM','V V R',NBMODE,JVITGM)
      CALL WKVECT(KPRMO(1:19)//'.VGEP','V V R',NBMODE,JVITGP)
      CALL WKVECT(KPRMO(1:19)//'.DGEM','V V R',NBMODE,JDEPGM)
      CALL WKVECT(KPRMO(1:19)//'.DGEP','V V R',NBMODE,JDEPGP)
      CALL WKVECT(KPRMO(1:19)//'.RIGG','V V R',NBMODE*NBMODE,JRIGGE)
      CALL WKVECT(KPRMO(1:19)//'.AMOG','V V R',NBMODE*NBMODE,JAMOGE)
      CALL WKVECT(KPRMO(1:19)//'.BASM','V V R',NBMODE*NEQ,JBASMO)
      IF (NFONC.NE.0) THEN
        CALL WKVECT(KPRMO(1:19)//'.FONG','V V K24',NFONC,JFONGE)
        CALL WKVECT('&&LIFOGE','V V K24',NFONC,JLIFGE)
        CALL WKVECT(KPRMO(1:19)//'.FORG','V V R',NFONC*NBMODE,JFORGE)
        DO 11 N=1,NFONC
          CALL GETVID('EXCIT_GENE','FONC_MULT',N,1,1,
     &                ZK24(JFONGE+N-1),NF)
          CALL GETVID('EXCIT_GENE','VECT_GENE',N,1,1,
     &                ZK24(JLIFGE+N-1),NF)
          CALL JEVEUO(ZK24(JLIFGE+N-1)(1:19)//'.VALE','L',JFGE)
          DO 12 I=1,NBMODE
            ZR(JFORGE+(N-1)*NBMODE+I-1) = ZR(JFGE+I-1)
 12       CONTINUE
 11     CONTINUE
      ENDIF
      CALL GETVID('ARCHIVAGE','LIST_INST',1,1,1,LISINS,NL)
      IF (NL.EQ.0) CALL GETVID('INCREMENT','LIST_INST',1,1,1,LISINS,NL)
      CALL JEVEUO(LISINS//'.VALE','L',JINST0)
      CALL JEVEUO(LISINS//'.NBPA','L',JNBPA)
      NBINST = ZI(JNBPA)
      CALL JEEXIN(RESULT(1:8)//'           .DGEN',IRET)
C
      IF (IRET.EQ.0) THEN
        NUMA = 0

        CALL WKVECT(RESULT(1:8)//'           .DGEN','G V R',
     &              NBINST*NBMODE,JRESTD)
        CALL WKVECT(RESULT(1:8)//'           .VGEN','G V R',
     &              NBINST*NBMODE,JRESTV)
        CALL WKVECT(RESULT(1:8)//'           .AGEN','G V R',
     &              NBINST*NBMODE,JRESTA)
        CALL R8INIR(NBMODE,0.D0,ZR(JACCGM),1)
        CALL R8INIR(NBMODE,0.D0,ZR(JACCGP),1)
        CALL R8INIR(NBMODE,0.D0,ZR(JVITGM),1)
        CALL R8INIR(NBMODE,0.D0,ZR(JVITGP),1)
        CALL R8INIR(NBMODE,0.D0,ZR(JDEPGM),1)
        CALL R8INIR(NBMODE,0.D0,ZR(JDEPGP),1)
      ELSE
        PREC = 1.D-6
        EPS0 = 1.D-12
        IF (ABS(INSTAM).GT.EPS0) THEN
          CALL RSORAC(RESULT,'INST',IBID,INSTAM,K8BID,CBID,PREC,
     &                'RELATIF',NUMA,1,NBR)
        ELSE
          CALL RSORAC(RESULT,'INST',IBID,INSTAM,K8BID,CBID,EPS0,
     &                'ABSOLU',NUMA,1,NBR)
        ENDIF
        CALL JUVECA(RESULT(1:8)//'           .DGEN',NBINST*NBMODE)
        CALL JUVECA(RESULT(1:8)//'           .VGEN',NBINST*NBMODE)
        CALL JUVECA(RESULT(1:8)//'           .AGEN',NBINST*NBMODE)
        CALL JEVEUO(RESULT(1:8)//'           .DGEN','L',JRESTD)
        CALL JEVEUO(RESULT(1:8)//'           .VGEN','L',JRESTV)
        CALL JEVEUO(RESULT(1:8)//'           .AGEN','L',JRESTA)
        CALL DCOPY(NBMODE,ZR(JRESTD+(NUMA-1)*NBMODE),1,ZR(JDEPGM),1)
        CALL DCOPY(NBMODE,ZR(JRESTD+(NUMA-1)*NBMODE),1,ZR(JDEPGP),1)
        CALL DCOPY(NBMODE,ZR(JRESTV+(NUMA-1)*NBMODE),1,ZR(JVITGM),1)
        CALL DCOPY(NBMODE,ZR(JRESTV+(NUMA-1)*NBMODE),1,ZR(JVITGP),1)
        CALL DCOPY(NBMODE,ZR(JRESTA+(NUMA-1)*NBMODE),1,ZR(JACCGM),1)
        CALL DCOPY(NBMODE,ZR(JRESTA+(NUMA-1)*NBMODE),1,ZR(JACCGP),1)
      ENDIF
      ZI(JEXPL+1-1) = NUMA
C
C --- ALLOCATION VECTEUR DE TRAVAIL
C
      RESU = MAGENE
      CALL JEVEUO(JEXNUM(RESU//'.VALM',1),'L',LDBLO)
      DO 20 I=1,NBMODE
        ZR(JVALM+I-1) = ZR(LDBLO+I-1)
        CALL RSEXCH(MODMEC,'DEPL',I,NOMCHA,IRET)
        CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
C
C ----- CALCUL PRODUIT MATRICE DEFORMEE
C
        CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(I-1)*NEQ),1)
C
C     --- MISE A ZERO DES DDL DE LAGRANGE
        CALL ZERLAG(ZR(JBASMO+(I-1)*NEQ),NEQ,ZI(IDDEEQ))
 20   CONTINUE
C
C
C --- RECUPERATION DE LA STRUCTURE DE LA MATR_ASSE_GENE
C
      RESU1 = RIGENE
      CALL JEVEUO(JEXNUM(RESU1//'.VALM',1),'L',LDBLO1)
      IF (NBAG.NE.0) THEN
        RESU2 = AMGENE
        CALL JEVEUO(JEXNUM(RESU2//'.VALM',1),'L',LDBLO2)
      ELSE
        CALL R8INIR(NBMODE*NBMODE,0.D0,ZR(JAMOGE),1)
      ENDIF
C
C        BOUCLE SUR LES COLONNES DE LA MATRICE ASSEMBLEE
C
      DO 30 I = 1 , NBMODE
C
C --------- BOUCLE SUR LES INDICES VALIDES DE LA COLONNE I
C
        DO 40 J = 1 , I
          ZR(JRIGGE+(I-1)*NBMODE+J-1)=ZR(LDBLO1+I*(I-1)/2+J-1)
          ZR(JRIGGE+(J-1)*NBMODE+I-1)=ZR(LDBLO1+I*(I-1)/2+J-1)
          IF (NBAG.NE.0) THEN
            ZR(JAMOGE+(I-1)*NBMODE+J-1)=ZR(LDBLO2+I*(I-1)/2+J-1)
            ZR(JAMOGE+(J-1)*NBMODE+I-1)=ZR(LDBLO2+I*(I-1)/2+J-1)
          ENDIF
 40     CONTINUE
 30   CONTINUE
C
 9999 CONTINUE
      CALL JEDEMA()
      END
