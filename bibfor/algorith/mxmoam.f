      SUBROUTINE MXMOAM(SDDYNA,NBMODP)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 21/09/2011   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT     NONE
      CHARACTER*19 SDDYNA
      INTEGER      NBMODP
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (ALGORITHME - EXPLICITE)
C
C PROJECTION MODALE EN EXPLICITE
C
C ----------------------------------------------------------------------
C
C
C IN  SDDYNA : SD DEDIEE A LA DYNAMIQUE (CF NDLECT)
C OUT NBMODP : NOMBRE DE MODES DE PROJECTION
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      CHARACTER*32       JEXNUM
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      INTEGER      NBMD,NBMG,NEQ,NBMAX,NBRG,NBAG
      INTEGER      NDYNIN,NBGENE
      INTEGER      IDDEEQ,JVAL
      INTEGER      JLIFGE,JFGE
      INTEGER      LDBLO,LDBLO1,LDBLO2
      INTEGER      IMODE,IFONC,IMODE2
      INTEGER      IRET,IBID,NF,LPAR,VALI(3)
      REAL*8       R8BID
      CHARACTER*8  K8BID
      CHARACTER*8  MODMEC,MAGENE,AMGENE,RIGENE
      CHARACTER*14 NUMDDL
      CHARACTER*19 FMODAL,VALFON
      INTEGER      JFMODA,JVALFO
      CHARACTER*19 DEPGEM,VITGEM,ACCGEM
      INTEGER      JDEPGM,JVITGM,JACCGM
      CHARACTER*19 DEPGEP,VITGEP,ACCGEP
      INTEGER      JDEPGP,JVITGP,JACCGP  
      CHARACTER*19 BASMOD
      INTEGER      JBASMO
      CHARACTER*19 RIGGEN,MASGEN,AMOGEN,FONGEN,FORGEN
      INTEGER      JRIGGE,JMASGE,JAMOGE,JFONGE,JFORGE  
      CHARACTER*19 ACCGCN
      INTEGER      JACCCN  
      CHARACTER*24 DEEQ
      CHARACTER*24 NOMCHA
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- NOM DES OBJETS POUR PROJECTION MODALE
C
      CALL NDYNKK(SDDYNA,'PRMO_DEPGEM',DEPGEM)
      CALL NDYNKK(SDDYNA,'PRMO_VITGEM',VITGEM)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGEM',ACCGEM)
      CALL NDYNKK(SDDYNA,'PRMO_DEPGEP',DEPGEP)
      CALL NDYNKK(SDDYNA,'PRMO_VITGEP',VITGEP)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGEP',ACCGEP)
      CALL NDYNKK(SDDYNA,'PRMO_BASMOD',BASMOD)
      CALL NDYNKK(SDDYNA,'PRMO_MASGEN',MASGEN)
      CALL NDYNKK(SDDYNA,'PRMO_AMOGEN',AMOGEN)            
      CALL NDYNKK(SDDYNA,'PRMO_RIGGEN',RIGGEN)      
      CALL NDYNKK(SDDYNA,'PRMO_FONGEN',FONGEN)
      CALL NDYNKK(SDDYNA,'PRMO_FORGEN',FORGEN)
      CALL NDYNKK(SDDYNA,'PRMO_ACCGCN',ACCGCN)
      CALL NDYNKK(SDDYNA,'PRMO_VALFON',VALFON)
      CALL NDYNKK(SDDYNA,'PRMO_FMODAL',FMODAL)            
C
C --- MATRICE DES MODES MECA
C
      CALL GETVID('PROJ_MODAL','MODE_MECA',1,IARG,1,MODMEC,NBMD) 
      IF (NBMD.EQ.0) THEN
        CALL ASSERT(.FALSE.)
      ENDIF 
C
C --- MASSE, RIGIDITE ET AMORTISSEMENT GENERALISES
C
      CALL GETVID('PROJ_MODAL','MASS_GENE',1,IARG,1,MAGENE,NBMG  )      
      CALL GETVID('PROJ_MODAL','RIGI_GENE',1,IARG,1,RIGENE,NBRG  )
      CALL GETVID('PROJ_MODAL','AMOR_GENE',1,IARG,1,AMGENE,NBAG  )
C
C --- IL FAUT MASS_GENE _ET_ RIGI_GENE (VOIR CAPY)
C      
      IF ((NBMG.GT.0).AND.(NBRG.EQ.0)) THEN
        CALL ASSERT(.FALSE.)
      ENDIF       
C
C --- INFORMATIONS SUR MATRICE DES MODES MECANIQUES
C
      CALL MGINFO(MODMEC,NUMDDL,NBMODP,NEQ   )
      DEEQ = NUMDDL//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
C
C --- NOMBRE DE MODES
C
      CALL GETVIS('PROJ_MODAL','NB_MODE',1,IARG,1,NBMAX,IBID  )
      IF (NBMAX.NE.NBMODP) THEN
        VALI(1) = NBMODP
        VALI(2) = NBMAX
        VALI(3) = MIN(NBMODP,NBMAX)
        CALL U2MESG('I','MECANONLINE5_29',0,K8BID,3,VALI,0,R8BID)
        NBMODP = MIN(NBMODP,NBMAX)
      ENDIF
C
C --- CREATION VECTEUR DES FORCES MODALES
C        
      CALL WKVECT(FMODAL,'V V R',NBMODP,JFMODA)      
C
C --- CREATION MASSES GENERALISEES   
C     
      CALL WKVECT(MASGEN,'V V R',NBMODP,JMASGE)       
C
C --- CREATION BASE MODALE
C
      CALL WKVECT(BASMOD,'V V R',NBMODP*NEQ,JBASMO)       
C
C --- SI MASS_GENE NON DONNE  
C     
      IF (NBMG.EQ.0) THEN
C
C ---   ON RECUPERE MODES DANS MODE_MECA 
C        
        DO 61 IMODE = 1,NBMODP
          CALL RSEXCH(MODMEC,'DEPL',IMODE,NOMCHA,IRET)
          CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
          CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(IMODE-1)*NEQ),1)
          CALL ZERLAG(ZR(JBASMO+(IMODE-1)*NEQ),NEQ,ZI(IDDEEQ))
 61     CONTINUE  
C
C ---   ON RECUPERE MASSES GENERALISEES DANS MODE_MECA 
C  
        DO 10 IMODE = 1,NBMODP
          CALL RSADPA(MODMEC,'L',1,'MASS_GENE',IMODE,0,LPAR,K8BID)
          ZR(JMASGE+IMODE-1) = ZR(LPAR)
 10     CONTINUE
C
C --- CREATION ACCELERATION DE REFERENCE
C
        CALL WKVECT(ACCGCN,'V V R',NBMODP,JACCCN) 
      ELSE
C
C --- CREATION DEPL/VITE/ACCE GENERALISES T- ET T+
C        
        CALL WKVECT(ACCGEM,'V V R',NBMODP,JACCGM)
        CALL WKVECT(ACCGEP,'V V R',NBMODP,JACCGP)
        CALL WKVECT(VITGEM,'V V R',NBMODP,JVITGM)
        CALL WKVECT(VITGEP,'V V R',NBMODP,JVITGP)
        CALL WKVECT(DEPGEM,'V V R',NBMODP,JDEPGM)
        CALL WKVECT(DEPGEP,'V V R',NBMODP,JDEPGP)
C
C --- ON RECUPERE MODES DANS MODE_MECA 
C        
        DO 67 IMODE = 1,NBMODP
          CALL RSEXCH(MODMEC,'DEPL',IMODE,NOMCHA,IRET)
          CALL JEVEUO(NOMCHA(1:19)//'.VALE','L',JVAL)
          CALL DCOPY(NEQ,ZR(JVAL),1,ZR(JBASMO+(IMODE-1)*NEQ),1)
          CALL ZERLAG(ZR(JBASMO+(IMODE-1)*NEQ),NEQ,ZI(IDDEEQ))
 67     CONTINUE                           
C
C --- CREATION RIGIDITES GENERALISEES   
C                            
        CALL WKVECT(RIGGEN,'V V R',NBMODP*NBMODP,JRIGGE)
C
C --- CREATION AMORTISSEMENTS GENERALISES   
C      
        CALL WKVECT(AMOGEN,'V V R',NBMODP*NBMODP,JAMOGE)    
C
C --- CREATION FORCES/FONC_MULT GENERALISEES
C        
        NBGENE = NDYNIN(SDDYNA,'NBRE_EXCIT_GENE')
        IF (NBGENE.NE.0) THEN
          CALL WKVECT(FONGEN,'V V K24',NBGENE,JFONGE)
          CALL WKVECT('&&MXMOAM.LIFOGE','V V K24',NBGENE,JLIFGE)
          CALL WKVECT(FORGEN,'V V R',NBGENE*NBMODP,JFORGE)
        ENDIF
C
C --- CREATION VECTEUR DE RESOLUTION FORCES 
C        
        IF (NBGENE.NE.0) THEN
          CALL WKVECT(VALFON,'V V R',NBGENE,JVALFO)
        ENDIF      
C
C --- RECUPERATION MASSES GENERALISEES   
C     
        CALL JEVEUO(JEXNUM(MAGENE//'           .VALM',1),'L',LDBLO)
        DO 20 IMODE=1,NBMODP
          ZR(JMASGE+IMODE-1) = ZR(LDBLO+IMODE-1)
  20    CONTINUE      
C
C --- RECUPERATION RIGIDITES GENERALISEES   
C                         
        CALL JEVEUO(JEXNUM(RIGENE//'           .VALM',1),'L',LDBLO1)
        DO 30 IMODE = 1 , NBMODP
          DO 40 IMODE2 = 1 , IMODE
            ZR(JRIGGE+(IMODE-1)*NBMODP+IMODE2-1) =
     &                 ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
            ZR(JRIGGE+(IMODE2-1)*NBMODP+IMODE-1) =
     &                 ZR(LDBLO1+IMODE*(IMODE-1)/2+IMODE2-1)
 40       CONTINUE
 30     CONTINUE   
C
C --- RECUPERATION AMORTISSEMENTS GENERALISES   
C                         
        CALL JEVEUO(JEXNUM(AMGENE//'           .VALM',1),'L',LDBLO2)
        DO 31 IMODE = 1 , NBMODP
          DO 41 IMODE2 = 1 , IMODE
            IF (NBAG.NE.0) THEN
              ZR(JAMOGE+(IMODE-1)*NBMODP+IMODE2-1) =
     &                   ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
              ZR(JAMOGE+(IMODE2-1)*NBMODP+IMODE-1) = 
     &                   ZR(LDBLO2+IMODE*(IMODE-1)/2+IMODE2-1)
            ENDIF
 41       CONTINUE
 31     CONTINUE          
C
C --- RECUPERATION FORCES/FONC_MULT GENERALISEES
C        
        IF (NBGENE.NE.0) THEN
          DO 11 IFONC = 1,NBGENE
            CALL GETVID('EXCIT_GENE','FONC_MULT',IFONC,IARG,1,
     &                  ZK24(JFONGE+IFONC-1),NF)
            CALL GETVID('EXCIT_GENE','VECT_GENE',IFONC,IARG,1,
     &                  ZK24(JLIFGE+IFONC-1),NF)
            CALL JEVEUO(ZK24(JLIFGE+IFONC-1)(1:19)//'.VALE','L',JFGE)
            DO 12 IMODE = 1,NBMODP
              ZR(JFORGE+(IFONC-1)*NBMODP+IMODE-1) = ZR(JFGE+IMODE-1)
 12         CONTINUE
 11       CONTINUE
        ENDIF 
      ENDIF   
C
C --- MENAGE
C
      CALL JEDETR('&&MXMOAM.LIFOGE')
      CALL JEDEMA()
      END
