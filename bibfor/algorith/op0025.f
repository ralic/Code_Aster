      SUBROUTINE OP0025()
C
C ----------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 21/02/2011   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C     COMMANDE:  THER_LINEAIRE
C ----------------------------------------------------------------------
C
      IMPLICIT   NONE
C
C 0.1. ==> ARGUMENTS
C
C
C 0.2. ==> COMMUNS
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
C
C 0.3. ==> VARIABLES LOCALES
C
      CHARACTER*6 NOMPRO
      PARAMETER ( NOMPRO = 'OP0025' )
C
      INTEGER VALI, ETAUSR
      INTEGER NRORES
      INTEGER IFM,NIV
      INTEGER NOPT
      INTEGER NEQ,NUMINS
      INTEGER NBPASE, NRPASE
      INTEGER PARMEI(1), PARCRI(1)
C
      REAL*8 PARMER(1), PARCRR(1), PARA(2), VALR(2)
      REAL*8 TPSTHE(6),TPS1(4),DELTAT,DELTAM
      REAL*8 THETA,INSTAP,DIINST
C
      LOGICAL MATCST,COECST,LOSTAT,LEVOL,ASME,ASMS,FINPAS,LNONL
      LOGICAL REASVC,REASVT,REASMT,REASRG,REASMS,DIDERN,FORCE
C
      CHARACTER*1 CREAS
      CHARACTER*4 TYPCAL
      CHARACTER*8 EVOLSC
      CHARACTER*8 SAUX08,MAILLA
      CHARACTER*13 INPSCO
      CHARACTER*19 MAPREC,SOLVEU,INFCHA,INFCH2,SDDISC,SDCRIT
      CHARACTER*24 RESULT,MODELE,CHARGE,CARELE
      CHARACTER*24 FOMULT,NUMEDD,K24BLA
      CHARACTER*24 MEDIRI,MATASS
      CHARACTER*24 CNDIRP,CNCHCI,TIME
      CHARACTER*24 INFOCH,MATE
      CHARACTER*24 VEC2ND
      CHARACTER*24 COMPOR
      CHARACTER*24 LISOPT
C
C ----------------------------------------------------------------------
      DATA RESULT  /' '/
      DATA SDCRIT  /'&&OP0025.CRIT.'/
      DATA MEDIRI/' '/
      DATA CNDIRP,CNCHCI/2*' '/
      DATA TPSTHE/6*0.D0/
      DATA SDDISC  /'&&OP0025.DISC.'/

C DEB ------------------------------------------------------------------
C====
C 1. PREALABLES
C====
C
      CALL JEMARQ()
C
C-----RECUPERATION DU NIVEAU D'IMPRESSION
C
      CALL INFMAJ
      CALL INFNIV(IFM,NIV)
C
C-----------------------------------------------------------------------
      ASME = .TRUE.
      ASMS = .FALSE.
      K24BLA = ' '
C
C 1.2. ==> NOM DES STRUCTURES
C
      INPSCO = '&&'//NOMPRO//'_PSCO'
      SOLVEU = '&&'//NOMPRO//'.SOLVEUR   '
      INFCHA = '&&'//NOMPRO//'_INFCHA    '
      MAPREC = '&&'//NOMPRO//'_MAT_PRECON'
      VEC2ND = '&&'//NOMPRO//'_2ND_MEMBRE     '
      MATASS = '&&'//NOMPRO//'_MATR_ASSEM     '

C====
C 2. LES DONNEES
C====
C
C 2.1. ==> LECTURE DES OPERANDES DE LA COMMANDE
C               12   345678
      SAUX08 = '&&'//NOMPRO
C
      CALL NXLECT (RESULT,MODELE,MATE,CARELE,MATCST,COECST,
     >             FOMULT,INFCHA,CHARGE,INFOCH,
     >             PARMEI,PARMER,SOLVEU,PARCRI,PARCRR,
     >             LISOPT,NOPT,COMPOR,EVOLSC,
     >             NBPASE, SAUX08, INPSCO )
      PARA(1) = PARMER(1)
C

C 2.3. ==> LECTURE DE L'ETAT INITIAL ET DES DONNEES D'INCREMENTATION
C
      CALL NTINIT(RESULT,MODELE,MATE  ,CARELE,COMPOR,
     &            INFCHA,INFCH2,SOLVEU,PARA  ,NUMEDD,
     &            LOSTAT,LEVOL ,LNONL ,SDDISC,NBPASE,
     &            INPSCO,MAILLA,SDCRIT,TIME  )
      CALL ASSERT(.NOT.LNONL)
C
C 2.5. ==> CALCUL DES MATRICES ELEMENTAIRES DES DIRICHLETS
C
      TYPCAL = 'THER'
      CALL MEDITH ( TYPCAL, MODELE, CHARGE, INFOCH, MEDIRI )
C
C 2.6. ==> PILOTAGE DES REACTUALISATIONS DES ASSEMBLAGES
C     REASVT : INSTANTS, DIRICHLET, TERMES DU TRANSITOIRE
C     REASVC : CHARGEMENTS (SOURCES, FLUX, ... )
C     REASRG : MATRICE DE RIGIDITE
C     REASMS : MATRICE DE MASSE
C     REASMT : MATRICE TANGENTE POUR LE NON-LINEAIRE (SANS OBJET ICI)
C
      REASVT = .TRUE.
      REASVC = .TRUE.
      REASRG = .FALSE.
      REASMS = .FALSE.
      REASMT = .FALSE.
C

      IF (LOSTAT) THEN
        ASMS = .TRUE.
        NUMINS=0
      ELSE
        NUMINS=1
      ENDIF

      DELTAT=-1.D150
C
C 2.6. ==> CREATION DES STRUCTURES
C
      CALL VTCREB (VEC2ND, NUMEDD, 'V', 'R',NEQ )
C
C====
C 3. BOUCLES SUR LES PAS DE TEMPS
C====
C
      CALL UTTCPU('CPU.OP0025','INIT',' ')

200   CONTINUE

C --- RECUPERATION DU PAS DE TEMPS ET DES PARAMETRES DE RESOLUTION

C --- CETTE BOUCLE IF SERT A MAINTENIR LE NUMERO D ORDRE
C --- A 1 DANS LE CAS D UN CALCUL STATIONNAIRE.
C --- IL FAUT EN EFFET PROCEDER A CE CALCUL AVANT DE PARCOURIR
C --- LA LISTE D INSTANT DE LA SD SDDISC

        IF (LOSTAT) THEN
          IF (.NOT.LEVOL) THEN
            INSTAP=0.D0
            DELTAM=DELTAT
            DELTAT=-1.D150
            THETA=1.D0
          ELSE
            INSTAP=DIINST(SDDISC, NUMINS)
            DELTAM=DELTAT
            DELTAT=-1.D150
            THETA=1.D0
          ENDIF
        ELSE
          INSTAP = DIINST(SDDISC, NUMINS)
          DELTAM=DELTAT
          DELTAT = INSTAP-DIINST(SDDISC, NUMINS-1)
          THETA=PARMER(1)
        ENDIF
        PARA(2) = DELTAT
C --- MATRICE TANGENTE REACTUALISEE POUR UN NOUVEAU DT

          CALL UTTCPU('CPU.OP0025','DEBUT',' ')
          TPSTHE(1) = INSTAP
          TPSTHE(2) = DELTAT
          TPSTHE(3) = THETA
C
C 3.2.2. ==> BOUCLE 322 SUR LES RESOLUTIONS
C            LE PREMIER PASSAGE, 0, EST CELUI DU CALCUL STANDARD
C            LES PASSAGES SUIVANTS SONT CEUX DES DERIVATIONS
C
          DO 322 , NRORES = 0 , NBPASE
C
            NRPASE = NRORES
C
C 3.2.2.1. ==> Y-A-T'IL ASSEMBLAGE DES MATRICES ?
C
            IF ( NRORES.EQ.0 ) THEN
C
              IF ((.NOT.MATCST.OR..NOT.COECST) .OR. ASMS .OR. ASME) THEN
                REASRG = .TRUE.
                ASMS = .FALSE.
              END IF
              IF ((.NOT.MATCST) .OR.DELTAM.NE.DELTAT) THEN
                REASMS = .TRUE.
                ASME = .FALSE.
              END IF
C
            END IF
C
C 3.2.2.2. ==> RESOLUTION NUMERO NRPASE
C
            CALL NTRESO(NRPASE,NBPASE,INPSCO,MODELE,MATE  ,
     &                  CARELE,FOMULT,CHARGE,INFCHA,INFOCH,
     &                  NUMEDD,SOLVEU,LOSTAT,TIME  ,TPSTHE,
     &                  REASVC,REASVT,REASMT,REASRG,REASMS,
     &                  CREAS ,VEC2ND,MATASS,MAPREC,CNDIRP,
     &                  CNCHCI,MEDIRI,COMPOR)
C
            REASRG = .FALSE.
            REASMS = .FALSE.
C
  322     CONTINUE
C
C ------- ARCHIVAGE
C
          IF (LOSTAT) THEN
            FORCE = .TRUE.
          ELSE
            FORCE = .FALSE.  
          ENDIF  
          CALL NTARCH(NUMINS,MODELE,MATE  ,CARELE,COMPOR,
     &                LNONL ,PARA  ,SDDISC,SDCRIT,NBPASE,
     &                INPSCO,K24BLA,INFCH2,FORCE )  
C
C ------- VERIFICATION SI INTERRUPTION DEMANDEE PAR SIGNAL USR1
C
          IF ( ETAUSR().EQ.1 ) THEN
             CALL SIGUSR()
          ENDIF        
C
C 3.2.3. ==> GESTION DU TEMPS CPU
C
          FINPAS = DIDERN(SDDISC, NUMINS)

          CALL UTTCPU('CPU.OP0025','FIN',' ')
          CALL UTTCPR('CPU.OP0025',4,TPS1)
          IF ( TPS1(4).GT..95D0*TPS1(1)-TPS1(4) ) THEN
            VALI = NUMINS
            VALR(1) = TPS1(4)
            VALR(2) = TPS1(1)
            CALL UTEXCM(28,'ALGORITH16_68',0,' ',1,VALI,2,VALR)
          ELSE
            WRITE (IFM,'(A,1X,I6,2(1X,A,1X,1PE11.3))')
     >        'NUMERO D''ORDRE:',NUMINS,'INSTANT:',INSTAP,
     >        'DUREE MOYENNE:',TPS1(4)
          END IF
        IF (LOSTAT) THEN
          LOSTAT=.FALSE.
        ENDIF
        NUMINS = NUMINS + 1

      IF (FINPAS) GOTO 41

      GOTO 200


   41 CONTINUE


      CALL TITRE()

C     -- MENAGE FINAL :
      CALL DETMAT()

      CALL JEDEMA()
      END
