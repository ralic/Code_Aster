      SUBROUTINE NDFDYN(SDDYNA,MEASSE,VITPLU,ACCPLU,CNDYNA)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 09/06/2009   AUTEUR GREFFET N.GREFFET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2008  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      CHARACTER*19 SDDYNA
      CHARACTER*19 MEASSE(*)
      CHARACTER*24 VITPLU,ACCPLU,CNDYNA
C
C ----------------------------------------------------------------------
C
C ROUTINE MECA_NON_LINE (DYNAMIQUE)
C
C CALCUL DES FORCES DE RAPPEL DYNAMIQUE
C
C ----------------------------------------------------------------------
C
C
  
C
C -------------- DEBUT DECLARATIONS NORMALISEES  JEVEUX ----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C -------------- FIN  DECLARATIONS  NORMALISEES  JEVEUX ----------------
C
      CHARACTER*8  K8BID
      CHARACTER*19 NMCHEX,AMORT,MASSE,RIGID
      CHARACTER*24 VITES,ACCEL,VITE2
      CHARACTER*24 CNINER,CNHYST,NU
      INTEGER      NDYNIN,JPROV,JDEEQ,JREFA,NEQ
      REAL*8       NDYNRE,COERMA,COERAM,COERRI      
      LOGICAL      NDYNLO,LAMOR,LIMPL
      LOGICAL      LNEWMA,LTHETA,LTHETD,LTHETV,LKRENK
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ() 
C
C --- COEFFICIENTS DEVANTS MATRICES
C
      COERMA = NDYNRE(SDDYNA,'COEF_FDYN_MASSE')
      COERAM = NDYNRE(SDDYNA,'COEF_FDYN_AMORT')      
      COERRI = NDYNRE(SDDYNA,'COEF_FDYN_RIGID')      
C
C --- FONCTIONNALITES ACTIVEES
C
      LAMOR  = NDYNLO(SDDYNA,'MAT_AMORT')
      LIMPL  = NDYNLO(SDDYNA,'IMPLICITE')
C
C --- TYPE DE SCHEMA: NEWMARK (ET SES DERIVEES) OU THETA    
C
      LNEWMA = NDYNLO(SDDYNA,'FAMILLE_NEWMARK')
      LTHETA = NDYNLO(SDDYNA,'THETA_METHODE')
      LKRENK = NDYNLO(SDDYNA,'KRENK')
      IF (.NOT.(LNEWMA.OR.LTHETA.OR.LKRENK)) THEN
        CALL ASSERT(.FALSE.)
      ENDIF   
C
C --- TYPE DE THETA
C
      LTHETD = NDYNLO(SDDYNA,'THETA_METHODE_DEPL')
      LTHETV = NDYNLO(SDDYNA,'THETA_METHODE_VITE')
      IF (LKRENK) THEN
        IF (NDYNIN(SDDYNA,'FORMUL_DYNAMIQUE').EQ.1) THEN
          LTHETD = .TRUE.
          LTHETV = .FALSE.
        ELSEIF (NDYNIN(SDDYNA,'FORMUL_DYNAMIQUE').EQ.2) THEN
          LTHETD = .FALSE.
          LTHETV = .TRUE.        
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF 
      ENDIF     
C
C --- MATRICES ASSEMBLEES      
C           
      AMORT  = NMCHEX(MEASSE,'MEASSE','MEAMOR')
      MASSE  = NMCHEX(MEASSE,'MEASSE','MEMASS')
      RIGID  = NMCHEX(MEASSE,'MEASSE','MERIGI')
C
C --- VECTEURS RESULTATS
C      
      CNINER = '&&CNPART.CHP1'
      CNHYST = '&&CNPART.CHP2'
      CALL VTZERO(CNINER)
      CALL VTZERO(CNHYST)
      CALL VTZERO(CNDYNA)
C
C --- VECTEURS SOLUTIONS
C
      VITES = VITPLU
      ACCEL = ACCPLU
      IF (LIMPL) THEN
        IF (LNEWMA) THEN
          CALL NMINER(MASSE ,ACCEL,CNINER)
          CALL VTAXPY(COERMA,CNINER,CNDYNA)
        ELSEIF (LTHETD) THEN
          CALL NMINER(MASSE ,VITES,CNINER)
          CALL VTAXPY(COERMA,CNINER,CNDYNA)
        ELSEIF (LTHETV) THEN   
C  Mise a zero des termes Lagrange pour la resolution en vitesse
          VITE2 = '&&NDFDYN.VITE'
          CALL COPISD('CHAMP_GD','V',VITES,VITE2)
          CALL JEVEUO(VITE2(1:19)//'.VALE','E',JPROV)
          CALL JEVEUO(RIGID//'.REFA','L',JREFA)
          NU = ZK24(JREFA-1+2)
          CALL JEVEUO(NU(1:14)//'.NUME.DEEQ','L',JDEEQ)
          CALL JELIRA(VITE2(1:19)//'.VALE','LONMAX',NEQ,K8BID)
          CALL ZERLAG(ZR(JPROV),NEQ,ZI(JDEEQ))                      
          CALL NMINER(RIGID ,VITE2,CNINER)
          CALL JEVEUO(CNINER(1:19)//'.VALE','E',JPROV)
          CALL ZERLAG(ZR(JPROV),NEQ,ZI(JDEEQ)) 
          CALL VTAXPY(COERRI,CNINER,CNDYNA)
          CALL JEVEUO(CNDYNA(1:19)//'.VALE','E',JPROV)
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF  
      ENDIF
C
      IF (LAMOR) THEN
        CALL NMHYST(AMORT ,VITES,CNHYST)
        CALL VTAXPY(COERAM,CNHYST,CNDYNA)
      ENDIF
C
      CALL JEDEMA()
      END
