      SUBROUTINE OP0072(IERR)
C-----------------------------------------------------------------------
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 21/07/2003   AUTEUR NICOLAS O.NICOLAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C-----------------------------------------------------------------------
C
C  CALCUL PROJECTION VECTEUR SUR BASE DE RITZ
C
C-----------------------------------------------------------------------
C
      IMPLICIT REAL*8 (A-H,O-Z)
C
C      ---- DEBUT DES COMMUNS JEVEUX ----------------------------------
C
      INTEGER ZI
      COMMON /IVARJE/ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16         ZK16
      CHARACTER*24                    ZK24
      CHARACTER*32                                 ZK32
      CHARACTER*80                                            ZK80
      COMMON  /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C      ---- FIN DES COMMUNS JEVEUX ------------------------------------
C
      INTEGER      MUN, LLDESC
      CHARACTER*8  NOMRES,BASEMO,VECTAS,NOMTYP,K8BID,VECTAG
      CHARACTER*14 NU,NUMDD1,NUMDD2,NUMGEN
      CHARACTER*16 TYPRES,NOMCOM,TYPBAS,MATRI2
      CHARACTER*24 NOMCHA,MATRIC,CHAMNO,KBID,DEEQ
      CHARACTER*72 K72B
      COMPLEX*16   CBID
      REAL*8       R8DOT
C
C     ------------------------------------------------------------------
C     ------------------------------------------------------------------
C
      CALL JEMARQ()
      CALL INFMAJ()
C
C --- RECUPERATION DES ARGUMENTS DE LA COMMANDE
C
      CALL GETRES(NOMRES,TYPRES,NOMCOM)
      CALL GETVID(' ','NUME_DDL_GENE',0,1,1,NUMGEN,N0)
      CALL GETVID(' ','VECT_ASSE',0,1,1,VECTAS,N1)
      CALL GETVID(' ','VECT_ASSE_GENE',0,1,1,VECTAS,N3)
      CALL GETVID(' ','BASE',0,1,1,BASEMO,N4)
      CALL GETVTX(' ','TYPE_VECT',0,1,1,NOMTYP,N2)
      CALL GETTCO(BASEMO,TYPBAS)
C
C --- RECUPERATION DU NB DE MODES
C
      CALL RSORAC(BASEMO,'LONUTI',IBID,BID,K8BID,CBID,EBID,'ABSOLU',
     +            NBMODE,1,NBID)
C
C RECUPERATION DU NOMBRE DE MODES REDUIT,
C NB_VECT DONNE PAR NUME_DDL_GENE

      CALL JEVEUO(NUMGEN//'.SLCS.DESC','L',LLDESC)
      NBMODE   = ZI(LLDESC)
C
C
C --- VERIFICATION DE LA CONFORMITE DES NUMEROTATIONS
C     DES MODES ET DU VECTEUR ASSEMBLE
C
      CALL JEVEUO(VECTAS//'           .VALE','L',IADVEC)
      CALL JEVEUO(VECTAS//'           .REFE','L',IADREF)
      CALL JEVEUO(BASEMO//'           .REFE','L',IADRIF)
      IF ((TYPBAS(1:9).EQ.'MODE_MECA').OR.
     +   (TYPBAS(1:9).EQ.'MODE_STAT')) THEN
        NUMDD1 = ZK24(IADREF+1) (1:8)
        MATRIC = ZK24(IADRIF)
        CALL DISMOI('F','NOM_NUME_DDL',MATRIC,'MATR_ASSE',IBID,NUMDD2,
     +              IRET)
        NU = NUMDD2(1:14)
      ELSEIF (TYPBAS(1:9).EQ.'BASE_MODA') THEN
        NUMDD1 = ZK24(IADREF+1)
        NUMDD2 = ZK24(IADRIF+1)
        NU = NUMDD2
      ELSEIF (TYPBAS(1:9).EQ.'MODE_GENE') THEN
        NUMDD1=ZK24(IADREF+1)
        MATRIC = ZK24(IADRIF)
        MATRI2 = MATRIC(1:16)
        CALL JEVEUO(MATRI2//'   .REFA','L',LLREFE)
        NUMDD2=ZK24(LLREFE+1)
        NU = NUMDD2(1:14)
      ENDIF
      IF (NUMDD1.NE.NUMDD2) THEN
        CALL UTMESS('F',NOMCOM,'BASE MODALE ET VECT_ASSE AVEC '//
     +              ' NUMEROTATION INCOMPATIBLE')
      ENDIF
C
C --- RECUPERATION DU NOMBRE D'EQUATIONS DU SYSTEME PHYSIQUE
C
      IF ((TYPBAS(1:9).EQ.'MODE_MECA').OR.
     +    (TYPBAS(1:9).EQ.'MODE_STAT')) THEN
        CALL DISMOI('F','NB_EQUA',MATRIC,'MATR_ASSE',NEQ,KBID,IRET)
      ELSEIF (TYPBAS(1:9).EQ.'BASE_MODA') THEN
        CALL DISMOI('F','NB_EQUA',NU,'NUME_DDL',NEQ,KBID,IRET)
      ELSEIF (TYPBAS(1:9).EQ.'MODE_GENE') THEN
        CALL JEVEUO(NUMDD1//'.NUME.NEQU','L',LLNEQU)
        NEQ = ZI(LLNEQU)
      ENDIF
C
      DEEQ = NU//'.NUME.DEEQ'
      CALL JEVEUO(DEEQ,'L',IDDEEQ)
C
C --- CREATION DE L OBJET VECT_GENE RESULTAT
C
      CALL WKVECT(NOMRES//'           .VALE','G V R',NBMODE,IAVALE)
      CALL WKVECT(NOMRES//'           .REFE','G V K24',2,IAREFE)
      CALL WKVECT(NOMRES//'           .DESC','G V I',3,IADESC)
C
C --- REMPLISSAGE DU .REFE ET .VALE
C
      ZK24(IAREFE) = BASEMO
      ZK24(IAREFE+1) = NUMGEN//'.NUME     '
      ZI(IADESC) = 1
      ZI(IADESC+1) = NBMODE
      CALL WKVECT('&&OP0072.BASEMO','V V R',NBMODE*NEQ,IDBASE)
C --- CONVERSION DE BASEMO A LA NUMEROTATION NU      
      IF ((TYPBAS.EQ.'MODE_MECA').OR.(TYPBAS.EQ.'MODE_GENE').OR.
     +    (TYPBAS.EQ.'MODE_STAT')) THEN
        CALL COPMOD(BASEMO,'DEPL',NEQ,NU,NBMODE,ZR(IDBASE))
      ELSE
        CALL COPMO2(BASEMO,NEQ,NU,NBMODE,ZR(IDBASE))
      ENDIF      
      IF (NOMTYP(1:4).EQ.'FORC') THEN
C
C --- PROJECTION D UN VECTEUR DE TYPE FORCE
C
        CALL WKVECT('&&OP0072.VECTASSE','V V R',NEQ,IDVECT)
        DO 10 I = 1,NBMODE
C
C --------- RECOPIE DU IEME MODE
C
          CALL R8COPY(NEQ,ZR(IDBASE+(I-1)*NEQ),1,ZR(IDVECT),1)          
C          
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
          CALL ZERLAG(ZR(IDVECT),NEQ,ZI(IDDEEQ))
C
C ------- PRODUIT SCALAIRE VECTASS * MODE
C
          ZR(IAVALE+I-1) = R8DOT(NEQ,ZR(IDVECT),1,ZR(IADVEC),1)
10      CONTINUE
        CALL JEDETR('&&OP0072.VECTASSE')
      ELSE
C
C --- PROJECTION D UN VECTEUR DE TYPE DEPL OU VITE
C
        CALL WKVECT('&&OP0072.VECTASS1','V V R',NEQ,IDVEC1)
        CALL WKVECT('&&OP0072.VECTASS2','V V R',NEQ,IDVEC2)
        CALL WKVECT('&&OP0072.MATRNORM','V V R',NBMODE*NBMODE,IAMATR)
C
C ----- CALCUL DE TMODE*MODE
C
        DO 20 I = 1,NBMODE
C
C ----- RECOPIE DU IEME MODE
C
          CALL R8COPY(NEQ,ZR(IDBASE+(I-1)*NEQ),1,ZR(IDVEC1),1)
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
          CALL ZERLAG(ZR(IDVEC1),NEQ,ZI(IDDEEQ))
C
C-------- PRODUIT SCALAIRE MODE(I)*MODE(J)
C
          DO 20 J = I,NBMODE
C
C ------- RECOPIE DU JEME MODE
C
            CALL R8COPY(NEQ,ZR(IDBASE+(J-1)*NEQ),1,ZR(IDVEC2),1)
C --------- MISE A ZERO DES DDLS DE LAGRANGE
C
            CALL ZERLAG(ZR(IDVEC2),NEQ,ZI(IDDEEQ))
C
C --------- PRODUIT SCALAIRE VECTASS * MODE
C
            PIJ = R8DOT(NEQ,ZR(IDVEC1),1,ZR(IDVEC2),1)
            ZR(IAMATR+I+ (J-1)*NBMODE-1) = PIJ
            ZR(IAMATR+J+ (I-1)*NBMODE-1) = PIJ
20      CONTINUE
C
C ----- CALCUL DE LA PROJECTION
C
        DO 30 I = 1,NBMODE
C
C ------- RECOPIE DU IEME MODE
C
          CALL R8COPY(NEQ,ZR(IDBASE+(I-1)*NEQ),1,ZR(IDVEC1),1)          
C
C ------- MISE A ZERO DES DDLS DE LAGRANGE
C
          CALL ZERLAG(ZR(IDVEC1),NEQ,ZI(IDDEEQ))
C
C ------- PRODUIT SCALAIRE VECTASS * MODE
C
          ZR(IDVEC2+I-1) = R8DOT(NEQ,ZR(IDVEC1),1,ZR(IADVEC),1)
30      CONTINUE
C
C ----- FACTORISATION ET RESOLUTION SYSTEME
C
        CALL TRLDS(ZR(IAMATR),NBMODE,NBMODE,ICOD)
        IF (ICOD.NE.0) THEN
          CALL UTMESS('F',NOMCOM,
     +        'LA BASE CONSTITUEE NE FORME PAS UNE FAMILLE LIBRE ')
        ENDIF
        CALL RRLDS(ZR(IAMATR),NBMODE,NBMODE,ZR(IDVEC2),1)
        CALL R8COPY(NBMODE,ZR(IDVEC2),1,ZR(IAVALE),1)
        CALL JEDETR('&&OP0072.VECTASS1')
        CALL JEDETR('&&OP0072.VECTASS2')
        CALL JEDETR('&&OP0072.MATRNORM')
      ENDIF
      CALL JEDETR('&&OP0072.BASEMO')      
C
      CALL JEDEMA()
      END
