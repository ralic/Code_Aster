      SUBROUTINE OPTILI (RESULT, MODELE,MATE,LISCHA,PARTPS)

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 11/02/2003   AUTEUR PBADEL P.BADEL 
C ======================================================================
C COPYRIGHT (C) 1991 - 2002  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
C (AT YOUR OPTION) ANY LATER VERSION.                                 
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
C ======================================================================
C RESPONSABLE PBADEL P.BADEL

      IMPLICIT      NONE
      CHARACTER*24  MATE, MODELE
      CHARACTER*8   RESULT
      CHARACTER*19  PARTPS, LISCHA

C -----------------------------------------------------------------
C  ROUTINE REDECOUPAGE LISTE PAS DE TEMPS MECA
C  EN FONCTION DU CHARGEMENT THERMIQUE
C------------------------------------------------------------------
C
C      IN  RESULT K8   NOM UTILISATEUR DU RESULTAT DE STAT_NON_LINE
C      IN  MODELE K24  MODELE MECANIQUEC
C      IN  LISCHA K19  SD L_CHARGE
C      IN  MATE K24    CHAMP MATERIAU
C      IN  PARTPS K19  SD DICSCRETISATION

      INTEGER       I,J,K,ITER
      INTEGER       N1,N2,N3,DIM,NCHAR,NBORDR,LONCH,LGINI,LGTEMP
      INTEGER       FREARC,NOCC,IRET,NUMCHA
      INTEGER       NUMINS,NBPAS,INSPAS,NBINI,NBTEMP
      INTEGER       JINFO,JCHAR,JINF,JTEMP,IACCES,IATAVA,IAOBJ
      INTEGER       JLIOPT,JDDT,JDTE,JLINEW,JTEMMO,JTEMPL,JTEMPS,JARCH
      INTEGER       INF,NIV
      REAL*8         CRIT,INST0,INSTAM,INSTAP,TIMEM,TIMEP,DTIME
      REAL*8         VMAX0,VMAX1,DIINST,TOLE
      CHARACTER*19  NOMS2,TEMMOI,TEMPLU,TEMPI,DTEMPP,DDTEMP
      CHARACTER*19  LISOPT,LISNEW
      CHARACTER*8   VARICO,TEMPE,NOMOBJ,NOPASE,K8BID
      CHARACTER*24  NOM24,CHARGE,INFOCH
      LOGICAL        EXITMM,EXITMP

C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------

      CHARACTER*32      JEXNOM, JEXNUM
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)

C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------

      CALL JEMARQ()

C 1 - LECTURE CRITERE DE REDECOUPAGE ET VERIFICATION

      CALL GETVTX('INCREMENT','NOM_CHAM',1,1,1,VARICO,NOCC)
      IF (NOCC .EQ. 0) CALL UTMESS('F','OPTILI','LE NOM DU CHAMP
     & DE LA VARIABLE DE COMMANDE  POUR DECOUPAGE OBLIGATOIRE')
      
      CALL GETVTX('INCREMENT','NOM_CMP',1,1,1,VARICO,NOCC)
      IF (NOCC .EQ. 0) CALL UTMESS('F','OPTILI','LE NOM DU CMP
     & DE LA VARIABLE DE COMMANDE  POUR DECOUPAGE OBLIGATOIRE')

      CALL GETVR8('INCREMENT','VALE',1,1,1,CRIT,NOCC)
      IF (NOCC .EQ. 0) CALL UTMESS('F','OPTILI','CRITERE POUR
     & DECOUPAGE OBLIGATOIRE')

      CALL GETVR8('INCREMENT','PRECISION'     ,1,1,1,TOLE,N3)

C 2 - RECUPERATION DU CHAMP DE TEMPERATURE CHARGEMENT
C 2.1 - RECUPERATION DU NOM UTILISATEUR DE CE CHAMP THERMIQUE

      TEMPE = '        '
      NOPASE = '        '
      CHARGE = LISCHA // '.LCHA'
      INFOCH = LISCHA // '.INFC'
      CALL JEEXIN(CHARGE,IRET)
      IF ( IRET .NE. 0 ) THEN
       CALL JELIRA(CHARGE,'LONMAX',NCHAR,K8BID)
       CALL JEVEUO(CHARGE,'L',JCHAR)
       CALL JEVEUO(INFOCH,'L',JINF)
       NUMCHA = ZI(JINF+2*NCHAR+1)
      ELSE
       NUMCHA = 0
      ENDIF

      IF ( NUMCHA .GT. 0 ) THEN
       NOM24 = ZK24(JCHAR+NUMCHA-1)(1:8)//'.CHME.TEMPE.TEMP'
       CALL JEVEUO(NOM24,'L',JTEMP)
       TEMPE = ZK8(JTEMP)
      ENDIF

C 2.2 - RECUPARATION DE LA LISTE D INSTANTS THERMIQUE
C       DE LONGUEUR NBORDR ET DE VALEUR ZR(IAOBJ)

      NOMS2=TEMPE
      CALL JENONU(JEXNOM(NOMS2//'.NOVA','INST'),IACCES)
      CALL JEVEUO(JEXNUM(NOMS2//'.TAVA',IACCES),'L',IATAVA)
      NOMOBJ = ZK8(IATAVA-1+1)
      CALL JEVEUO(NOMS2//NOMOBJ,'L',IAOBJ)
      CALL JELIRA(NOMS2//NOMOBJ,'LONMAX',NBORDR,K8BID)

C 2.3 - POUR UN INSTANT DONNE ON RECUPERE LA DIMENSION LONCH
C       DU CHAMP DE TEMPERATURE = NOMBRE DE NOEUD

      TEMPI  =  '&&OPTILI.TEMPI'
      INST0 = DIINST(PARTPS, 0)
      CALL NMDETE (MODELE,MATE,CHARGE,INFOCH,NOPASE,INST0,TEMPI,EXITMM)
      CALL JELIRA(TEMPI//'.VALE','LONMAX',LONCH,K8BID)

C 3 - DISCRETISATION MECANIQUE INITIALE A REDECOUPER
C     LONGUEUR DE LA LISTE D INSTANTS MECANIQUE = N1
C     FREQUENCE D ARCHIVAGE FREARC

      CALL JELIRA(PARTPS // '.DITR','LONMAX',N1,K8BID)
      CALL JEVEUO(PARTPS // '.DIIR','L',JINFO)
      FREARC = NINT(ZR(JINFO-1+2))

C 4 - CREATION POUR CHAQUE INTERVALLE DE TEMPS MECANIQUE
C     DE VECTEURS UTILES POUR L OPTIMISATION
C
C     LISOPT = LISTE D INSTANTS COMPRENANT LES DEUX INSTANTS MECANIQUES
C              PLUS EVENTUELLEMENT LES INSTANTS THERMIQUES
C     ATTENTION A LA LONGUEUR DE CETTE LISTE A CHANGER SI DEPASSE NBORDR
C     TEMMOI = TEMPERATURE A L INSTANT MOINS (DIMENSION LONCH)
C     TEMPLU = TEMPERATURE A L INSTANT PLUS  (DIMENSION LONCH)
C     DDTEMP = TEMPERATURE A L INSTANT PLUS - TEMPE. A L INSTANT MOINS
C     DTEMPP = DDTEMP(ITERATION D AVANT) + DDTEMP(ITERATION COURANTE)
C     LISNEW = NOUVELLE LISTE D INSTANTS POUR CALCUL MECANIQUE

      LISOPT =  '&&OPTILI.LISOPT'
      TEMMOI =  '&&OPTILI.TEMMOI'
      TEMPLU =  '&&OPTILI.TEMPLU'
      DDTEMP =  '&&OPTILI.DDTEMP'
      DTEMPP =  '&&OPTILI.DTEMPP'
      LISNEW =  '&&OPTILI.LISNEW'

      CALL WKVECT(LISOPT,'V V R8',NBORDR+N1,JLIOPT)
      CALL WKVECT(DDTEMP,'V V R8',LONCH,JDDT)
      CALL WKVECT(DTEMPP,'V V R8',LONCH,JDTE)

C=================================================================
C 5 - BOUCLE SUR LES INCREMENTS DE TEMPS MECANIQUE
C=================================================================

      NUMINS=0
      DO 10 ITER = 1,N1-1

C 5.1 - INITILAISATION DES DEUX VECTEURS DDTEMP ET DTEMPP

       DO 15 I=1,LONCH
        ZR(JDDT+I-1)=0.D0
        ZR(JDTE+I-1)=0.D0
 15    CONTINUE

C 5.2 - RECUPERATION DES DEUX INSTANTS MECANIQUES

       INSTAM = DIINST(PARTPS, NUMINS)
       INSTAP = DIINST(PARTPS, NUMINS+1)

C 5.3 - CREATION PAR LISTER DE LA LISTE D INSTANT LISOPT
C       COMPRENANT LES DEUX INSTANTS MECANIQUES
C       PLUS EVENTUELLEMENT LES INSTANTS THERMIQUES
C       IN : LISTE DES INSTANTS THERMIQUE ZR(IAOBJ) + SA LONGUEUR NBORDR
C       IN : INSTANT MOINS ET INSTANT PLUS MECANIQUE
C       OUT: LISTE LISOPT DE DIMENSION N2

       CALL LISTER(ZR(IAOBJ),NBORDR,INSTAM,INSTAP,ZR(JLIOPT),N2)

C=================================================================
C 5.4 - CREATION DE LA NOUVELLE LISTE D INSTANTS MECANIQUE
C       LISTNEW DE DIMENSION INITIALE NBORDR+N1
C=================================================================

       CALL WKVECT(LISNEW,'V V R8',NBORDR+N1,JLINEW)
       J=0
       DIM =0

C 5.4.1 - BOUCLE SUR LES INSTANTS DE LISOPT

       DO 20 I = 1, N2-1

        TIMEM = ZR(JLIOPT+I-1)
        TIMEP = ZR(JLIOPT+I)

C 5.4.2 - RECUPERATION AUX INSTANTS MOINS ET PLUS
C         DES CHAMPS DE TEMPERATURE AUX NOEUDS

        CALL NMDETE (MODELE,MATE,CHARGE,INFOCH,NOPASE,TIMEM,TEMMOI,
     &               EXITMM)
        CALL NMDETE (MODELE,MATE,CHARGE,INFOCH,NOPASE,TIMEP,TEMPLU,
     &               EXITMP)
        CALL JEVEUO(TEMMOI//'.VALE','L',JTEMMO)
        CALL JEVEUO(TEMPLU//'.VALE','L',JTEMPL)

C 5.4.3 - CALCUL DE
C         ZR(JDDT) = DT = TEMPERATURE PLUS - TEMPERATURE MOINS
C         ZR(JDTE) = DTP = DT(ITERATION I-1) + DT(ITERATION I)
C         VMAX0    = MAX DE DT SUR TOUS LES NOEUDS
C         VMAX1    = MAX DE DTP SUR TOUS LES NOEUDS

        CALL CALDTP(ZR(JTEMMO),ZR(JTEMPL),ZR(JDDT),ZR(JDTE),LONCH
     &             ,VMAX0,VMAX1)

C 5.4.4 - SI ON DEPASSE L UNE DES DEUX CONDITIONS SUIVANTES
C         ON STOKE DANS LA NOUVELLE LISTE LES NOUVEAUX INSTANTS

        IF ((VMAX1 .GT. CRIT).AND.(I .NE. 1)) THEN
         DIM=DIM+1
         IF (DIM.GT.(NBORDR+N1)) THEN
          CALL JUVECA(LISNEW,DIM)
         ENDIF

         ZR(J+JLINEW)=TIMEM
         J=J+1
         DO 25 K=0, LONCH-1
          ZR(JDTE+K)=ZR(JDDT+K)
 25      CONTINUE
        ENDIF

        IF (VMAX0 .GT. CRIT) THEN
         NBPAS = INT(VMAX0/(CRIT+TOLE*CRIT))+1
         DIM=DIM+NBPAS-1
         IF (DIM.GT.(NBORDR+N1)) THEN
          CALL JUVECA(LISNEW,DIM)
         ENDIF
         DTIME  = (TIMEP-TIMEM)/DBLE(NBPAS)
         IF (TIMEM .NE. INSTAM) THEN
          ZR(JLINEW+J)=ZR(JLINEW+J-1)+DTIME
         ELSE
          ZR(JLINEW+J)=TIMEM+DTIME
         ENDIF
         J=J+1
         DO 30 K = 2,NBPAS-1
          ZR(JLINEW+J)=ZR(JLINEW+J-1)+DTIME
          J=J+1
 30      CONTINUE

         DO 35 K=0, LONCH-1
          ZR(JDTE+K)=ZR(JDDT+K)/NBPAS
 35      CONTINUE
        ENDIF
 20    CONTINUE

C==================================================================
C 5.5 - ALLONGEMENT DE LA LISTE D'INSTANTS
C==================================================================

       INSPAS =J
       IF (J .GT. 0) THEN
        CALL JELIRA(PARTPS // '.DITR','LONMAX',LGINI,K8BID)
        LGTEMP = LGINI + INSPAS
        CALL JUVECA(PARTPS // '.DITR',LGTEMP)
        CALL JEVEUO(PARTPS // '.DITR','E',JTEMPS)
        NBINI  = LGINI  - 1
        NBTEMP = LGTEMP - 1

C 5.5.1 - RECOPIE DE LA PARTIE DROITE DE LA LISTE

        DO 40 I = NBINI, NUMINS+1, -1
         ZR(JTEMPS+I+INSPAS) = ZR(JTEMPS+I)
 40     CONTINUE

C 5.5.2 - INSERTION DES INSTANTS SUPPLEMENTAIRES

        J=0
        DO 45 I = NUMINS+1, NUMINS+INSPAS
         ZR(JTEMPS+I) = ZR(JLINEW+J)
         J=J+1
 45     CONTINUE

C==================================================================
C 5.6 - LISTE D'ARCHIVAGE
C==================================================================

C 5.6.1 - ALLONGEMENT DE LA LISTE D'ARCHIVAGE

        CALL JUVECA(PARTPS // '.DIAL',LGTEMP)
        CALL JEVEUO(PARTPS // '.DIAL','E',JARCH)

C 5.6.2 - AUCUN ARCHIVAGE SUPPLEMENTAIRE SI PAS_ARCH == 0
C PAS_ARCH = 0 ARCHIVAGE PAR LISTE D INSTANT OU INSTANT
C          = 1 ON ARCHIVE TOUS LES INSTANTS (PAR DEFAUT)
C          = VALEUR

        IF (FREARC .EQ. 0) THEN

C 5.6.2.1 - RECOPIE DE LA PARTIE HAUTE

         DO 50 I = NBINI, NUMINS+1, -1
          ZL(JARCH+I+INSPAS) = ZL(JARCH+I)
 50      CONTINUE

C 5.6.2.2 - MISE A .FALSE. DES NOUVEAUX INSTANTS

         DO 55 I = NUMINS+1, NUMINS+INSPAS
          ZL(JARCH+I) = .FALSE.
 55      CONTINUE

C 5.6.2.3 - NOUVELLE LISTE D'ARCHIVAGE SI PAS_ARCH DIFFERENT DE 0

        ELSE
         DO 60 I = 0, NBTEMP
          ZL(JARCH+I) = .FALSE.
 60      CONTINUE

         DO 65 I = FREARC, NBTEMP, FREARC
          ZL(JARCH+I) = .TRUE.
 65      CONTINUE

        END IF
       ENDIF
       CALL JEDETR(LISNEW)
       NUMINS = NUMINS+INSPAS+1
 10   CONTINUE

      CALL JEDETR(LISOPT)
      CALL JEDETR(DTEMPP)
      CALL JEDETR(DDTEMP)

C ---IMPRESSION NOUVEAU LISTE D'INSTANT

      CALL UTMESS ('A','OPTILI','LISTE D INSTANTS CHANGEE')

      CALL JEDEMA()

      END
