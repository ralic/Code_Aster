      SUBROUTINE DIDECO(PARTPS, NUMINS, CRITNL, FDECUP, RETOUR )

C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 12/11/2007   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE MABBAS M.ABBAS

      IMPLICIT NONE
      INTEGER      NUMINS, RETOUR, FDECUP
      CHARACTER*19 PARTPS, CRITNL

C ----------------------------------------------------------------------
C        SD DISCRETISATION :   DECOUPAGE DU PAS DE TEMPS
C ----------------------------------------------------------------------
C
C  IN PARTPS K19 : SD DISCRETISATION
C  IN NUMINS  I  : NUMERO D'INSTANTS
C  IN CRITNL K19 : SD CRITERE
C  IN FDECUP  I  : FORCE LA SUBDIVISION
C                  1 : FORCE LA SUBDIVISION
C
C OUT RETOUR  I  : CODE RETOUR
C                  0 = LA SUBDIVISION C'EST BIEN PASSEE
C                  1 = SUBDIVISION NON DEMANDE
C                  2 = FINESSE MAXIMALE ATTEINTE : SUBDIVISION INTERDITE
C                  3 = ON AUTORISE DES ITERATIONS EN PLUS
C
C --- DEBUT DECLARATIONS NORMALISEES JEVEUX ----------------------------
C
      CHARACTER*32       JEXNUM , JEXNOM , JEXR8 , JEXATR
      INTEGER            ZI
      COMMON  / IVARJE / ZI(1)
      REAL*8             ZR
      COMMON  / RVARJE / ZR(1)
      COMPLEX*16         ZC
      COMMON  / CVARJE / ZC(1)
      LOGICAL            ZL
      COMMON  / LVARJE / ZL(1)
      CHARACTER*8        ZK8
      CHARACTER*16                ZK16
      CHARACTER*24                          ZK24
      CHARACTER*32                                    ZK32
      CHARACTER*80                                              ZK80
      COMMON  / KVARJE / ZK8(1) , ZK16(1) , ZK24(1) , ZK32(1) , ZK80(1)
C
C --- FIN DECLARATIONS NORMALISEES JEVEUX ------------------------------
      REAL*8 ZERO,UN,DEUX
      PARAMETER ( ZERO=0.0D0, UN=1.0D0, DEUX=2.0D0)

      INTEGER      JINFO, JTEMPS, JARCH, JNIVTP, NBNIVO, NBIGNO, I
      INTEGER      ITERAT, JCRR, JERRE, IRET, NBITER, DININS, NBFIN
      INTEGER      FREARC, NBRPAS, INSPAS, NBTEMP, NBINI, LGTEMP, LGINI
      REAL*8       PASMIN, RATIO, INSTAM, INSTAP, INST, INCINS, DELTAT
      REAL*8       R8BID, XXBB, FXXBB
      REAL*8       GLBREL, GLBMAX, ERRREL, ERRMAX
      CHARACTER*8  K8BID
      CHARACTER*16 METHOD

      REAL*8       XX,SX,SX2,SX3,SX4,SY,SYX,SYX2,XN,XA0,XA1,XA2,XDET
      REAL*8       CIBLEN, CIBLE, XXITER, TEQUI, XBPASP, PENTE
      INTEGER      DECAL, DEPART, DEPASS , IUNIFI, NBPEN, LENIVO
      LOGICAL      LEXTRA,VERINI

      REAL*8       VALRM(2)
      INTEGER      VALIM(2)
      CHARACTER*40 VALKM(1)
C ----------------------------------------------------------------------

      CALL JEMARQ()
      RETOUR = 0

C --- LECTURE DU NOM DE LA METHODE DE SUBDIVISION
      CALL JEVEUO(PARTPS // '.METH','L',JINFO)
      METHOD = ZK16(JINFO)
      IF ( METHOD(1:6) .EQ. 'AUCUNE' ) THEN
         RETOUR = 1
         GOTO 9999
      ENDIF
C      MATRICE = ZK16(JINFO+1)

C     ERREUR DES CRITERES DE CONVERGENCE :  +O = ITERAT
      CALL JEEXIN(CRITNL//'.CRTR',IRET)
      IF (IRET.NE.0) THEN
         CALL JEVEUO(CRITNL// '.CRTR','L',JCRR)
         ITERAT = NINT(ZR(JCRR))
      ELSE
C        PAS D'EXISTANCE D'ERREUR SUR LES CONVERGENCES
         RETOUR = 1
         GOTO 9999
      ENDIF

      CALL JEVEUO(PARTPS // '.ERRE','E',JERRE)
      NBITER = NINT(ZR(JERRE))
C     PAS D'EXISTANCE D'ERREUR SUR LES CONVERGENCES
      IF (NBITER .EQ. 0) THEN
         RETOUR = 1
         GOTO 9999
      ENDIF
C      UMESS   = IUNIFI ('MESSAGE')

C --- LECTURE DES INFOS SUR LE PAS DE TEMPS
      CALL JEVEUO(PARTPS // '.DITR','E',JTEMPS)
      INSTAM = ZR(JTEMPS+NUMINS-1)
      INSTAP = ZR(JTEMPS+NUMINS)

C --- LECTURE DES INFOS SUR LES CONVERGENCES : CF DIINIT
      XXITER = ZR(JERRE + 2)
      GLBREL = ZR(JERRE + 3)
      GLBMAX = ZR(JERRE + 4)

C --- ARGUMENTS DE LA SUBDIVISION
      CALL JEVEUO(PARTPS // '.DIIR','L',JINFO)
C     ZR(JINFO-1 + 2) <===> 'FREQUENCE ARCHIVAGE'
C     ZR(JINFO-1 + 3) <===> 'SUBD_PAS'
C     ZR(JINFO-1 + 4) <===> 'SUBD_PAS_MINI'
C     ZR(JINFO-1 + 5) <===> 'SUBD_COEF_PAS_1'
C     ZR(JINFO-1 + 6) <===> 'SUBD_NIVEAU'
C     ZR(JINFO-1 + 7) <===> 'SUBD_ITER_IGNO'
C     ZR(JINFO-1 + 8) <===> 'SUBD_ITER_FIN'
      FREARC = NINT(ZR(JINFO-1+2))
      NBRPAS = NINT(ZR(JINFO-1+3))
      PASMIN =      ZR(JINFO-1+4)
      RATIO  =      ZR(JINFO-1+5)
      NBNIVO = NINT(ZR(JINFO-1+6))
      NBIGNO = NINT(ZR(JINFO-1+7))
      NBFIN  = NINT(ZR(JINFO-1+8))

      LENIVO = DININS(PARTPS,NUMINS)
      VERINI = .FALSE.
      IF ( NBNIVO .GT. 1 ) VERINI = .TRUE.
C     NIVEAU MAXIMUM DE REDECOUPAGE ATTEINT
      IF ( VERINI.AND.(LENIVO.GT.NBNIVO) ) THEN
         VALIM(1) = LENIVO
         VALIM(2) = NBNIVO
         CALL U2MESI('I','SUBDIVISE_12',2,VALIM)
         RETOUR = 2
         GOTO 9999
      ENDIF

C     TAILLE DE PAS MINIMALE ATTEINTE AVANT LA NOUVELLE SUBDIVISION
C     CELA PEUT ARRIVER A CAUSE DU COEFFICIENT RATIO
      DELTAT = INSTAP-INSTAM
      IF ( DELTAT .LT. PASMIN ) THEN
         VALKM(1) = 'Avant la nouvelle subdivision'
         CALL U2MESK('I','SUBDIVISE_13',1,VALKM)
         VALKM(1) = METHOD
         VALIM(1) = LENIVO-1
         VALRM(1) = DELTAT
         VALRM(2) = PASMIN
         CALL U2MESG('I','SUBDIVISE_15',1,VALKM,1,VALIM,2,VALRM)
         RETOUR = 2
         GOTO 9999
      END IF

      IF ( ITERAT .GT. XXITER ) THEN
         IF ( METHOD(1:7) .EQ. 'EXTRAP_' ) THEN
            METHOD = 'AUCUNE'
            RATIO  = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
         ELSE
            METHOD = 'AUCUNE'
            RATIO  = UN
         ENDIF
         VALIM(1) = NBRPAS
         VALIM(2) = LENIVO
         VALRM(1) = RATIO
         VALRM(2) = DELTAT
         CALL U2MESG('I','SUBDIVISE_10',0,VALKM,2,VALIM,2,VALRM)
         GOTO 8888
      ENDIF

C     DANS LE CAS OU L'ON A SUBDIVISE ET QUE L'ON A PLUSIEURS NIVEAUX
C     DE DIFFÉRENCE AVEC LE PAS SUIVANT. CELA CORRESPOND AU 1ER APPEL
C     A DIDECO DANS OP0070
      IF ((FDECUP .EQ. -1).AND.(METHOD(1:6).NE.'SIMPLE')) THEN
         METHOD = 'AUCUNE'
         RATIO  = UN
         GOTO 8888
      ENDIF

C     FORCE LA SUBDIVISION
      IF ( FDECUP .EQ. 1 ) THEN
         IF ( METHOD(1:7) .EQ. 'EXTRAP_' ) THEN
C            NBRPAS = 3
C            RATIO  = 24.0/((3.0*NBRPAS+UN)**2 - UN)
            METHOD = 'AUCUNE'
            RATIO  = UN
         ELSE
            METHOD = 'AUCUNE'
            RATIO  = UN
         ENDIF
         VALIM(1) = NBRPAS
         VALIM(2) = LENIVO
         VALRM(1) = RATIO
         VALRM(2) = DELTAT
         CALL U2MESG('I','SUBDIVISE_14',0,VALKM,2,VALIM,2,VALRM)
         GOTO 8888
      ENDIF

C --- SI LA METHODE UTILISE L'EXTRAPOLATION
      LEXTRA = .FALSE.
      IF (     (METHOD(1:11).EQ.'EXTRAP_IGNO').AND.
     &         ((NBIGNO+3).LE.ITERAT) ) THEN
        LEXTRA = .TRUE.
        DEPART = NBIGNO
      ELSEIF ( (METHOD(1:10).EQ.'EXTRAP_FIN').AND.
     &         ((NBFIN+3).LE.ITERAT) ) THEN
        LEXTRA = .TRUE.
        DEPART = ITERAT - NBFIN
      ENDIF

C --- SI ON RECHERCHE UNE DIVERGENCE
C     ET QUE LA METHODE N'UTILISE PAS L'EXTRAPOLATION
C     OU QUE L'ON PEUT PAS ENCORE L'UTILISER ON SORT
      RETOUR = 0

C --- SI LA METHODE UTILISE L'EXTRAPOLATION
      IF ( LEXTRA ) THEN
C        REGRESSION SUR : GLOB_RELA ou GLOB_MAXI ?
         ERRREL = ZR(JERRE + 5 + ITERAT*2 )
         ERRMAX = ZR(JERRE + 5 + ITERAT*2 + 1 )
         IF      ( GLBREL .LT. ERRREL ) THEN
            DECAL = 0
            CIBLE = GLBREL
         ELSE IF ( GLBMAX .LT. ERRMAX ) THEN
            DECAL = 1
            CIBLE = GLBMAX
         ENDIF

C        CALCUL DE LA REGRESSION
         SX  = ZERO
         SY  = ZERO
         SX2 = ZERO
         SYX = ZERO
         XN  = ZERO
         DO 110, I = DEPART, ITERAT
            XX   = LOG( ZR(JERRE+5+I*2+DECAL) )
C           ON DONNE UN POIDS DOUBLE AU 3 DERNIERS POINTS CELA REVIENT
C           A AJOUTER DES POINTS => MEILLEURE EXTRAPOLATION
            IF ( I .GT. ITERAT - 3 ) THEN
               XN   = XN  + DEUX
               SX   = SX  + DEUX*XX
               SY   = SY  + DEUX*I
               SX2  = SX2 + DEUX*(XX**2)
               SYX  = SYX + DEUX*XX*I
            ELSE
               XN   = XN  + UN
               SX   = SX  + XX
               SY   = SY  + I
               SX2  = SX2 + XX**2
               SYX  = SYX + XX*I
            ENDIF
110      CONTINUE
         XDET   = -SX**2 + SX2*XN
         XA0    =  SX2*SY - SX*SYX
         XA1    = -(SX*SY) + SYX*XN
         CIBLEN = (XA0 + XA1*LOG(CIBLE) )/XDET

C        LA METHODE TROUVE UN NOMBRE D'ITERATION < LIMITE ITERATION
C        CELA SE PRODUIT SI ON DONNE ITER_GLOB_MAXI ET ITER_GLOB_ELAS.
C        SI ITER_GLOB_ELAS EST < ITER_GLOB_MAXI ALORS L'EXTRAPOLATION
C        QUI EST FAITE LORS DE ITER_GLOB_ELAS PEUT DONNER UN NOMBRE
C        ENTRE CES 2 VALEURS.
C        ON COMPARE PAR RAPPORT AU MIN DES 2 VALEURS ITER_GLOB
C        IL FAUT FAIRE ATTENTION AUX ARRONDIS PAR SECURITE AJOUT 20%
         IF ( (CIBLEN*1.20D0) .LT. ZR(JERRE+1) ) THEN
            RATIO  = 24.0D0/((3.0D0*NBRPAS+UN)**2 - UN)
            VALIM(1) = NBRPAS
            VALIM(2) = LENIVO
            VALRM(1) = RATIO
            VALRM(2) = DELTAT
            CALL U2MESG('I','SUBDIVISE_11',0,VALKM,2,VALIM,2,VALRM)
            GOTO 8888
         ENDIF

         VALIM(1) = CIBLEN
         VALIM(2) = NINT(XXITER)
         CALL U2MESI('I','SUBDIVISE_16',2,VALIM)
         IF ( CIBLEN .LT. XXITER ) THEN
            IF ( CIBLEN .LE. ITERAT ) THEN
               VALIM(1) = ITERAT
               CALL U2MESI('I','SUBDIVISE_17',1,VALIM)
            ENDIF
            RETOUR = 3
            GOTO 9999
         ELSE
C           CALCUL DU RATIO POUR ATTEINDRE LA CIBLE
            IF ( (CIBLEN-XXITER) .LE. (-10.0D0*XA1/XDET) ) THEN
               RATIO = EXP( (CIBLEN-XXITER)*XDET/XA1 )
            ELSE
               RATIO = EXP( -10.0D0 )
            ENDIF
            RATIO = 0.48485D0*RATIO
            XXBB = ( -UN + (UN+24.0D0/RATIO)**0.5D0 )/3.0D0
            IF ( XXBB .LT. 2.0D0 ) THEN
               NBRPAS = 2
               RATIO  = 0.50D0
            ELSE
               NBRPAS = NINT( XXBB )
            ENDIF
            VALIM(1) = NBRPAS
            VALIM(2) = LENIVO
            VALRM(1) = RATIO
            VALRM(2) = DELTAT
            CALL U2MESG('I','SUBDIVISE_18',0,VALKM,2,VALIM,2,VALRM)
         ENDIF
      ENDIF

C ====================================
C     RATIO ET NBRPAS SONT CONNUS
8888  CONTINUE
C ====================================

      CALL NMIMPR('IMPR','SUBDIVISE',' ',0.D0,NBRPAS)
C      WRITE(UMESS,'(A,E15.8)') '  DELTAT = ',DELTAT
C      WRITE(UMESS,'(A,I4)')    '  NIVEAU = ',LENIVO-1

C ======================================================================
C                    TRAITEMENT DE LA LISTE D'INSTANTS
C ======================================================================
      INSPAS = NBRPAS - 1
C --- ALLONGEMENT DE LA LISTE D'INSTANTS
      CALL JELIRA(PARTPS // '.DITR','LONMAX',LGINI,K8BID)
      LGTEMP = LGINI + INSPAS
      CALL JUVECA(PARTPS // '.DITR',LGTEMP)
      CALL JUVECA(PARTPS // '.DINI',LGTEMP)
      CALL JEVEUO(PARTPS // '.DITR','E',JTEMPS)
      CALL JEVEUO(PARTPS // '.DINI','E',JNIVTP)
      NBINI  = LGINI  - 1
      NBTEMP = LGTEMP - 1

C --- INSERTION DES INSTANTS SUPPLEMENTAIRES
      IF (METHOD(1:7) .EQ. 'EXTRAP_')THEN
C ---    RECOPIE DE LA PARTIE HAUTE DE LA LISTE
         DO 12 I = NBINI, NUMINS, -1
            ZR(JTEMPS+I+INSPAS) = ZR(JTEMPS+I)
            ZI(JNIVTP+I+INSPAS) = ZI(JNIVTP+I)
12       CONTINUE
         INCINS = DELTAT
         INST   = INSTAM
         DO 14 I = NUMINS, NUMINS+INSPAS-1
C        PRISE EN COMPTE DU FAIT QUE :
C           LE Ième    PAS (I<=NbPas/2) EST AFFECTE DE RATIO*I
C           LES AUTRES PAS SONT             AFFECTE DE RATIO*NbPAs/2
            IF ( (I-NUMINS+1) .LE. NBRPAS*0.5D0 ) THEN
               INST = INST + INCINS*RATIO*(I-NUMINS+1)
            ELSE
               INST = INST + INCINS*RATIO*NBRPAS*0.5D0
            ENDIF
            ZR(JTEMPS+I) = INST
            ZI(JNIVTP+I) = ZI(JNIVTP+NUMINS+INSPAS)+1
14       CONTINUE
      ELSE
C        METHODES
C           SIMPLE     : INITIALEMENT IMPLANTEE
         INCINS = (INSTAP - INSTAM) / (RATIO + NBRPAS - 1)
         INST   = INSTAM
         IF ( INCINS .LT. PASMIN ) THEN
            VALKM(1) = 'Pendant la nouvelle subdivision'
            CALL U2MESK('I','SUBDIVISE_13',1,VALKM)
            VALKM(1) = METHOD
            VALIM(1) = LENIVO-1
            VALRM(1) = INCINS*RATIO
            VALRM(2) = PASMIN
            CALL U2MESG('I','SUBDIVISE_15',1,VALKM,1,VALIM,2,VALRM)
            RETOUR = 2
            GOTO 9999
         END IF
C ---    RECOPIE DE LA PARTIE HAUTE DE LA LISTE
         DO 22 I = NBINI, NUMINS, -1
            ZR(JTEMPS+I+INSPAS) = ZR(JTEMPS+I)
            ZI(JNIVTP+I+INSPAS) = ZI(JNIVTP+I)
22       CONTINUE
         DO 24 I = NUMINS, NUMINS+INSPAS-1
C           LE PREMIER PAS EST AFFECTE D'UN RATIO
            IF (I .EQ. NUMINS) THEN
               INST = INST + INCINS*RATIO
            ELSE
               INST = INST + INCINS
            ENDIF
            ZR(JTEMPS+I) = INST
            ZI(JNIVTP+I) = ZI(JNIVTP+NUMINS+INSPAS)+1
24       CONTINUE
         IF ( METHOD(1:6) .NE. 'AUCUNE' ) THEN
            ZI(JNIVTP+NUMINS+INSPAS)=ZI(JNIVTP+NUMINS+INSPAS)+1
         ENDIF
      ENDIF

C ======================================================================
C                           LISTE D'ARCHIVAGE
C ======================================================================

C --- ALLONGEMENT DE LA LISTE D'ARCHIVAGE
      CALL JUVECA(PARTPS // '.DIAL',LGTEMP)
      CALL JEVEUO(PARTPS // '.DIAL','E',JARCH)

C --- AUCUN ARCHIVAGE SUPPLEMENTAIRE SI PAS_ARCH == 0
      IF (FREARC .EQ. 0) THEN
C        RECOPIE DE LA PARTIE HAUTE
         DO 30 I = NBINI, NUMINS, -1
            ZL(JARCH+I+INSPAS) = ZL(JARCH+I)
30       CONTINUE
C        MISE A .FALSE. DES NOUVEAUX INSTANTS
         DO 40 I = NUMINS, NUMINS+INSPAS-1
            ZL(JARCH+I) = .FALSE.
40       CONTINUE

C -- ON RECONSTRUIT LA LISTE D'ARCHIVAGE SI PAS_ARCH <> 0
      ELSE
         DO 50 I = 0, NBTEMP
            ZL(JARCH+I) = .FALSE.
50       CONTINUE
         DO 60 I = FREARC, NBTEMP, FREARC
            ZL(JARCH+I) = .TRUE.
60       CONTINUE
      END IF

9999  CONTINUE
      CALL JEDEMA()

      END
