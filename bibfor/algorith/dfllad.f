      SUBROUTINE DFLLAD(SDLIST)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF ALGORITH  DATE 21/09/2011   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C
      IMPLICIT NONE
      CHARACTER*8  SDLIST
C
C ----------------------------------------------------------------------
C
C OPERATEUR DEFI_LIST_INST
C
C LECTURE DES ADAPTATIONS
C
C MOT-CLEF ADAPTATION
C
C ----------------------------------------------------------------------
C
C CONSTRUCTION DE SDLIST//'.ADAP.EVENR'
C
C     ZR(JAEVR-1 + LAEVR*(IADAPT-1) + 1) <===> 'EVENEMENT' 
C                                             = 0 SI 'AUCUN'
C                                             = 1 SI 'TOUT_INST'
C                                             = 2 SI  SEUIL SANS FORMULE
C                                             = 3 SI  SEUIL AVEC FORMULE
C     ZR(JAEVR-1 + LAEVR*(IADAPT-1) + 2) <===> 'NB_INCR_SEUIL'
C     ZR(JAEVR-1 + LAEVR*(IADAPT-1) + 3) <===> 'NOM_PARA'
C                                               = 1 SI 'NB_ITER_NEWTON'
C     ZR(JAEVR-1 + LAEVR*(IADAPT-1) + 4) <===> 'CRIT_COMP'
C                                               = 1 SI 'LT'
C                                               = 2 SI 'GT'
C                                               = 3 SI 'LE'
C                                               = 4 SI 'GE'
C     ZR(JAEVR-1 + LAEVR*(IADAPT-1) + 5) <===> 'VALE'
C
C CONSTRUCTION DE SDLIST//'.ADAP.EVENK'
C
C     ZR(JAEVK-1 + LAEVK*(IADAPT-1) + 1) <===> 'FORMULE_SEUIL'
C
C CONSTRUCTION DE SDLIST//'.ADAP.TPLUR'
C
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 1) <===> 'MODE_CALCUL_TPLUS'
C                                               = 1 SI 'FIXE'
C                                               = 2 SI 'DELTA_GRANDEUR'
C                                               = 3 SI 'ITER_NEWTON'
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 2) <===> 'PCENT_AUGM'
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 3) <===> 'VALE_REF'
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 4) <===> NUMERO DE LA COMPOSANTE
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 5) <===> 'NB_ITER_NEWTON_REF'
C     ZR(JATPR-1 + LATPR*(IADAPT-1) + 6) <===> NUMERO DE LA FORMULE
C                                               = 1 SI 'OLIVER'
C
C CONSTRUCTION DE SDLIST//'.ADAP.TPLUK'
C
C     ZR(JATPK-1 + LATPK*(IADAPT-1) + 1) <===> 'NOM_PARA'
C     ZR(JATPK-1 + LATPK*(IADAPT-1) + 2) <===> 'NOM_CHAM'
C     ZR(JATPK-1 + LATPK*(IADAPT-1) + 3) <===> 'NOM_CMP'
C     ZR(JATPK-1 + LATPK*(IADAPT-1) + 4) <===> 'FORMULE_TPLUS'
C
C IN  SDLIST : NOM DE LA SD RESULTAT
C
C -------------- DEBUT DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C ---------------- FIN DECLARATIONS NORMALISEES JEVEUX -----------------
C
      CHARACTER*16 MCFACT
      INTEGER      NADAPT
      INTEGER      IBID,NIT,NBINSE
      INTEGER      IADAPT
      CHARACTER*16 EVEN,NOPARA,CRICOM,MODETP,NOCHAM
      CHARACTER*8  NOMGD,DINOGD,NOCMP
      INTEGER      JLINR
      REAL*8       PCENT,VALERE,VALE
      INTEGER      VALEI,NUCMP
      INTEGER      DFLLVD
      CHARACTER*24 LISAVR,LISAVK,LISTPR,LISTPK
      INTEGER      LAEVR,LAEVK,LATPR,LATPK
      INTEGER      JAEVR,JAEVK,JATPR,JATPK
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- INITIALISATIONS
C
      MCFACT = 'ADAPTATION'
      NADAPT = 0
      CALL JEVEUO(SDLIST//'.LIST.INFOR','E',JLINR )
C
C --- TAILLE DES VECTEURS
C
      LAEVR  = DFLLVD('LAEVR')
      LAEVK  = DFLLVD('LAEVK')
      LATPR  = DFLLVD('LATPR')
      LATPK  = DFLLVD('LATPK')
C
C --- NADAPT: NOMBRE D'OCCURENCE DU MOT-CLE FACTEUR 'ADAPTATION'
C
      CALL GETFAC(MCFACT,NADAPT)
C
C --- CREATION DES OBJETS
C
      LISAVR = SDLIST(1:8)//'.ADAP.EVENR'
      LISAVK = SDLIST(1:8)//'.ADAP.EVENK'
      LISTPR = SDLIST(1:8)//'.ADAP.TPLUR'
      LISTPK = SDLIST(1:8)//'.ADAP.TPLUK'    
      CALL WKVECT(LISAVR,'G V R',  NADAPT*LAEVR,JAEVR)
      CALL WKVECT(LISAVK,'G V K8', NADAPT*LAEVK,JAEVK)
      CALL WKVECT(LISTPR,'G V R',  NADAPT*LATPR,JATPR)
      CALL WKVECT(LISTPK,'G V K16',NADAPT*LATPK,JATPK)
      ZR(JLINR-1+10) = NADAPT
C
C --- LECTURE INFOS
C
      DO 200 IADAPT = 1,NADAPT
C
C ----- EVENEMENT POUR L'ADAPTATION
C
        CALL GETVTX(MCFACT,'EVENEMENT',IADAPT,IARG,1,EVEN,IBID)
        IF (EVEN.EQ.'AUCUN') THEN
          ZR(JAEVR-1+LAEVR*(IADAPT-1)+1) = 0.D0
          CALL U2MESS('A','DISCRETISATION_5')
        ELSEIF (EVEN.EQ.'TOUT_INST') THEN
          ZR(JAEVR-1+LAEVR*(IADAPT-1)+1) = 1.D0
        ELSEIF (EVEN.EQ.'SEUIL') THEN
          ZR(JAEVR-1+LAEVR*(IADAPT-1)+1) = 2.D0
        ELSE
          CALL ASSERT(.FALSE.)  
        ENDIF
C
C ----- OPTIONS POUR L'ADAPTATION 'SEUIL'
C
        IF (EVEN.EQ.'SEUIL') THEN
          CALL GETVIS(MCFACT,'NB_INCR_SEUIL',IADAPT,IARG,1,NBINSE,IBID)
          ZR(JAEVR-1+LAEVR*(IADAPT-1)+2) = NBINSE
          CALL GETVTX(MCFACT,'NOM_PARA'     ,IADAPT,IARG,1,NOPARA,IBID)
          IF (NOPARA.EQ.'NB_ITER_NEWTON') THEN          
            ZR(JAEVR-1+LAEVR*(IADAPT-1)+3) = 1.D0
            VALEI  = 0
            CALL GETVIS(MCFACT,'VALE_I',IADAPT,IARG,1,VALEI,IBID)
            VALE   = VALEI
          ELSE 
            CALL ASSERT(.FALSE.)
          ENDIF
          ZR(JAEVR-1+LAEVR*(IADAPT-1)+5) = VALE
          CALL GETVTX(MCFACT,'CRIT_COMP'    ,IADAPT,IARG,1,CRICOM,IBID)
          IF     (CRICOM.EQ.'LT') THEN
            ZR(JAEVR-1+LAEVR*(IADAPT-1)+4) = 1.D0
          ELSEIF (CRICOM.EQ.'GT') THEN
            ZR(JAEVR-1+LAEVR*(IADAPT-1)+4) = 2.D0
          ELSEIF (CRICOM.EQ.'LE') THEN
            ZR(JAEVR-1+LAEVR*(IADAPT-1)+4) = 3.D0
          ELSEIF (CRICOM.EQ.'GE') THEN
            ZR(JAEVR-1+LAEVR*(IADAPT-1)+4) = 4.D0
          ELSE
            CALL ASSERT(.FALSE.)  
          ENDIF
        ENDIF
C
C ----- DONNEES CONCERNANT LE MODE DE CALCUL DE T+
C
        CALL GETVTX(MCFACT,'MODE_CALCUL_TPLUS',IADAPT,IARG,1,
     &              MODETP,IBID)
        IF (MODETP.EQ.'FIXE') THEN
          ZR(JATPR-1+LATPR*(IADAPT-1)+1) = 1.D0       
        ELSEIF (MODETP.EQ.'DELTA_GRANDEUR') THEN
          ZR(JATPR-1+LATPR*(IADAPT-1)+1) = 2.D0       
        ELSEIF (MODETP.EQ.'ITER_NEWTON') THEN
          ZR(JATPR-1+LATPR*(IADAPT-1)+1) = 3.D0
        ELSEIF (MODETP.EQ.'IMPLEX') THEN
          ZR(JATPR-1+LATPR*(IADAPT-1)+1) = 5.D0
          IF (EVEN.NE.'TOUT_INST') THEN
             CALL U2MESS('F','DISCRETISATION_14')
          ENDIF        
        ELSE
          CALL ASSERT(.FALSE.)      
        ENDIF
C
C ----- OPTIONS MODE DE CALCUL DE T+, FIXE
C        
        IF (MODETP.EQ.'FIXE') THEN
          CALL GETVR8(MCFACT,'PCENT_AUGM',IADAPT,IARG,1,PCENT,IBID)
          ZR(JATPR-1+LATPR*(IADAPT-1)+2) = PCENT
        ENDIF
C
C ----- OPTIONS MODE DE CALCUL DE T+, DELTA_GRANDEUR
C        
        IF (MODETP.EQ.'DELTA_GRANDEUR') THEN
          CALL GETVR8(MCFACT,'VALE_REF',IADAPT,IARG,1,VALERE,IBID)
          ZR(JATPR-1+LATPR*(IADAPT-1)+3) = VALERE
          CALL GETVTX(MCFACT,'NOM_PARA',IADAPT,IARG,1,NOPARA,IBID)
          CALL GETVTX(MCFACT,'NOM_CHAM',IADAPT,IARG,1,NOCHAM,IBID)
          CALL GETVTX(MCFACT,'NOM_CMP' ,IADAPT,IARG,1,NOCMP ,IBID)
          CALL ASSERT(IBID.EQ.1)
          NOMGD = DINOGD(NOCHAM)
          CALL UTCMP2 (NOMGD,MCFACT,IADAPT,1,NOCMP,NUCMP,IBID)
          ZK16(JATPK-1+LATPK*(IADAPT-1)+1) = NOPARA
          ZK16(JATPK-1+LATPK*(IADAPT-1)+2) = NOCHAM
          ZK16(JATPK-1+LATPK*(IADAPT-1)+3) = NOCMP
          ZR(JATPR-1+LATPR*(IADAPT-1)+4)   = NUCMP
        ENDIF        
C
C ----- OPTIONS MODE DE CALCUL DE T+, ITER_NEWTON
C        
        IF (MODETP.EQ.'ITER_NEWTON') THEN
          CALL GETVIS(MCFACT,'NB_ITER_NEWTON_REF',IADAPT,IARG,1,
     &                NIT,IBID)
          ZR(JATPR-1+LATPR*(IADAPT-1)+5) = NIT
        ENDIF          
C
 200  CONTINUE
C
      CALL JEDEMA()
      END
