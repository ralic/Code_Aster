      SUBROUTINE CAZOCC(CHAR  ,MOTFAC,IZONE )
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 23/01/2012   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C
      IMPLICIT NONE
      CHARACTER*8  CHAR
      CHARACTER*16 MOTFAC
      INTEGER      IZONE
C
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (METHODE CONTINUE - LECTURE DONNEES)
C
C LECTURE DES PRINCIPALES CARACTERISTIQUES DU CONTACT (SURFACE IZONE)
C REMPLISSAGE DE LA SD 'DEFICO' (SURFACE IZONE)
C
C ----------------------------------------------------------------------
C
C
C IN  CHAR   : NOM UTILISATEUR DU CONCEPT DE CHARGE
C IN  MOTFAC : MOT-CLE FACTEUR (VALANT 'ZONE')
C IN  IZONE  : INDICE POUR LIRE LES DONNEES DANS AFFE_CHAR_MECA
C
C -------------- DEBUT DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C ---------------- FIN DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER      CFMMVD,ZCMCF,ZEXCL
      CHARACTER*24 DEFICO
      INTEGER      NOC,NOCC
      CHARACTER*8  FONFIS,RACSUR,INDUSU,PIVOT
      CHARACTER*24 CARACF,EXCLFR
      INTEGER      JCMCF,JEXCLF
      CHARACTER*16 GLIS,SGRNO,INTEG,STACO0,ALGOC,ALGOF
      REAL*8       REXCLF,DIREXF(3)
      REAL*8       COEFFF,SEUILI
      REAL*8       COEFAF,COEFAC
      REAL*8       ALGOCR,ALGOFR
      REAL*8       ARCHAR,KWEAR,HWEAR
      REAL*8       TYPINT,CTRINI
      INTEGER      PARINT
      LOGICAL      LINTNO,LFROT,LSSCON,LSSFRO,LEXDIR,MMINFL,CFDISL
      LOGICAL      LPIVOT,LFONFI,LRACLQ,LGLISS
      INTEGER      IARG
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ
C
C --- INITIALISATIONS
C
      DEFICO    = CHAR(1:8)//'.CONTACT'
      LFROT     = CFDISL(DEFICO,'FROTTEMENT')
C
      PARINT    = 0
      TYPINT    = 0.D0
      ALGOCR    = 0.D0
      COEFAC    = 100.D0
      ALGOFR    = 0.D0
      COEFFF    = 0.D0
      COEFAF    = 100.D0
      SEUILI    = 0.D0
      ARCHAR    = 0.D0
      KWEAR     = 0.D0
      HWEAR     = 0.D0
      CTRINI    = 0.D0
      LINTNO    = .FALSE.
      LSSCON    = .FALSE.
      LSSFRO    = .FALSE.
      REXCLF    = 0.D0
      DIREXF(1) = 0.D0
      DIREXF(2) = 0.D0
      DIREXF(3) = 0.D0
      LPIVOT    = .FALSE.
      LFONFI    = .FALSE.
      LRACLQ    = .FALSE.
      LGLISS    = .FALSE.
C
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C
      CARACF = DEFICO(1:16)//'.CARACF'
      EXCLFR = DEFICO(1:16)//'.EXCLFR'
C
      CALL JEVEUO(CARACF,'E',JCMCF )
      CALL JEVEUO(EXCLFR,'E',JEXCLF)
C
      ZCMCF = CFMMVD('ZCMCF')
      ZEXCL = CFMMVD('ZEXCL')
C
C --- TYPE INTEGRATION
C
      CALL GETVTX(MOTFAC,'INTEGRATION',IZONE,IARG,1,INTEG,NOC)
      IF (INTEG(1:4) .EQ. 'AUTO') THEN
        LINTNO = .TRUE.
        TYPINT = 1.D0
      ELSE IF (INTEG(1:5) .EQ. 'GAUSS') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 2.D0
      ELSE IF (INTEG(1:7) .EQ. 'SIMPSON') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 3.D0
      ELSE IF (INTEG(1:6) .EQ. 'NCOTES') THEN
        CALL GETVIS(MOTFAC,'ORDRE_INT',IZONE,IARG,1,PARINT,NOC)
        TYPINT = 10.D0*PARINT + 4.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- OPTIONS CONTACT
C
      CALL GETVTX(MOTFAC,'ALGO_CONT',IZONE,IARG,1,ALGOC,NOC)
      IF (ALGOC(1:10) .EQ. 'STANDARD') THEN
        CALL GETVR8(MOTFAC,'COEF_CONT',IZONE,IARG,1,COEFAC,NOC)
        ALGOCR = 1.D0
      ELSEIF (ALGOC(1:14) .EQ. 'PENALISATION') THEN
        CALL GETVR8(MOTFAC,'COEF_PENA_CONT',IZONE,IARG,1,COEFAC,NOC)
        ALGOCR = 3.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- OPTIONS FROTTEMENT
C
      IF (LFROT) THEN
        CALL GETVTX(MOTFAC,'ALGO_FROT',IZONE,IARG,1,ALGOF,NOC)
        IF (ALGOF(1:10) .EQ. 'STANDARD') THEN
          CALL GETVR8(MOTFAC,'COEF_FROT',IZONE,IARG,1,COEFAF,NOC)
          ALGOFR = 1.D0
        ELSEIF (ALGOF(1:14) .EQ. 'PENALISATION') THEN
          CALL GETVR8(MOTFAC,'COEF_PENA_FROT',IZONE,IARG,1,COEFAF,NOC)
          ALGOFR = 3.D0
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
        IF (ALGOC.NE.ALGOF) CALL U2MESS('F','CONTACT_89')
      ELSE
        COEFAF = 0.D0
        ALGOFR = 0.D0
      ENDIF
C
C --- CARACTERISTIQUES DU FROTTEMENT PAR ZONE
C
      IF (LFROT) THEN
        CALL GETVR8(MOTFAC,'COULOMB'   ,IZONE,IARG,1,COEFFF,NOC)
        CALL GETVR8(MOTFAC,'SEUIL_INIT',IZONE,IARG,1,SEUILI,NOC)
        IF (COEFFF.EQ.0.D0) THEN
          COEFAF = 0.D0
          ALGOFR = 0.D0
        ENDIF
      ENDIF
C
C --- LECTURE DES PARAMETRES DE LA LOI D'USURE
C
      IF (LFROT) THEN
        CALL GETVTX(MOTFAC,'USURE',IZONE,IARG,1,INDUSU,NOC)
        IF (INDUSU .EQ. 'ARCHARD') THEN
          ARCHAR = 1.D0
          CALL GETVR8(MOTFAC,'K',IZONE,IARG,1,KWEAR,NOC)
          CALL GETVR8(MOTFAC,'H',IZONE,IARG,1,HWEAR,NOC)
        ELSEIF (INDUSU .EQ. 'SANS') THEN
          ARCHAR = 0.D0
          KWEAR  = 0.D0
          HWEAR  = 0.D0
        ELSE
          CALL ASSERT(.FALSE.)
        ENDIF
      ELSE
        ARCHAR = 0.D0
        KWEAR  = 0.D0
        HWEAR  = 0.D0
      ENDIF
C
C --- TRAITEMENT EXCLUSION NOEUDS CONTACT
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_NO'   ,IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_NOEUD'      ,IZONE,IARG,1,SGRNO,NOCC)
      LSSCON = (NOC.NE.0)  .OR. (NOCC.NE.0)
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_MA'   ,IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_MAILLE'     ,IZONE,IARG,1,SGRNO,NOCC)
      LSSCON = LSSCON.OR.((NOC.NE.0).OR.(NOCC.NE.0))
C
C --- TRAITEMENT EXCLUSION NOEUDS FROTTEMENT
C
      CALL GETVTX(MOTFAC,'SANS_GROUP_NO_FR',IZONE,IARG,1,SGRNO,NOC)
      CALL GETVTX(MOTFAC,'SANS_NOEUD_FR'   ,IZONE,IARG,1,SGRNO,NOCC)
      LSSFRO = (NOC.NE.0) .OR. (NOCC.NE.0)
C
C --- SI NOEUD EXCLUS, ON VERIFIE QU'ON A UNE INTEGRATION AUX NOEUDS
C
      IF (.NOT.LINTNO) THEN
        IF (LSSCON .OR. LSSFRO) THEN
          CALL U2MESS('F','CONTACT_97')
        ENDIF
        IF (.NOT.MMINFL(DEFICO,'MAIT',IZONE )) THEN
          CALL U2MESS('F','CONTACT_98')
        ENDIF
      ENDIF
C
C --- NOMBRE DE DIRECTIONS A EXCLURE ET VECTEUR DIRECTEUR
C
      IF (LSSFRO) THEN
        CALL GETVR8(MOTFAC,'DIRE_EXCL_FROT',IZONE,IARG,3,DIREXF,NOC)
        LEXDIR = (NOC .NE. 0)
        IF (.NOT.LEXDIR) THEN
C ------- TOUTES LES DIRECTIONS SONT EXCLUES
          REXCLF    = 2.D0
          DIREXF(1) = 0.D0
          DIREXF(2) = 0.D0
          DIREXF(3) = 0.D0
        ELSE
C ------- UNE SEULE DIRECTION EST EXCLUE
          REXCLF = 1.D0
        ENDIF
      ELSE
        REXCLF    = 0.D0
        DIREXF(1) = 0.D0
        DIREXF(2) = 0.D0
        DIREXF(3) = 0.D0
      ENDIF
C
C --- TRAITEMENT FOND FISSURE
C
      CALL GETVTX(MOTFAC,'FOND_FISSURE',IZONE,IARG,1,FONFIS,NOC)
      IF (FONFIS .EQ. 'OUI') THEN
        LFONFI = .TRUE.
      ELSEIF (FONFIS .EQ. 'NON') THEN
        LFONFI = .FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- TRAITEMENT RACCORD LINE_QUAD
C
      CALL GETVTX(MOTFAC,'RACCORD_LINE_QUAD',IZONE,IARG,1,RACSUR,NOC)
      IF (RACSUR .EQ. 'OUI') THEN
        LRACLQ = .TRUE.
      ELSEIF (RACSUR .EQ. 'NON') THEN
        LRACLQ = .FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      END IF
C
      IF (LRACLQ.AND.LFONFI) THEN
        CALL U2MESS('F','CONTACT_95')
      ENDIF
C
C --- TRAITEMENT EXCLUSION PIVOT NUL
C
      CALL GETVTX(MOTFAC,'EXCLUSION_PIV_NUL',IZONE,IARG,1,PIVOT,NOC)
      IF (PIVOT .EQ. 'OUI') THEN
        LPIVOT = .TRUE.
      ELSEIF (PIVOT .EQ. 'NON') THEN
        LPIVOT = .FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- CONTACT INITIAL
C
      CALL GETVTX(MOTFAC,'CONTACT_INIT',IZONE,IARG,1,STACO0,NOC)
      IF (STACO0 .EQ. 'OUI') THEN
        CTRINI = 1.D0
      ELSEIF (STACO0 .EQ. 'INTERPENETRE') THEN
        CTRINI = 2.D0
      ELSEIF (STACO0 .EQ. 'NON') THEN
        CTRINI = 0.D0
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
C --- GLISSIERE
C
      CALL GETVTX(MOTFAC,'GLISSIERE',IZONE,IARG,1,GLIS  ,NOC   )
      IF (GLIS(1:3) .EQ. 'OUI') THEN
        LGLISS = .TRUE.
      ELSEIF (GLIS(1:3) .EQ. 'NON') THEN
        LGLISS = .FALSE.
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+1)  = TYPINT
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+2)  = COEFAC
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+3)  = ALGOCR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+4)  = COEFAF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+5)  = ALGOFR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+6)  = COEFFF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+7)  = SEUILI
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+8)  = CTRINI
      IF (LGLISS) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+9) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+9) = 0.D0
      ENDIF
      IF (LSSCON) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+10) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+10) = 0.D0
      ENDIF
      IF (LSSFRO) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+11) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+11) = 0.D0
      ENDIF
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+12) = REXCLF
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+1) = DIREXF(1)
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+2) = DIREXF(2)
      ZR(JEXCLF-1+ZEXCL*(IZONE-1)+3) = DIREXF(3)
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+13) = ARCHAR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+14) = KWEAR
      ZR(JCMCF-1+ZCMCF*(IZONE-1)+15) = HWEAR
C
      IF (LPIVOT) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+16) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+16) = 0.D0
      ENDIF
C
      IF (LFONFI) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+17) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+17) = 0.D0
      ENDIF
C
      IF (LRACLQ) THEN
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+18) = 1.D0
      ELSE
        ZR(JCMCF-1+ZCMCF*(IZONE-1)+18) = 0.D0
      ENDIF
C
      CALL JEDEMA()
      END
