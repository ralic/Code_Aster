      SUBROUTINE CAZOCD(CHAR  ,MOTFAC,FONREE,NOMA  ,NOMO  ,
     &                  NDIM  ,METHOD,LGLIS ,IREAD ,IWRITE)
C
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF MODELISA  DATE 30/04/2007   AUTEUR ABBAS M.ABBAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2007  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
C (AT YOUR OPTION) ANY LATER VERSION.                                   
C                                                                       
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
C                                                                       
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.         
C ======================================================================
C RESPONSABLE ABBAS M.ABBAS
C TOLE CRP_20
C
      IMPLICIT NONE
      CHARACTER*8  CHAR
      CHARACTER*16 MOTFAC,METHOD
      CHARACTER*8  NOMA
      CHARACTER*8  NOMO
      INTEGER      NDIM
      INTEGER      IREAD
      INTEGER      IWRITE
      LOGICAL      LGLIS
      CHARACTER*4  FONREE      
C      
C ----------------------------------------------------------------------
C
C ROUTINE CONTACT (METHODE DISCRETE - LECTURE DONNEES)
C
C LECTURE DES PRINCIPALES CARACTERISTIQUES DU CONTACT (SURFACE IREAD)
C REMPLISSAGE DE LA SD 'DEFICO' (SURFACE IWRITE)
C      
C ----------------------------------------------------------------------
C
C IN  CHAR   : NOM UTILISATEUR DU CONCEPT DE CHARGE
C IN  MOTFAC : MOT-CLE FACTEUR (VALANT 'CONTACT')
C IN  NOMA   : NOM DU MAILLAGE
C IN  NOMO   : NOM DU MODELE
C IN  NDIM   : NOMBRE DE DIMENSIONS DU PROBLEME
C IN  IREAD  : INDICE POUR LIRE LES DONNEES DANS AFFE_CHAR_MECA
C IN  IWRITE : INDICE POUR ECRIRE LES DONNEES DANS LA SD DEFICONT
C IN  METHOD : METHODE DE CONTACT (LAGRANGE, PENALISATION, ETC.)
C IN  LGLISS : .TRUE. SI CONTACT GLISSIERE
C IN  FONREE : FONC OU REEL SUIVANT L'OPERATEUR
C
C -------------- DEBUT DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER ZI
      COMMON /IVARJE/ ZI(1)
      REAL*8 ZR
      COMMON /RVARJE/ ZR(1)
      COMPLEX*16 ZC
      COMMON /CVARJE/ ZC(1)
      LOGICAL ZL
      COMMON /LVARJE/ ZL(1)
      CHARACTER*8 ZK8
      CHARACTER*16 ZK16
      CHARACTER*24 ZK24
      CHARACTER*32 ZK32
      CHARACTER*80 ZK80
      COMMON /KVARJE/ ZK8(1),ZK16(1),ZK24(1),ZK32(1),ZK80(1)
C
C ---------------- FIN DECLARATIONS NORMALISEES JEVEUX -----------------
C
      INTEGER      CFMMVD,ZMETH,ZTOLE,ZCONV,ZCARF,ZTGDE,ZPOUD
      CHARACTER*16 APPA,RECH,FROT,PREC,PROJ,LISS,NORM
      INTEGER      NBREAC,LGBLOC,ITER
      INTEGER      NOC,NOCN,NOCC
      CHARACTER*24 METHCO,TOLECO,CARFRO,DIRCO,SANSNQ
      INTEGER      JMETH,JTOLE,JCARFR,JDIR,JSANSN
      CHARACTER*24 JEUSUP,JEUFO1,JEUFO2,JEUFO3
      INTEGER      JJSUP,JJFO1,JJFO2,JJFO3
      CHARACTER*24 NORLIS,TANDEF,CONVCO,TANPOU
      INTEGER      JNORLI,JTGDEF,JCONV,GCPREA,JPOUDI
      CHARACTER*8  JEUF1,JEUF2,ISTO,REAC
      CHARACTER*3  NOQU
      REAL*8       DIST1,DIST2,LAMB,ALJEU
      REAL*8       DIR(3),PRECIS,RELA
      REAL*8       COEFRO,COEFPN,COEFPT,COEFTE
      LOGICAL      LFROT
      CHARACTER*16 VALK(2)
C
C ----------------------------------------------------------------------
C
      CALL JEMARQ()
C
C --- INITIALISATIONS
C
      COEFPT = 0.D0
      COEFPN = 0.D0
      COEFTE = 0.D0
      COEFRO = 0.D0
      DIST1  = 0.D0
      DIST2  = 0.D0
      LAMB   = 0.D0
      ALJEU  = -1.D0
      PRECIS = 0.D0 
      PREC   = '  '
      LFROT  = .FALSE.
C 
C --- LECTURE DES STRUCTURES DE DONNEES DE CONTACT
C 
      CARFRO = CHAR(1:8)//'.CONTACT.CARFRO'
      CONVCO = CHAR(1:8)//'.CONTACT.CONVCO'
      DIRCO  = CHAR(1:8)//'.CONTACT.DIRCO'
      JEUFO1 = CHAR(1:8)//'.CONTACT.JFO1CO'
      JEUFO2 = CHAR(1:8)//'.CONTACT.JFO2CO'
      JEUFO3 = CHAR(1:8)//'.CONTACT.JFO3CO'
      JEUSUP = CHAR(1:8)//'.CONTACT.JSUPCO'
      METHCO = CHAR(1:8)//'.CONTACT.METHCO'
      NORLIS = CHAR(1:8)//'.CONTACT.NORLIS'
      SANSNQ = CHAR(1:8)//'.CONTACT.SANSNQ'
      TANDEF = CHAR(1:8)//'.CONTACT.TANDEF'
      TOLECO = CHAR(1:8)//'.CONTACT.TOLECO'
      TANPOU = CHAR(1:8)//'.CONTACT.TANPOU'      
C 
      CALL JEVEUO(CARFRO,'E',JCARFR)
      CALL JEVEUO(CONVCO,'E',JCONV)
      CALL JEVEUO(DIRCO ,'E',JDIR)
      CALL JEVEUO(JEUFO1,'E',JJFO1)
      CALL JEVEUO(JEUFO2,'E',JJFO2)
      CALL JEVEUO(JEUFO3,'E',JJFO3)
      CALL JEVEUO(JEUSUP,'E',JJSUP)
      CALL JEVEUO(METHCO,'E',JMETH)
      CALL JEVEUO(NORLIS,'E',JNORLI)
      CALL JEVEUO(SANSNQ,'E',JSANSN)
      CALL JEVEUO(TANDEF,'E',JTGDEF)
      CALL JEVEUO(TANPOU,'E',JPOUDI)      
      CALL JEVEUO(TOLECO,'E',JTOLE)
C
      ZMETH  = CFMMVD('ZMETH')
      ZTOLE  = CFMMVD('ZTOLE')
      ZCONV  = CFMMVD('ZCONV')
      ZCARF  = CFMMVD('ZCARF')
      ZTGDE  = CFMMVD('ZTGDE')
      ZPOUD  = CFMMVD('ZPOUD')       
C
C --- RECUPERATION DE LA METHODE DE CONTACT
C
      IF (METHOD(1:8) .EQ. 'PENALISA') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+6) = -1
      ELSEIF (METHOD(1:8) .EQ. 'LAGRANGI') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+6) = 1
      ELSEIF (METHOD(1:8) .EQ. 'CONTRAIN') THEN
        IF (LGLIS) THEN
          ZI(JMETH+ZMETH*(IWRITE-1)+6) = 7
        ELSE
          ZI(JMETH+ZMETH*(IWRITE-1)+6) = 0
        ENDIF  
      ELSEIF (METHOD(1:3) .EQ. 'GCP') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+6) = 9        
      ELSEIF (METHOD(1:5) .EQ. 'VERIF') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+6) = -2        
      ELSEIF (METHOD(1:4) .EQ. 'XFEM') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+6) = 10               
      ELSE
        VALK(1) = METHOD
        VALK(2) = 'METHODE'
        CALL U2MESK('F','CONTACT3_3',2,VALK)  
      END IF 
C
C --- RECUPERATION DE LA METHODE DE FROTTEMENT
C       
      CALL GETVTX(MOTFAC,'FROTTEMENT',IREAD,1,1,FROT,NOCC)
      IF (NOCC .NE. 0) THEN 
        IF (FROT .EQ. 'COULOMB') THEN
          LFROT = .TRUE.
          CALL GETVR8(MOTFAC,'E_N',1,1,1,COEFPN,NOCN)
          IF (NDIM .EQ. 2) THEN
            IF (METHOD(1:8) .EQ. 'PENALISA') THEN
              IF (NOCN .EQ. 0) THEN
                ZI(JMETH+ZMETH*(IWRITE-1)+6) = 3
              ELSE
                ZI(JMETH+ZMETH*(IWRITE-1)+6) = 5
              ENDIF  
            ELSEIF (METHOD(1:8) .EQ. 'LAGRANGI') THEN
              ZI(JMETH+ZMETH*(IWRITE-1)+6) = 2
            END IF
          ELSEIF (NDIM .EQ. 3) THEN
            IF (METHOD(1:8) .EQ. 'PENALISA') THEN
              IF (NOCN .NE. 0) THEN
                ZI(JMETH+ZMETH*(IWRITE-1)+6) = 5
              ENDIF  
            ELSEIF (METHOD(1:8) .EQ. 'LAGRANGI') THEN
              ZI(JMETH+ZMETH*(IWRITE-1)+6) = 4
            END IF
          END IF
        ELSEIF (FROT .EQ. 'SANS') THEN 
          LFROT = .FALSE. 
        ELSE    
          VALK(1) = FROT
          VALK(2) = 'FROTTEMENT'
          CALL U2MESK('F','CONTACT3_3',2,VALK)           
        END IF
      END IF              
C
C --- OPTIONS POUR L'APPARIEMENT GEOMETRIQUE
C      
C
C --- TOLE_PROJ_EXT
C --- TOLE_PROJ_EXT <0: LA PROJECTION HORS DE LA MAILLE EST INTERDITE
C --- TOLE_PROJ_EXT >0: LA PROJECTION HORS DE LA MAILLE EST AUTORISEE
C ---                    MAIS LIMITEE PAR LAMB
C
      CALL GETVR8(MOTFAC,'TOLE_PROJ_EXT',IREAD,1,1,LAMB,NOC)
      IF (LAMB .LE. 0.D0) THEN
        ZR(JTOLE+ZTOLE*(IWRITE-1)) = -1.D0
      ELSE
        ZR(JTOLE+ZTOLE*(IWRITE-1)) = LAMB
      END IF
C
C --- TOLE_PROJ_INT
C --- TOLE_PROJ_INT   : LA PROJECTION SUR LES ENTITES GEOMETRIQUES
C ---                   INTERNES (NOEUDS, ARETES, DIAGONALES) EST
C ---                   DETECTEE DANS LA ZONE LIMITEE PAR LAMB
C
      CALL GETVR8(MOTFAC,'TOLE_PROJ_INT',IREAD,1,1,LAMB,NOC)
      ZR(JTOLE+ZTOLE*(IWRITE-1)+1) = LAMB      
C
C --- MOT-CLE VECT_Y
C
      IF (LFROT) THEN
        CALL GETVR8(MOTFAC,'VECT_Y',IREAD,1,3,DIR,NOC)
        IF (NOC .NE. 0) THEN
          IF (NDIM .EQ. 2) THEN
            CALL U2MESS('A','CONTACT_55')
          ELSE
            ZI(JMETH+ZMETH*(IWRITE-1)+2)  = 1
            ZR(JTGDEF+ZTGDE*(IWRITE-1))   = DIR(1)
            ZR(JTGDEF+ZTGDE*(IWRITE-1)+1) = DIR(2)
            ZR(JTGDEF+ZTGDE*(IWRITE-1)+2) = DIR(3)            
          END IF
        END IF
      END IF
C
C --- MOT-CLE VECT_ORIE_POU
C
      CALL GETVR8(MOTFAC,'VECT_ORIE_POU',IREAD,1,3,DIR,NOC)
      IF (NOC .NE. 0) THEN
        IF (NDIM .EQ. 2) THEN
          CALL U2MESS('A','CONTACT_56')
        ELSE
          ZI(JMETH+ZMETH*(IWRITE-1)+2)  = 2
          ZR(JPOUDI+ZPOUD*(IWRITE-1))   = DIR(1)
          ZR(JPOUDI+ZPOUD*(IWRITE-1)+1) = DIR(2)
          ZR(JPOUDI+ZPOUD*(IWRITE-1)+2) = DIR(3)
        END IF
      END IF
C
C --- RECUPERATION DU JEU SUPPLEMENTAIRE MECANIQUE POUR LA ZONE IOC
C --- LE JEU TOTAL SERA JEU - JEUSUP (SOIT : D - DIST1 - DIST2)
C
      ZR(JJSUP+IWRITE-1)  = 0.D0
      ZK8(JJFO1+IWRITE-1) = ' '
      ZK8(JJFO2+IWRITE-1) = ' '
C
C --- CAS D'UN JEU SUPPLEMENTAIRE 
C
      IF (FONREE .EQ. 'REEL') THEN
        CALL GETVR8(MOTFAC,'DIST_MAIT',IREAD,1,1,DIST1,NOC)
        CALL GETVR8(MOTFAC,'DIST_ESCL',IREAD,1,1,DIST2,NOC)
        ZR(JJSUP+IWRITE-1) = DIST1 + DIST2
      ELSEIF (FONREE .EQ. 'FONC') THEN
        CALL GETVID(MOTFAC,'DIST_MAIT',IREAD,1,1,JEUF1,NOC)
        IF (NOC .NE. 0) ZK8(JJFO1+IWRITE-1) = JEUF1
        CALL GETVID(MOTFAC,'DIST_ESCL',IREAD,1,1,JEUF2,NOC)
        IF (NOC .NE. 0) ZK8(JJFO2+IWRITE-1) = JEUF2
      END IF
C
C --- CONTACT SANS CALCUL: PARAMETRES SPECIFIQUES
C
      IF (METHOD(1:5) .EQ. 'VERIF') THEN
        CALL CAZOCV(CHAR,MOTFAC,IREAD,IWRITE)
        GOTO 999
      END IF
C
C --- RECUPERATION DU TYPE D'APPARIEMENT
C
      CALL GETVTX(MOTFAC,'APPARIEMENT',IREAD,1,1,APPA,NOC)
C
      IF (APPA(1:5) .EQ. 'NODAL') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+1) = 0
      ELSEIF (APPA(1:9) .EQ. 'MAIT_ESCL') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+1) = 1
      ELSEIF (APPA(1:6) .EQ. 'RIGIDE') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+1) = 9        
      ELSE
        VALK(1) = APPA
        VALK(2) = 'APPARIEMENT'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- MOT-CLE VECT_NORM_ESCL
C
      CALL GETVR8(MOTFAC,'VECT_NORM_ESCL',IREAD,1,3,DIR,NOC)
      IF (NOC .NE. 0) THEN
        IF (APPA(1:5) .NE. 'NODAL') THEN
          CALL U2MESS('F','CONTACT_54')
        END IF
        ZI(JMETH+ZMETH*(IWRITE-1)+1) = 4
        ZR(JDIR+3*(IWRITE-1))   = DIR(1)
        ZR(JDIR+3*(IWRITE-1)+1) = DIR(2)
        ZR(JDIR+3*(IWRITE-1)+2) = DIR(3)
      END IF      
C
C --- APPARIEMENT SYMETRIQUE ?
C
      IF (APPA .EQ. 'MAIT_ESCL_SYME') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+3) = 1
      ELSE
        ZI(JMETH+ZMETH*(IWRITE-1)+3) = 0
      END IF
C
C --- RECUPERATION DU TYPE DE PROJECTION
C
      CALL GETVTX(MOTFAC,'PROJECTION',IREAD,1,1,PROJ,NOC)
C
      IF (PROJ .EQ. 'LINEAIRE') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+4) = 1
      ELSEIF (PROJ .EQ. 'QUADRATIQUE') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+4) = 2
      ELSE
        VALK(1) = PROJ
        VALK(2) = 'PROJECTION'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- RECUPERATION DE L'ENVIRONNEMENT DE RECHERCHE
C
      CALL GETVTX(MOTFAC,'RECHERCHE',IREAD,1,1,RECH,NOC)
C
      IF (RECH(1:12) .EQ. 'NOEUD_BOUCLE') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+5) = 1
      ELSEIF (RECH(1:12) .EQ. 'NOEUD_VOISIN') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+5) = 2
      ELSE
        VALK(1) = RECH
        VALK(2) = 'RECHERCHE'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- PRESENCE DE LISSAGE ?
C
      CALL GETVTX(MOTFAC,'LISSAGE',IREAD,1,1,LISS,NOC)
C
      IF (LISS(1:3) .EQ. 'OUI') THEN
        ZI(JNORLI+(IWRITE-1)+1) = 1
      ELSEIF (LISS(1:3) .EQ. 'NON') THEN
        ZI(JNORLI+(IWRITE-1)+1) = 0
      ELSE
        VALK(1) = LISS
        VALK(2) = 'LISSAGE'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- TYPE DE NORMALE
C
      CALL GETVTX(MOTFAC,'NORMALE',IREAD,1,1,NORM,NOC)
C
      IF (NORM(1:6) .EQ. 'MAIT') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+8) = 0
      ELSEIF (NORM(1:9) .EQ. 'MAIT_ESCL') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+8) = 1
      ELSE
        VALK(1) = NORM
        VALK(2) = 'NORMALE'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF      
C
C --- PARAMETRES DE L'OPTION GLISSIERE
C
      IF ((LGLIS).AND.(METHOD(1:8) .EQ. 'CONTRAIN')) THEN
        CALL GETVR8(MOTFAC,'ALARME_JEU',IREAD,1,1,ALJEU,NOC)
        ZR(JTOLE+ZTOLE*(IWRITE-1)+2) = ALJEU
      END IF  
C
C --- PARAMETRES DE REACTUALISATION GEOMETRIQUE
C
      CALL GETVTX(MOTFAC,'REAC_GEOM',IREAD,1,1,REAC,NOC)
C
      IF (REAC .EQ. 'SANS') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+7) = 0
      ELSEIF (REAC .EQ. 'AUTOMATI') THEN
        ZI(JMETH+ZMETH*(IWRITE-1)+7) = -1
      ELSEIF (REAC .EQ. 'CONTROLE') THEN
        CALL GETVIS(MOTFAC,'NB_REAC_GEOM',IREAD,1,1,NBREAC,NOC)
        ZI(JMETH+ZMETH*(IWRITE-1)+7) = NBREAC
      ELSE
        VALK(1) = REAC
        VALK(2) = 'REAC_GEOM'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- ARRET OU PAS SI MATRICE DE CONTACT SINGULIERE
C
      CALL GETVTX(MOTFAC,'STOP_SINGULIER',IREAD,1,1,ISTO,NOC)
      ZI(JCONV+ZCONV*(IWRITE-1)) = 0
      IF (ISTO .EQ. 'OUI') THEN
        ZI(JCONV+ZCONV*(IWRITE-1)) = 0
      ELSEIF (ISTO .EQ. 'NON') THEN
        ZI(JCONV+ZCONV*(IWRITE-1)) = 1
      ELSE
        VALK(1) = ISTO
        VALK(2) = 'STOP_SINGULIER'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- NOMBRE DE PAQUETS POUR LA RESOLUTION DES SYSTEMES LINEAIRES
C
      CALL GETVIS(MOTFAC,'NB_RESOL',IREAD,1,1,LGBLOC,NOC)
      ZI(JCONV+ZCONV*(IWRITE-1)+1) = LGBLOC
C
C --- NOMBRE D'ITERATIONS DE CONTACT MAX = NBLIAI*ITER_MULT_MAXI
C
      IF (METHOD(1:10) .NE. 'CONTRAINTE') THEN
        CALL GETVIS(MOTFAC,'ITER_MULT_MAXI',IREAD,1,1,ITER,NOC)
        ZI(JCONV+ZCONV*(IWRITE-1)+2) = ITER
      END IF
C
C --- EXCLUSION DE NOEUDS QUADRATIQUES (VOIR CACOOEQ)
C
      CALL GETVTX(MOTFAC,'SANS_NOEUD_QUAD',IREAD,1,1,NOQU,NOC)
      IF (NOQU .EQ. 'OUI') THEN
        ZI(JSANSN+(IWRITE-1)) = 1
      ELSEIF (NOQU .EQ. 'NON') THEN
        ZI(JSANSN+(IWRITE-1)) = 0
      ELSE
        VALK(1) = NOQU
        VALK(2) = 'SANS_NOEUD_QUAD'
        CALL U2MESK('F','CONTACT3_3',2,VALK)
      END IF
C
C --- CARACTERISTIQUES POUR LES METHODES AVEC PENALISATION
C
      IF (METHOD(1:8) .EQ. 'PENALISA') THEN
        CALL GETVR8(MOTFAC,'E_N',1,1,1,COEFPN,NOCN)
        ZR(JCARFR+ZCARF*(IWRITE-1)+1) = COEFPN 
        CALL GETVR8(MOTFAC,'E_T',IREAD,1,1,COEFPT,NOCN)
        ZR(JCARFR+ZCARF*(IWRITE-1)+2) = COEFPT        
      ENDIF
C
C --- PARAMETRES DU FROTTEMENT
C       
      IF (LFROT) THEN
        CALL GETVR8(MOTFAC,'COULOMB',IREAD,1,1,COEFRO,NOC)
        ZR(JCARFR+ZCARF*(IWRITE-1)+3) = COEFRO
        CALL GETVR8(MOTFAC,'COEF_MATR_FROT',IREAD,1,1,COEFTE,NOC)
        ZR(JCARFR+ZCARF*(IWRITE-1)+4) = COEFTE
      END IF
C
C --- PARAMETRE POUR LA METHODE GCP
C
      IF (METHOD(1:3) .EQ. 'GCP') THEN
        CALL GETVR8(MOTFAC,'RESI_ABSO',IREAD,1,1,PRECIS,NOC)
        ZR(JTOLE+ZTOLE*(IWRITE-1)+4) = PRECIS
        CALL GETVIS(MOTFAC,'REAC_ITER',IREAD,1,1,GCPREA,NOC)
        ZR(JTOLE+ZTOLE*(IWRITE-1)+5) = GCPREA
        CALL GETVTX(MOTFAC,'PRE_COND',IREAD,1,1,PREC,NOC)
        IF (PREC.EQ.'SANS') THEN
          ZI(JCONV+ZCONV*(IWRITE-1)+4) = 0
        ELSE IF (PREC.EQ.'DIRICHLET') THEN
          ZI(JCONV+ZCONV*(IWRITE-1)+4) = 1
          CALL GETVR8(MOTFAC,'COEF_RESI',IREAD,1,1,RELA,NOC)
          ZR(JTOLE+ZTOLE*(IWRITE-1)+6) = RELA
        ELSE
          VALK(1) = PREC
          VALK(2) = 'PRE_COND'
          CALL U2MESK('F','CONTACT3_3',2,VALK)
        ENDIF
        CALL GETVTX(MOTFAC,'RECH_LINEAIRE',IREAD,1,1,RECH,NOC)
        IF (RECH.EQ.'ADMISSIBLE') THEN
          ZI(JCONV+ZCONV*(IWRITE-1)+5) = 0
        ELSE IF (RECH.EQ.'NON_ADMISSIBLE') THEN
          ZI(JCONV+ZCONV*(IWRITE-1)+5) = 1
        ELSE
          VALK(1) = RECH
          VALK(2) = 'RECH_LINEAIRE'
          CALL U2MESK('F','CONTACT3_3',2,VALK)
        ENDIF
      END IF
C
 999  CONTINUE
C
      CALL JEDEMA
C
      END
