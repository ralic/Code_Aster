      SUBROUTINE SSRIU2(NOMU)
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF SOUSTRUC  DATE 09/11/2012   AUTEUR DELMAS J.DELMAS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
      IMPLICIT NONE

C     ARGUMENTS:
C     ----------
      INCLUDE 'jeveux.h'

      CHARACTER*32 JEXNUM
      CHARACTER*8 NOMU
C ----------------------------------------------------------------------
C     BUT:
C        1)FACTORISER PARTIELLEMENT LA MATR_ASSE DE RIGIDITE
C             "K_II**(-1)"
C        2)CALCULER PHI_IE=  (K_II**(-1))*K_IE
C     ===>  ATTENTION LE PHI_IE CALCULE EST L'OPPOSE DE CELUI D'IMBERT
C        3)CALCULER KP_EE = K_EE - K_EI*PHI_IE


C     IN: NOMU   : NOM DU MACR_ELEM_STAT

C     OUT:  PHI_IE, KP_EE,
C           "K_II**(-1)" (DANS LE DEBUT DE .RIGIMECA.UALF)


C ----------------------------------------------------------------------


      INTEGER I,SCDI,SCHC,IBLO,IBID
      CHARACTER*8 KBID
      CHARACTER*8 PROMES
      LOGICAL MODIF

      REAL*8 RTBLOC
      CHARACTER*19 NU,MATAS,STOCK


C-----------------------------------------------------------------------
      INTEGER IAKPEE ,IAPHI0 ,IAPHIE ,IASCBL ,IASCDI ,IASCHC ,IASCIB
      INTEGER IBLOLD ,IBLPH ,IER ,II ,IIBLPH ,ISINGU ,J
      INTEGER JDESM ,JREFA ,JUALF ,JVARM ,K ,KK ,LGBLPH
      INTEGER LMAT ,NBBLOC ,NBLPH ,NDDLE ,NDDLI ,NDECI ,NLBLPH
      INTEGER NPVNEG
C-----------------------------------------------------------------------
      CALL JEMARQ()
      NU = NOMU
      NU = NU(1:14)//'.NUME'
      STOCK = NU(1:14)//'.SLCS'
      MATAS = NOMU//'.RIGIMECA'

      MODIF = .TRUE.
      CALL DISMOI('F',
     &    'NOM_PROJ_MESU',NOMU,'MACR_ELEM_STAT',IBID,PROMES,IER)
      IF (PROMES .EQ. ' ') MODIF = .FALSE.

      CALL JEVEUO(NOMU//'.VARM','E',JVARM)
      RTBLOC=ZR(JVARM-1+1)
      CALL JEVEUO(NOMU//'.DESM','E',JDESM)
      NDDLE = ZI(JDESM-1+4)
C     NDDLE = 50
      NDDLI = ZI(JDESM-1+5)

C     -- FACTORISATION PARTIELLE DE LA MATRICE DE RIGIDITE:
C     -----------------------------------------------------
      CALL MTDSCR(MATAS)
      CALL JEVEUO(MATAS(1:19)//'.&INT','E',LMAT)
      CALL TLDLGG(1,LMAT,1,NDDLI,0,NDECI,ISINGU,NPVNEG,IER)
      IF (IER.GT.0) CALL U2MESS('F','ALGORITH5_19')


C     -- ALLOCATION DE PHI_IE ET INITIALISATION PAR K_IE
C     -- ALLOCATION DE KP_EE  ET INITIALISATION PAR K_EE:
C     -------------------------------------------------------

      CALL MTDSC2(ZK24(ZI(LMAT+1)),'SCDI','L',IASCDI)
      CALL JEVEUO(ZK24(ZI(LMAT+1)) (1:19)//'.REFA','L',JREFA)
      CALL JEVEUO(ZK24(JREFA-1+2)(1:14)//'.SLCS.SCHC','L',IASCHC)
      CALL MTDSC2(ZK24(ZI(LMAT+1)),'SCBL','L',IASCBL)
      CALL JELIRA(MATAS//'.UALF','NMAXOC',NBBLOC,KBID)
      CALL JEVEUO(STOCK//'.SCIB','L',IASCIB)

C     NLBLPH : NOMBRE DE LIGNES DE PHI_IE QUE L'ON PEUT REGROUPER
C              DANS UN BLOC DE LONGUEUR 5*RTBLOC
      NLBLPH=MAX(1,MIN(INT(5*RTBLOC*1024)/NDDLI,NDDLE))

C     LGBLPH : LONGUEUR DES BLOCS DE PHI_IE :
      LGBLPH = NLBLPH*NDDLI

C     NBLPH : NOMBRE DE BLOCS DE PHI_IE :
      NBLPH = (NDDLE*NDDLI-1)/LGBLPH + 1


      CALL JECREC(NOMU//'.PHI_IE','G V R','NU','DISPERSE','CONSTANT',
     &            NBLPH)
      CALL JEECRA(NOMU//'.PHI_IE','LONMAX',LGBLPH,KBID)

      CALL WKVECT(NOMU//'.MAEL_RAID_VALE','G V R',(NDDLE*(NDDLE+1)/2),
     &            IAKPEE)

      IBLOLD = 0
      J = 0
      DO 50,IBLPH = 1,NBLPH
        CALL JECROC(JEXNUM(NOMU//'.PHI_IE',IBLPH))
        CALL JEVEUO(JEXNUM(NOMU//'.PHI_IE',IBLPH),'E',IAPHI0)
        DO 30,IIBLPH = 1,NLBLPH
          J = J + 1
          IF (J.GT.NDDLE) GO TO 40
          IAPHIE = IAPHI0 + (IIBLPH-1)*NDDLI
          IBLO = ZI(IASCIB-1+NDDLI+J)
          SCDI = ZI(IASCDI-1+NDDLI+J)
          SCHC = ZI(IASCHC-1+NDDLI+J)
          IF (IBLO.NE.IBLOLD) THEN
            IF (IBLOLD.GT.0) CALL JELIBE(JEXNUM(MATAS//'.UALF',IBLOLD))
            CALL JEVEUO(JEXNUM(MATAS//'.UALF',IBLO),'L',JUALF)
          END IF
          IBLOLD = IBLO
          K = 0

          IF (MODIF) THEN
            DO 210,I = NDDLI + J + 1 - SCHC,NDDLI
              K = K + 1
              ZR(IAPHIE-1+I) = 0.D0
  210       CONTINUE
          ELSE

CCDIR$ IVDEP
            DO 10,I = NDDLI + J + 1 - SCHC,NDDLI
              K = K + 1
              ZR(IAPHIE-1+I) = ZR(JUALF-1+SCDI-SCHC+K)
   10       CONTINUE

CCDIR$ IVDEP
            DO 20,I = MAX(1,J+1-SCHC),J
              II = ((J-1)*J)/2 + I
              ZR(IAKPEE-1+II) = ZR(JUALF-1+SCDI+I-J)
   20       CONTINUE
          ENDIF

   30   CONTINUE
   40   CONTINUE
        CALL JELIBE(JEXNUM(NOMU//'.PHI_IE',IBLPH))
   50 CONTINUE
      IF (IBLOLD.GT.0) CALL JELIBE(JEXNUM(MATAS//'.UALF',IBLOLD))


C     -- CALCUL DE PHI_IE = (K_II**(-1))*K_IE:
C     ----------------------------------------
      IF (MODIF) THEN
      ELSE
       DO 60,IBLPH = 1,NBLPH
        CALL JEVEUO(JEXNUM(NOMU//'.PHI_IE',IBLPH),'E',IAPHI0)
        CALL RLDLR8(ZK24(ZI(LMAT+1)),ZI(IASCHC),ZI(IASCDI),ZI(IASCBL),
     &              NDDLI,NBBLOC,ZR(IAPHI0),NLBLPH)
        CALL JELIBE(JEXNUM(NOMU//'.PHI_IE',IBLPH))
   60  CONTINUE
      ENDIF


C     -- CALCUL DE KP_EE:
C     -------------------
      IF (MODIF) THEN
       CALL CRMERI(PROMES,IAKPEE)
      ELSE
       IBLOLD = 0
       DO 110,J = 1,NDDLE
        IBLO = ZI(IASCIB-1+NDDLI+J)
        SCDI = ZI(IASCDI-1+NDDLI+J)
        SCHC = ZI(IASCHC-1+NDDLI+J)
        IF (IBLO.NE.IBLOLD) THEN
          IF (IBLOLD.GT.0) CALL JELIBE(JEXNUM(MATAS//'.UALF',IBLOLD))
          CALL JEVEUO(JEXNUM(MATAS//'.UALF',IBLO),'L',JUALF)
        END IF
        IBLOLD = IBLO

        I = 0
        DO 100,IBLPH = 1,NBLPH
          CALL JEVEUO(JEXNUM(NOMU//'.PHI_IE',IBLPH),'L',IAPHI0)
          DO 80,IIBLPH = 1,NLBLPH
            I = I + 1
            IF (I.GT.J) GO TO 90
            IAPHIE = IAPHI0 + (IIBLPH-1)*NDDLI
            II = (J* (J-1)/2) + I
            KK = 0
CCDIR$ IVDEP
            DO 70,K = NDDLI + J + 1 - SCHC,NDDLI
              KK = KK + 1
              ZR(IAKPEE-1+II) = ZR(IAKPEE-1+II) -
     &                          ZR(IAPHIE-1+K)*ZR(JUALF-1+SCDI-SCHC+KK)
   70       CONTINUE
   80     CONTINUE
   90     CONTINUE
          CALL JELIBE(JEXNUM(NOMU//'.PHI_IE',IBLPH))
  100   CONTINUE

  110  CONTINUE
       IF (IBLOLD.GT.0) CALL JELIBE(JEXNUM(MATAS//'.UALF',IBLOLD))

C FIN TEST SUR MODIF
      ENDIF


      CALL JELIBE(ZK24(JREFA-1+2)(1:14)//'.SLCS.SCHC')

      CALL JEDEMA()
      END
