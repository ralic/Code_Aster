      SUBROUTINE CMPCHA(NOMCHA,NOMCMP,CORR1,CORR2,NCMP,NCMPMX)
      IMPLICIT NONE
      INCLUDE 'jeveux.h'
      CHARACTER*(*) NOMCHA,NOMCMP,CORR1,CORR2
      INTEGER NCMP,NCMPMX
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF UTILITAI  DATE 13/06/2012   AUTEUR COURTOIS M.COURTOIS 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C   1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C ----------------------------------------------------------------------
C BUT : FOURNIR LE NOMBRE ET LE NOM DES COMPOSANTES DU CHAMP NOMCHA
C       AINSI QUE LA CORRESPONDANCE "COMPOSANTE CHAMP <=> COMPOSANTE
C       GRANDEUR ASSOCIEE"
C       FONCTIONNE AVEC LES CARTES, LES CHAM_NO ET LES CHAM_EL*
C ----------------------------------------------------------------------
C ARGUMENTS :
C ===========
C NOMCHA  IN  K19 : NOM DU CHAMP
C NCMPMX  OUT I   : NOMBRE DE COMPOSANTES DE LA GRANDEUR ASSOCIEE
C NCMP    OUT I   : NOMBRE DE COMPOSANTES EFFECTIVEMENT PRESENTES DANS
C                   LE CHAMP
C NOMCMP  IN/JXOUT K*  :  (LONG=NCMP)
C                   NOM DU VECTEUR JEVEUX QUI CONTIENDRA EN SORTIE LE
C                   NOM DES COMPOSANTES PRESENTES DANS LE CHAMP
C CORR1  IN/JXOUT K*  :   (LONG=NCMPMX)
C              NOM DU VECTEUR JEVEUX QUI CONTIENDRA EN SORTIE LA
C              CORRESPONDANCE ENTRE LE NUMERO D'1 CMP DE LA GRANDEUR
C              ASSOCIEE ET LE NUMERO DE LA MEME CMP DANS NOMCMP
C CORR2  IN/JXOUT K*  :   (LONG=NCMP)
C              NOM DU VECTEUR JEVEUX QUI CONTIENDRA EN SORTIE LA
C              CORRESPONDANCE INVERSE DE CORR1
C ----------------------------------------------------------------------
C  EXEMPLE :
C  SI NOMCHA EST UN CHAMP DE DEPL_R NE CONTENANT QUE 'DY' ET 'DRZ' :
C    NCMP=2
C    NOMCP=('DY','DRZ')
C    CORR1=(0,1,0,0,2,0,...)
C    CORR2=(2,5)
C ----------------------------------------------------------------------
C RESPONSABLE SELLENET N.SELLENET
      INTEGER IFM,NIV,IBID,IRET,NBGR,JCELD,NEC,JCMPGD,JNOCMP
      INTEGER JCORR1,IGR,IMOLO,JMOLO,GD,NBPT,IPT,K,IADG,ICMP
      INTEGER JDESC,LONG,JPRNO,JNUEQ,NBNO,INO,NCMPP,JCORR2
      INTEGER NGRMX,NBEDIT,IGD,IENT,DEBGD,DG(50),IOR,KPT,KCMP
      LOGICAL EXISDG,DIFF
      CHARACTER*1 KBID
      CHARACTER*8 NOMGD,MA
      CHARACTER*16 TYPSD
      CHARACTER*19 CH19,PROFCN
C
      CH19=NOMCHA
      CALL INFNIV(IFM,NIV)
      CALL JEMARQ()
C
      CALL DISMOI('F','TYPE_CHAMP',NOMCHA,'CHAMP',IBID,TYPSD,IRET)
C
      IF (TYPSD.EQ.'NOEU') THEN
        CALL DISMOI('F','NOM_GD',CH19,'CHAM_NO',IBID,NOMGD,IBID)
      ELSEIF (TYPSD(1:2).EQ.'EL') THEN
        CALL DISMOI('F','NOM_GD',CH19,'CHAM_ELEM',IBID,NOMGD,IBID)
      ELSEIF (TYPSD.EQ.'CART') THEN
        CALL DISMOI('F','NOM_GD',CH19,'CARTE',IBID,NOMGD,IBID)
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF
C
      CALL DISMOI('F','NB_EC',NOMGD,'GRANDEUR',NEC,KBID,IBID)
      CALL DISMOI('F','NB_CMP_MAX',NOMGD,'GRANDEUR',NCMPMX,KBID,IBID)
      CALL DISMOI('F','NUM_GD',NOMGD,'GRANDEUR',GD,KBID,IBID)
      CALL JEVEUO(JEXNUM('&CATA.GD.NOMCMP',GD),'L',JCMPGD)
C


C     -- 1. POUR ECONOMISER LES APPELS A EXISDG, ON VA CALCULER
C           UN DESCRIPTEUR_GRANDEUR (DG) "ENVELOPPE" DE TOUS LES
C           POINTS DU CHAMP.
C     ----------------------------------------------------------------
      CALL ASSERT(NEC.LE.50)
      DO 10,K=1,50
        DG(K)=0
   10 CONTINUE


C     -- 1.1 CAS DES CHAM_NO
C     ----------------------------------------------------------------
      IF (TYPSD.EQ.'NOEU') THEN
        CALL JEVEUO(CH19//'.DESC','L',JDESC)
        CALL DISMOI('F','NOM_MAILLA',CH19,'CHAM_NO',IBID,MA,IBID)
        CALL DISMOI('F','NB_NO_MAILLA',MA,'MAILLAGE',NBNO,KBID,IBID)
C
C        -- 1.1.1 CAS DES CHAM_NO A REPRESENTATION CONSTANTE :
        IF (ZI(JDESC-1+2).LT.0) THEN
          PROFCN=' '
          CALL JELIRA(CH19//'.DESC','LONMAX',LONG,KBID)
          CALL ASSERT(LONG.EQ.(2+NEC))
          IADG=JDESC-1+3
          DO 20,K=1,NEC
            DG(K)=ZI(IADG-1+K)
   20     CONTINUE
C
C        -- 1.1.2 CAS DES CHAM_NO A PROF_CHNO:
        ELSE
          CALL DISMOI('F','PROF_CHNO',CH19,'CHAM_NO',IBID,PROFCN,IBID)
          CALL JEVEUO(JEXNUM(PROFCN//'.PRNO',1),'L',JPRNO)
          CALL JEVEUO(PROFCN//'.NUEQ','L',JNUEQ)
          DO 40,INO=1,NBNO
            NCMPP=ZI(JPRNO-1+(INO-1)*(NEC+2)+2)
            IF (NCMPP.NE.0) THEN
              IADG=JPRNO-1+(INO-1)*(NEC+2)+3
              DO 30,K=1,NEC
                DG(K)=IOR(DG(K),ZI(IADG-1+K))
   30         CONTINUE
            ENDIF
   40     CONTINUE
        ENDIF


C     -- 1.2 CAS DES CHAM_ELEM
C     ----------------------------------------------------------------
      ELSEIF (TYPSD(1:2).EQ.'EL') THEN
        CALL JEVEUO(CH19//'.CELD','L',JCELD)
        NBGR=ZI(JCELD-1+2)
C
        DO 70 IGR=1,NBGR
          IMOLO=ZI(JCELD-1+ZI(JCELD-1+4+IGR)+2)
          IF (IMOLO.EQ.0)GOTO 70
          CALL JEVEUO(JEXNUM('&CATA.TE.MODELOC',IMOLO),'L',JMOLO)
          CALL ASSERT(ZI(JMOLO-1+1).LE.3)
          CALL ASSERT(ZI(JMOLO-1+2).EQ.GD)
          DIFF=(ZI(JMOLO-1+4).GT.10000)
          NBPT=MOD(ZI(JMOLO-1+4),10000)
C
          DO 60,IPT=1,NBPT
            KPT=1
            IF (DIFF)KPT=IPT
            IADG=JMOLO-1+4+(KPT-1)*NEC+1
            DO 50,K=1,NEC
              DG(K)=IOR(DG(K),ZI(IADG-1+K))
   50       CONTINUE
   60     CONTINUE
   70   CONTINUE


C     -- 1.3 CAS DES CARTES
C     ----------------------------------------------------------------
      ELSEIF (TYPSD.EQ.'CART') THEN
        CALL JEVEUO(CH19//'.DESC','L',JDESC)
        NGRMX=ZI(JDESC-1+2)
        NBEDIT=ZI(JDESC-1+3)
        DO 90 IGD=1,NBEDIT
          IENT=ZI(JDESC-1+3+2*IGD)
          IF (IENT.NE.0) THEN
            DEBGD=3+2*NGRMX+(IGD-1)*NEC+1
            DO 80 K=1,NEC
              DG(K)=IOR(DG(K),ZI(JDESC-1+DEBGD-1+K))
   80       CONTINUE
          ENDIF
   90   CONTINUE
C
      ELSE
        CALL ASSERT(.FALSE.)
      ENDIF



C     -- CALCUL DE COOR1 :
C     --------------------
      CALL WKVECT(CORR1,'V V I',NCMPMX,JCORR1)
      NCMP=0
      DO 100 ICMP=1,NCMPMX
        IF (EXISDG(DG(1),ICMP)) THEN
          NCMP=NCMP+1
          ZI(JCORR1-1+ICMP)=NCMP
        ENDIF
  100 CONTINUE



C     -- CALCUL DE NOMCMP ET CORR2 :
C     ------------------------------------
      CALL WKVECT(NOMCMP,'V V K8',NCMP,JNOCMP)
      CALL WKVECT(CORR2,'V V I',NCMP,JCORR2)
      KCMP=0
      DO 110,ICMP=1,NCMPMX
        IF (ZI(JCORR1-1+ICMP).GT.0) THEN
          KCMP=KCMP+1
          ZI(JCORR2-1+KCMP)=ICMP
          ZK8(JNOCMP-1+KCMP)=ZK8(JCMPGD-1+ICMP)
        ENDIF
  110 CONTINUE
      CALL ASSERT(KCMP.EQ.NCMP)


      CALL JEDEMA()
      END
