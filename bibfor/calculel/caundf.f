      SUBROUTINE CAUNDF(CODE,OPT,TE)
      IMPLICIT NONE
C            CONFIGURATION MANAGEMENT OF EDF VERSION
C MODIF CALCULEL  DATE 04/09/2012   AUTEUR PELLET J.PELLET 
C ======================================================================
C COPYRIGHT (C) 1991 - 2012  EDF R&D                  WWW.CODE-ASTER.ORG
C THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
C IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
C THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
C (AT YOUR OPTION) ANY LATER VERSION.
C
C THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
C WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
C MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
C GENERAL PUBLIC LICENSE FOR MORE DETAILS.
C
C YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
C ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
C    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
C ======================================================================
C RESPONSABLE PELLET J.PELLET
C     ARGUMENTS:
C     ----------
      INCLUDE 'jeveux.h'
      INTEGER OPT,TE
      CHARACTER*5 CODE
C ----------------------------------------------------------------------
C     ENTREES:
C      CODE :  / 'ECRIT' : ON ECRIT UNE VALEUR UNDEF AU BOUT DES CHLOC
C              / 'VERIF' : ON VERIFIE LA VALEUR UNDEF AU BOUT DES CHLOC
C      OPT : OPTION
C      TE  : TYPE_ELEMENT
C ----------------------------------------------------------------------
      COMMON /CAII02/IAOPTT,LGCO,IAOPMO,ILOPMO,IAOPNO,ILOPNO,IAOPDS,
     &       IAOPPA,NPARIO,NPARIN,IAMLOC,ILMLOC,IADSGD
      INTEGER        NBGR,IGR,NBELGR,JCTEAT,LCTEAT,IAWLOC,IAWLO2,IAWTYP
      COMMON /CAII06/NBGR,IGR,NBELGR,JCTEAT,LCTEAT,IAWLOC,IAWLO2,IAWTYP
      COMMON /CAII04/IACHII,IACHIK,IACHIX
      COMMON /CAII07/IACHOI,IACHOK
      INTEGER EVFINI,CALVOI,JREPE,JPTVOI,JELVOI
      COMMON /CAII19/EVFINI,CALVOI,JREPE,JPTVOI,JELVOI
      INTEGER NBPARA,ISNNEM,INDIK8,INNEM
      CHARACTER*8 NOPARA
      INTEGER NP,IPAR
      INTEGER IAOPTT,LGCO,IAOPMO,ILOPMO,IAOPNO,ILOPNO,IAOPDS,IAOPPA
      INTEGER NPARIO,NPARIN,IAMLOC,ILMLOC,IADSGD
      INTEGER IACHII,IACHIK,IACHIX,IACHOI
      INTEGER IACHOK,IPARG,LGGREL,IACHLO
      CHARACTER*3 TYPSCA
      CHARACTER*8 NOMPAR
      LOGICAL ECRAS,ARRET
      CHARACTER*16 NOMTE,NOMOPT
      INTEGER IISNAN,ICH,DEBUGR,LGCATA
      REAL*8 RNNEM,R8NNEM
      CHARACTER*8 KNNEM
      CHARACTER*24 VALK(3)

C DEB-------------------------------------------------------------------

      INNEM = ISNNEM()
      RNNEM = R8NNEM()
      KNNEM='????????'

      CALL ASSERT((CODE.EQ.'ECRIT').OR.(CODE.EQ.'VERIF'))


      IF (CODE.EQ.'ECRIT') THEN
C     ------------------------------------------------

C        -- CHAMPS "IN" ET "OUT" :
        DO 10 IPARG = 1,NPARIO
          LGCATA=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+2)
          IF (LGCATA.LE.0) GOTO 10
          IACHLO=ZI(IAWLOC-1+3*(IPARG-1)+1)
          IF ((IACHLO.EQ.-1) .OR. (IACHLO.EQ.-2)) GOTO 10

          TYPSCA = ZK8(IAWTYP-1+IPARG)
          LGGREL=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+4)
          DEBUGR=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+5)

          IF (TYPSCA.EQ.'R') THEN
            ZR(IACHLO-1+DEBUGR-1+LGGREL+1) = RNNEM
          ELSE IF (TYPSCA.EQ.'C') THEN
            ZC(IACHLO-1+DEBUGR-1+LGGREL+1) = DCMPLX(RNNEM,RNNEM)
          ELSE IF (TYPSCA.EQ.'I') THEN
            ZI(IACHLO-1+DEBUGR-1+LGGREL+1) = INNEM
          ELSE IF (TYPSCA.EQ.'K8') THEN
            ZK8(IACHLO-1+DEBUGR-1+LGGREL+1) = KNNEM
          ELSE IF (TYPSCA.EQ.'K16') THEN
            ZK16(IACHLO-1+DEBUGR-1+LGGREL+1) = KNNEM
          ELSE IF (TYPSCA.EQ.'K24') THEN
            ZK24(IACHLO-1+DEBUGR-1+LGGREL+1) = KNNEM
          ELSE
            CALL ASSERT(.FALSE.)
          END IF
   10   CONTINUE



      ELSE IF (CODE.EQ.'VERIF') THEN
C     ------------------------------------------------

C        -- CHAMPS "OUT" :
        ARRET = .FALSE.
        NP = NBPARA(OPT,TE,'OUT')
        DO 30 IPAR = 1,NP
          ECRAS=.FALSE.
          NOMPAR = NOPARA(OPT,TE,'OUT',IPAR)
          IPARG = INDIK8(ZK8(IAOPPA),NOMPAR,1,NPARIO)
          LGCATA=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+2)
          IF (LGCATA.LE.0) GOTO 30
          ICH=ZI(IAWLOC-1+3*(IPARG-1)+3)
          IF (ICH.EQ.0) GOTO 30
          IACHLO=ZI(IAWLOC-1+3*(IPARG-1)+1)
          IF ((IACHLO.EQ.-1) .OR. (IACHLO.EQ.-2)) GOTO 30

          TYPSCA = ZK8(IAWTYP-1+IPARG)
          LGGREL=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+4)
          DEBUGR=ZI(IAWLO2-1+5*(NBGR*(IPARG-1)+IGR-1)+5)


          IF (TYPSCA.EQ.'R') THEN
            IF (IISNAN(ZR(IACHLO-1+DEBUGR-1+LGGREL+1)).EQ.0)
     &          ECRAS=.TRUE.
          ELSE IF (TYPSCA.EQ.'C') THEN
            IF (IISNAN(DBLE(ZC(IACHLO-1+DEBUGR-1+LGGREL+1))).EQ.0)
     &          ECRAS=.TRUE.
            IF (IISNAN(DIMAG(ZC(IACHLO-1+DEBUGR-1+LGGREL+1))).EQ.0)
     &          ECRAS=.TRUE.
          ELSE IF (TYPSCA.EQ.'I') THEN
            IF (ZI(IACHLO-1+DEBUGR-1+LGGREL+1).NE.INNEM) ECRAS=.TRUE.
          ELSE
            CALL ASSERT(.FALSE.)
          END IF

          IF (ECRAS) THEN
            ARRET = .TRUE.
            CALL JENUNO(JEXNUM('&CATA.TE.NOMTE',TE),NOMTE)
            CALL JENUNO(JEXNUM('&CATA.OP.NOMOPT',OPT),NOMOPT)
             VALK(1) = NOMTE
             VALK(2) = NOMOPT
             VALK(3) = NOMPAR
             CALL U2MESK('E','CALCULEL_42', 3 ,VALK)
          END IF

   30   CONTINUE

        CALL ASSERT(.NOT.ARRET)

      END IF


      END
