#& MODIF COMMANDE  DATE 04/10/2010   AUTEUR GNICOLAS G.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS


from Macro.macr_adap_mail_ops import macr_adap_mail_ops

def macr_adap_mail_prod(self,MAJ_CHAM,ADAPTATION,**args):
#
# 0. Typage des structures produites
#
  maillage_np1=args['MAILLAGE_NP1']
  self.type_sdprod(maillage_np1,maillage_sdaster)
#
  if ( args['MAILLAGE_NP1_ANNEXE'] is not None ) :
    maillage_np1_annexe=args['MAILLAGE_NP1_ANNEXE']
    self.type_sdprod(maillage_np1_annexe,maillage_sdaster)
#
  if MAJ_CHAM == None:return None
# Remarque : la liste qui suit doit etre conforme à son homologue de LIRE_CHAMP
  for ch in MAJ_CHAM:
    t=ch['TYPE_CHAM']
    if t[0:5] == "NOEU_":self.type_sdprod(ch['CHAM_MAJ'],cham_no_sdaster)
    if t[0:2] == "EL":   self.type_sdprod(ch['CHAM_MAJ'],cham_elem)
  return None


MACR_ADAP_MAIL=MACRO(nom="MACR_ADAP_MAIL",op=macr_adap_mail_ops,sd_prod=macr_adap_mail_prod,
                     fr="Adapter un maillage avec le logiciel HOMARD.",
                     ang="Mesh adaptation with the HOMARD software.",
                     docu="U7.03.01-b",UIinfo={"groupe":("Maillage",)},
#
# 1. Le niveau d'information
#
  INFO = SIMP(statut='f',typ='I',defaut=1,into=(1,2,3,4)),
#
# 2. Version de HOMARD
#
  VERSION_HOMARD = SIMP(statut='f',typ='TXM',defaut="V9_6",
                        into=("V9_6", "V9_N", "V9_N_PERSO"),
                        fr="Version de HOMARD",
                        ang="HOMARD release"),
#
# 3. Langue des messages produits par HOMARD
#
  LANGUE = SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                fr="Langue des messages produits par HOMARD.",
                ang="Language for the HOMARD messages." ),
#
# 4. Les maillages
# 4.1. Quel que soit le type de traitement, il faut donner  :
#      A. Le concept du maillage initial (entree)
#      B. Le concept du maillage final (sortie)
#
  MAILLAGE_N   = SIMP(statut='o',typ=maillage_sdaster,
                      fr="Maillage avant adaptation",
                      ang="Mesh before adaptation" ),
#
  MAILLAGE_NP1 = SIMP(statut='o',typ=CO,
                      fr="Maillage apres adaptation",
                      ang="Mesh after adaptation" ),
#
# 4.2. Eventuellement, on peut produire un maillage annexe
#      Actuellement, c'est le maillage n+1, mais de degré différent.
#
  MAILLAGE_NP1_ANNEXE = SIMP(statut='f',typ=CO,
                             fr="Maillage annexe apres adaptation",
                             ang="Additional mesh after adaptation" ),
#
# 5. Le pilotage de l'adaptation, avec les variantes suivantes :
#  . Raffinement et deraffinement, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon un champ d'indicateurs d'erreur
#  . Deraffinement seul, selon un champ d'indicateurs d'erreur
#  . Raffinement seul, selon des zones geometriques
#  . Raffinement uniforme : toutes les mailles sont divisées
#  . Deraffinement uniforme : toutes les mailles sont regroupées
#  . Modification : le maillage subit des transformations specifiques
#  . Rien : le maillage est le meme a la sortie et a l'entree
#
  ADAPTATION = SIMP(statut='o',typ='TXM',
                    into=("RAFF_DERA","RAFFINEMENT","DERAFFINEMENT","RAFFINEMENT_ZONE", \
                          "RAFFINEMENT_UNIFORME","DERAFFINEMENT_UNIFORME", \
                          "MODIFICATION","RIEN"),
                    fr="Pilotage de l'adaptation : selon un indicateur d'erreur ou uniforme.",
                    ang="Adaptation control : either among an error indicator or uniform" ),
#
# 6. Pour de l'adaptation libre, il faut un indicateur d'erreur
#
  b_indicateur_d_erreur = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                              (ADAPTATION == 'RAFFINEMENT') or \
                                              (ADAPTATION == 'DERAFFINEMENT') " ,
                                fr="Pour une adaptation libre, choix de l'indicateur d'erreur ou d'une zone à raffiner",
                                ang="For a free adaptation, selection of the error indicator or of a zone",
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT_N')),
#
# 6.1. Repérage de la zone à raffiner à l'aide d'un indicateur
#
# 6.1.1. Sous forme de champ de grandeur
#
    CHAM_GD    = SIMP(statut='f',typ=cham_gd_sdaster,
                      fr="Champ de grandeur Code_Aster contenant l'indicateur d'erreur",
                      ang="Code_Aster champ de grandeur with error indicator" ),
#
# 6.1.2. Sous forme de concept resultat_sdaster
#
    RESULTAT_N = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther) ,
                      fr="Concept resultat Code_Aster contenant l'indicateur d'erreur",
                      ang="The Code_Aster result with error indicator" ),
#
    b_champ_indicateur = BLOC(condition="(RESULTAT_N != None)",
      NOM_CHAM = SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO(),
                        fr="Champ de l'indicateur d'erreur dans le résultat",
                        ang="The error indicator field in the result structure" ),
    ),
#
# 6.1.3. Est-ce un champ dérivé
#
    b_sensibilite = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Est-ce un champ dérivé",
                        ang="Is the indicator a derivative field",
#
      SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                         fr="Paramètre de sensibilité.",
                         ang="Sensitivity parameter")
#
    ),
#
# 6.1.4. La ou les composantes retenues
#
    b_composante = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                        fr="Choix de la composante ou des composantes pour l'indicateur",
                        ang="Selection of the component(s) for the error indicator",
#
      NOM_CMP = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                            fr="Liste des composante(s) retenue(s) pour l'indicateur d'erreur.",
                            ang="List of the selected component(s) for the error indicator." ),
#
    ),
#
# 6.1.5. Le paramètre temporel pour l'indicateur
#
    b_parametre_temporel = BLOC(condition="(RESULTAT_N != None)",
                                fr="Choix éventuel du paramètre temporel pour l'indicateur",
                                ang="Time selection for the error indicator (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 6.1.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre",
                        ang="Rank" ),
#
# 6.1.5.2. Soit l'instant
# 6.1.5.2.1. Sa valeur
#
      INST       = SIMP(statut='f',typ='R',
                        fr="Instant associé",
                        ang="Instant" ),
#
# 6.1.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Precision for the choice of the instant",
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
      ),
#
    ),
#
# 6.1.6. Type de valeur de l'indicateur : absolue (norme L2), norme infinie, ou relative
#
    b_valeur_indicateur = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                               fr="Type de valeur pour l'indicateur",
                               ang="Type of the value type for the error indicator",
#
      TYPE_VALEUR_INDICA = SIMP(statut='f',typ='TXM',defaut="V_ABSOLUE",
                                into=("V_ABSOLUE", "NORME_L2", "NORME_INFINIE", "V_RELATIVE"),
                                fr="Valeur absolue, norme des composantes ou valeur relative pour l'indicateur",
                                ang="Absolute value, norm or relative value for the error indicator" ),
#
    ),
#
# 6.1.7. Type d'opération sur l'indicateur : la valeur par maille ou le max du saut entre mailles
#
    b_usage_indicateur = BLOC(condition=" (RESULTAT_N != None) or (CHAM_GD != None) ",
                              fr="Usage de l'indicateur : direct ou saut",
                              ang="Use type for the error indicator : direct or jump",
#
      TYPE_OPER_INDICA = SIMP(statut='f',typ='TXM',defaut="MAILLE",into=("MAILLE","SAUT"),
                              fr="Usage de l'indicateur : la valeur par maille ou le saut entre mailles voisines",
                              ang="Use of the indicator : value over every mesh or jump between neighbour" ),
#
    ),
#
  ) ,
#
# 7. Les criteres pour de l'adaptation libre avec un indicateur d'erreur :
#        absolu, relatif, en proportion d'entite
# 7.1. Pour le raffinement :
#
  b_critere_de_raffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                 (ADAPTATION == 'RAFFINEMENT') " ,
                                fr="Critère de raffinement.",
                                ang="Refinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
#
    CRIT_RAFF_ABS = SIMP(statut='f',typ='R',
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_RAFF_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),
    CRIT_RAFF_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes : ratio between 0. and 1." ),
  ) ,
#
# 7.2. Pour le deraffinement :
#
  b_critere_de_deraffinement = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') " ,
                                     fr="Critère de déraffinement.",
                                     ang="Unrefinement threshold.",
#
    regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
#
    CRIT_DERA_ABS = SIMP(statut='f',typ='R' ,
                         fr="Critère absolu",
                         ang="Absolute threshold" ),
    CRIT_DERA_REL = SIMP(statut='f',typ='R',
                         fr="Critère relatif : fraction réelle entre 0. et 1.",
                         ang="Relative threshold : ratio between 0. and 1." ),
    CRIT_DERA_PE  = SIMP(statut='f',typ='R',
                         fr="Pourcentage de mailles : fraction réelle entre 0. et 1.",
                         ang="Percentage of meshes : ratio between 0. and 1." ),
  ) ,
#
# 8. Pour de l'adaptation par zone, définitions des zones
#
  b_zone = BLOC( condition = " (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                 fr="Pour une adaptation selon une zone à raffiner",
                 ang="For adaptation among a zone",
#
    ZONE = FACT(statut='f',max='**',
                fr="Définition de zones à raffiner.",
                ang="Refined zone definition.",
#
# 8.1. Type de la zone
#
      TYPE = SIMP(statut='o',typ='TXM',into=("RECTANGLE", "BOITE", "DISQUE", "SPHERE", "CYLINDRE", "DISQUE_PERCE", "TUYAU"),
                  fr="Type de la zone",
                  ang="Type of the zone" ),
#
# Ne sachant pas exploiter les blocs, je mets des regles
#
      regles=(AU_MOINS_UN('X_MINI','X_CENTRE','HAUTEUR'),
              EXCLUS('X_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','X_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('Z_MINI','Z_CENTRE','HAUTEUR',),
              EXCLUS('X_MINI','RAYON',),
              EXCLUS('Z_MINI','RAYON',),
              EXCLUS('X_MINI','X_CENTRE','RAYON_INT',),
              EXCLUS('Z_MINI','X_CENTRE','RAYON_INT',),
              EXCLUS('X_MINI','X_CENTRE','RAYON_EXT',),
              EXCLUS('Z_MINI','X_CENTRE','RAYON_EXT',),
              EXCLUS('RAYON','RAYON_INT',),),
#
# 8.2. Une boite rectangulaire ou parallelepipedique
# 8.2.1. Incontournables
#
##gn      b_z_boiteXY = BLOC( condition = " (TYPE == 'RECTANGLE') or (TYPE == 'BOITE') " ,
##gn                          fr="X et Y mini/maxi pour un rectangle ou un parallelepipede.",
##gn                          ang="X and Y min/max for a rectangle or a parallelepipedic box",
      X_MINI = SIMP(statut='f',typ='R',
                    fr="Abscisse minimum de la boite",
                    ang="Minimum X for the box"),
      X_MAXI = SIMP(statut='f',typ='R',
                    fr="Abscisse maximum de la boite",
                    ang="Maximum X for the box"),
      Y_MINI = SIMP(statut='f',typ='R',
                    fr="Ordonnée minimum de la boite",
                    ang="Minimum Y for the box"),
      Y_MAXI = SIMP(statut='f',typ='R',
                      fr="Abscisse maximum de la boite",
                      ang="Maximum Y for the box"),
##gn      ) ,
#
# 8.2.2. Complement pour une boite parallelepipedique
#
##gn      b_z_boiteZ = BLOC( condition = " (TYPE == 'BOITE') " ,
##gn                         fr="Z mini/maxi pour un parallelepipede.",
##gn                         ang="Z min/max for a parallelepipedic box",
      Z_MINI = SIMP(statut='f',typ='R',
                    fr="Cote minimum de la boite",
                    ang="Minimum Z for the box"),
      Z_MAXI = SIMP(statut='f',typ='R',
                    fr="Cote maximum de la boite",
                    ang="Maximum Z for the box"),
##gn      ) ,
#
# 8.3. Rayon pour un disque, une sphere ou un cylindre
#
##gn      b_z_rayon = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
##gn                        fr="Le rayon d'un disque, d'une sphere ou d'un cylindre.",
##gn                        ang="The radius of a disk or of a sphere or of a cylinder.",
      RAYON = SIMP(statut='f',typ='R',
                   fr="Rayon",
                   ang="Radius"),
##gn      ) ,
#
# 8.4. Pour un disque plein ou perce, une sphere
# 8.4.1. Incontournables
#
##gn      b_z_di_sp_XY = BLOC( condition = " (TYPE == 'DISQUE') or (TYPE == 'SPHERE') or (TYPE == 'DISQUE_PERCE') " ,
##gn                           fr="X et Y du centre d'un disque plein ou perce, d'une sphere.",
##gn                           ang="X and Y of the centre of a disk or of a sphere.",
      X_CENTRE = SIMP(statut='f',typ='R',
                      fr="Abscisse du centre du disque ou de la sphere",
                      ang="X for the center of the disk or of the sphere"),
      Y_CENTRE = SIMP(statut='f',typ='R',
                      fr="Ordonnee du centre du disque ou de la sphere",
                      ang="Y for the center of the disk or of the sphere"),
##gn      ) ,
#
# 8.4.2. Complement pour une sphere
#
##gn      b_z_sp_Z = BLOC( condition = " (TYPE == 'SPHERE') " ,
##gn                       fr="Cote du centre de la sphere.",
##gn                       ang="Z for the center of the sphere.",
       Z_CENTRE = SIMP(statut='f',typ='R',
                       fr="Cote du centre de la sphere",
                       ang="Z for the center of the sphere"),
##gn      ) ,
#
# 8.5. Rayons interieur et exterieur pour un disque perce ou un tuyau
#
##gn      b_z_rayon_int_ext = BLOC( condition = " (TYPE == 'DISQUE_PERCE') or (TYPE == 'TUYAU') " ,
##gn                                fr="Le rayon d'un disque perce ou d'un tuyau.",
##gn                                ang="The radius of a holed disk or of a pipe.",
      RAYON_INT = SIMP(statut='f',typ='R',
                       fr="Rayon interieur",
                       ang="Internal radius"),
      RAYON_EXT = SIMP(statut='f',typ='R',
                       fr="Rayon exterieur",
                       ang="External radius"),
##gn      ) ,
#
# 8.6. Un cylindre ou un tuyau
#
##gn      b_z_cylindre_tuyau = BLOC( condition = " (TYPE == 'CYLINDRE') or (TYPE == 'TUYAU') " ,
##gn                                 fr="Pour un cylindre ou un tuyau.",
##gn                                 ang="For a cylinder or a pipe.",
      X_AXE = SIMP(statut='f',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='f',typ='R',
                   fr="Ordonnee du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='f',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
      X_BASE = SIMP(statut='f',typ='R',
                    fr="Abscisse d'un point de la base, sur l'axe",
                    ang="X for the basis, on the axis"),
      Y_BASE = SIMP(statut='f',typ='R',
                    fr="Ordonnee d'un point de la base, sur l'axe",
                    ang="Y for the basis, on the axis"),
      Z_BASE = SIMP(statut='f',typ='R',
                    fr="Cote d'un point de la base, sur l'axe",
                    ang="Z for the basis, on the axis"),
      HAUTEUR = SIMP(statut='f',typ='R',
                     fr="Hauteur",
                     ang="Height"),
##gn     ) ,
#
    ) ,
#
  ) ,
#
# 9. Les niveaux extremes pour le maillage adapte
# 9.1. Pour le raffinement :
#
  b_niveau_maximum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'RAFFINEMENT') or \
                                         (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                         (ADAPTATION == 'RAFFINEMENT_ZONE') " ,
                           fr="Niveau maximum de profondeur de raffinement",
                           ang="Maximum level for the refinement",
    NIVE_MAX = SIMP(statut='f',typ='I',
                    fr="Niveau maximum de profondeur de raffinement",
                    ang="Maximum level for the refinement"),
  ) ,
#
# 9.2. Pour le deraffinement :
#
  b_niveau_minimum = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                         (ADAPTATION == 'DERAFFINEMENT') or \
                                         (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                           fr="Niveau minimum de profondeur de déraffinement",
                           ang="Minimum level for the unrefinement",
    NIVE_MIN = SIMP(statut='f',typ='I',
                    fr="Niveau minimum de profondeur de déraffinement",
                    ang="Minimum level for the unrefinement"),
  ) ,
#
# 10. Filtrage de l'adaptation par des groupes
#
  b_filtrage_par_des_groupes = BLOC( condition = " (ADAPTATION == 'RAFF_DERA') or \
                                                   (ADAPTATION == 'RAFFINEMENT') or \
                                                   (ADAPTATION == 'RAFFINEMENT_UNIFORME') or \
                                                   (ADAPTATION == 'RAFFINEMENT_ZONE') or \
                                                   (ADAPTATION == 'DERAFFINEMENT') or \
                                                   (ADAPTATION == 'DERAFFINEMENT_UNIFORME') " ,
                                fr="Filtrage de l'adaptation par des groupes.",
                                ang="Filtering of adaptation by the groups.",
#
    GROUP_MA = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles pour le filtrage de l'adaptation.",
                    ang="List of the groups of meshes for filtering of the adaptation." ),
#
    GROUP_NO = SIMP(statut='f',typ=grno,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de noeuds pour le filtrage de l'adaptation.",
                    ang="List of the groups of nodes for filtering of the adaptation." ),
  ) ,
#
# 11. Suivi d'une frontiere
#
# 11.1. Definition d'une frontiere par un maillage (valable seulement pour des frontieres 1D)
#
  MAILLAGE_FRONTIERE = SIMP(statut='f',typ=maillage_sdaster,
                           fr="Maillage de la frontiere à suivre",
                           ang="Boundary mesh" ),
#
  b_frontiere = BLOC( condition = " MAILLAGE_FRONTIERE != None " ,
                      fr="Information complémentaire sur la frontière",
                      ang="Further information about boundary",
#
    GROUP_MA_FRONT = SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                          fr="Liste des groupes de mailles définissant la frontière",
                          ang="Mesh groups which define the boundary" ),
#
  ) ,
#
# 11.2. Definition analytique d'une frontiere
#
  FRONTIERE_ANALYTIQUE = FACT(statut='f',max='**',
                              fr="Definition analytique de frontieres a suivre.",
                              ang="Analytical definition of a boundary.",
#
# 11.2.1. Type de la frontiere
#
    TYPE = SIMP(statut='o',typ='TXM',into=("SPHERE", "CYLINDRE"),
                fr="Type de la frontiere",
                ang="Type of the boundary" ),
#
# 11.2.2. Groupe lie a la frontiere
#
    GROUP_MA = SIMP(statut='o',typ=grma,validators=NoRepeat(),max='**',
                    fr="Liste des groupes de mailles definissant la frontiere",
                    ang="Groups of meshes which define the boundary" ),
#
# 11.2.3. Pour une sphere ou un cylindre : rayon et centre
#
    b_fr_rayon = BLOC( condition = " (TYPE == 'SPHERE') or (TYPE == 'CYLINDRE') " ,
                       fr="Le rayon et le centre d'une sphere ou d'un cylindre.",
                       ang="The radius and the centre of a sphere or of a cylinder.",
      RAYON = SIMP(statut='o',typ='R',
                   fr="Rayon",
                   ang="Radius"),
      X_CENTRE = SIMP(statut='o',typ='R',
                      fr="Abscisse du centre",
                      ang="X for the center"),
      Y_CENTRE = SIMP(statut='o',typ='R',
                      fr="Ordonnee du centre",
                      ang="Y for the center"),
      Z_CENTRE = SIMP(statut='o',typ='R',
                      fr="Cote du centre",
                      ang="Z for the center"),
    ) ,
#
# 11.2.4. Complement pour un cylindre
#
    b_fr_cylindre = BLOC( condition = " (TYPE == 'CYLINDRE') " ,
                          fr="Pour un cylindre.",
                          ang="For a cylinder.",
      X_AXE = SIMP(statut='o',typ='R',
                   fr="Abscisse du vecteur directeur de l'axe",
                   ang="X for the axial vector"),
      Y_AXE = SIMP(statut='o',typ='R',
                   fr="Ordonnee du vecteur directeur de l'axe",
                   ang="Y for the axial vector"),
      Z_AXE = SIMP(statut='o',typ='R',
                   fr="Cote du vecteur directeur de l'axe",
                   ang="Z for the axial vector"),
    ) ,
#
  ) ,
#
# 12. Mise à jour de champs sur le nouveau maillage
#
  MAJ_CHAM = FACT(statut='f',max='**',
                  fr="Mise à jour de champs sur le nouveau maillage.",
                  ang="Updating of the fields over the new mesh.",
#
# 12.1. Le nom du champ de grandeur qui contiendra le resultat de la mise a jour
#
    CHAM_MAJ = SIMP(statut='o',typ=CO,
                    fr="Nom du champ de grandeur qui contiendra le champ mis à jour",
                    ang="Name of the field for the updated field"),
#
# 12.2. Le type du champ qui contiendra le resultat de la mise a jour
#
    TYPE_CHAM = SIMP(statut='o',typ='TXM',into=C_TYPE_CHAM_INTO(),
                     fr="Type du champ qui contiendra le champ mis à jour",
                     ang="Type of the field for the updated field" ),
#
# 12.3. Le champ a interpoler
#
    regles=(UN_PARMI('CHAM_GD','RESULTAT')),
#
# 12.3.1. Sous forme de champ de grandeur
#
    CHAM_GD = SIMP(statut='f',typ=cham_gd_sdaster,
                   fr="Champ de grandeur Code_Aster contenant le champ à mettre à jour",
                   ang="Champ de grandeur with the field to be updated" ),
#
# 12.3.2. Sous forme de champ dans un resultat
#
    RESULTAT = SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                    fr="Resultat contenant le champ à mettre à jour",
                    ang="Result with the field to be updated" ),
#
    b_nom_du_champ = BLOC(condition="(RESULTAT != None)",
                          fr="Choix éventuel du nom du champ à interpoler",
                          ang="Selection for the name of the field (option)",
#
      NOM_CHAM = SIMP(statut='o',typ='TXM',into=C_NOM_CHAM_INTO(),
                      fr="Nom du champ à mettre à jour",
                      ang="Name of the field to be updated" ),
#
    ),
#
# 12.4. Est-ce un champ dérivé
#
    SENSIBILITE = SIMP(statut='f',typ=(para_sensi,theta_geom),
                       fr="Paramètre de sensibilité.",
                       ang="Sensitivity parameter"),
#
# 12.5. Le paramètre temporel pour le champ a interpoler
#
    b_parametre_temporel = BLOC(condition="(RESULTAT != None)",
                                fr="Choix éventuel du paramètre temporel pour le champ à interpoler",
                                ang="Time selection for the field (option)",
#
      regles=(EXCLUS('NUME_ORDRE','INST'),),
#
# 12.5.1. Soit le numero d'ordre
#
      NUME_ORDRE = SIMP(statut='f',typ='I',
                        fr="Numero d ordre du champ à mettre à jour",
                        ang="Rank of the field to be updated" ),
#
# 12.5.2. Soit l'instant
# 12.5.2.1. Sa valeur
#
      INST = SIMP(statut='f',typ='R',
                  fr="Instant associé",
                  ang="Instant" ),
#
# 12.5.2.2. La précision du choix de l'instant
#
      b_precision = BLOC(condition="(INST != None)",
                         fr="Choix de la précision du choix de l'instant",
                         ang="Selection for the choice of the instant",
#
        CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU",),
                         fr="Critère de précision sur le choix de l'instant associé",
                         ang="Accuracy criterium over the choice of the instant"),
        b_prec_rela=BLOC(condition="(CRITERE=='RELATIF')",
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.E-6,
                             fr="Précision relative sur le choix de l'instant associé",
                             ang="Relative accuracy over the choice of the instant"),),
        b_prec_abso=BLOC(condition="(CRITERE=='ABSOLU')",
            PRECISION       =SIMP(statut='o',typ='R',
                             fr="Précision absolue sur le choix de l'instant associé",
                             ang="Absolute accuracy over the choice of the instant"),),
#
      ),
#
    ),
  ),
#
# 13. Les Modifications
#
  b_modifications = BLOC( condition = " (ADAPTATION == 'MODIFICATION') " ,
                          fr="Modification de maillage.",
                          ang="Modification of the mesh.",
#
      #regles=(AU_MOINS_UN('DEGRE','JOINT'),),
#
# 13.1. Changement de degre
#
      DEGRE         = SIMP(statut='o',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Changement de degre du maillage",
                          ang="Modification of the degree of the mesh" ),
#
# 13.2. Création des joints
#
      #JOINT         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          #fr="Creations des joints",
                          #ang="Creation of the junctions" ),
#
  ) ,
#
# 14. Les options d'analyse de maillage ; par defaut, on ne fait que les nombres
# 14.1. Nombre de noeuds et mailles
#
  NOMBRE         = SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                        fr="Nombre de noeuds et de mailles du maillage",
                        ang="Number of nodes and meshes in the mesh" ),
#
# 14.2. Determination de la qualité des éléments du maillage
#
  QUALITE        = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Qualité du maillage",
                        ang="Quality of the mesh" ),
#
# 14.3. Connexite du maillage
#
  CONNEXITE      = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Connexité du maillage.",
                        ang="Connexity of the mesh." ),
#
# 14.4. Taille des sous-domaines du maillage
#
  TAILLE         = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Tailles des sous-domaines du maillage.",
                        ang="Sizes of mesh sub-domains." ),
#
# 14.5. Controle de la non-interpenetration des mailles
#
  INTERPENETRATION=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Controle de la non interpénétration des mailles.",
                        ang="Overlapping checking." ),
#
# 14.6. Propriétés du maillage de calcul
#
  PROP_CALCUL    = SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                        fr="Propriétés du maillage de calcul.",
                        ang="Properties of the calculation mesh." ),
#
# 15. Unite logique d'un fichier a ajouter a HOMARD.Configuration
#
  b_unite = BLOC( condition = " (VERSION_HOMARD == 'V9_N') or \
                                (VERSION_HOMARD == 'V9_N_PERSO') " ,
                                fr="Fichier supplementaire.",
                                ang="Additional file.",
#
  UNITE = SIMP(statut='f',typ='I',
               fr="Unite logique a ajouter a HOMARD.Configuration",
               ang="Additional file to HOMARD.Configuration" ),
#
  ) ,
#
# 16. Gestion des mailles autres que celles compatibles avec HOMARD
#       "REFUSER" : elles sont refusées (defaut)
#       "IGNORER" : elles sont ignorées
#
  ELEMENTS_NON_HOMARD = SIMP(statut='f',typ='TXM',defaut="REFUSER",into=("REFUSER","IGNORER"),
                             fr="Acceptation de mailles incompatibles avec HOMARD",
                             ang="Incompatible meshes for HOMARD" ),
#
) ;
