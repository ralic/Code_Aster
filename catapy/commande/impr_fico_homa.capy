#& MODIF COMMANDE  DATE 14/09/2004   AUTEUR MCOURTOI M.COURTOIS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR   
# (AT YOUR OPTION) ANY LATER VERSION.                                 
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT 
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF          
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU    
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                            
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE   
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,       
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.      
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS
IMPR_FICO_HOMA=PROC(nom="IMPR_FICO_HOMA",op= 189, docu="U7.04.01-b",
            UIinfo={"groupes":("Fonction",)},
                    fr="Imprime le fichier de configuration de HOMARD.",
                    ang="Writes the configuration file for HOMARD.",
#
# 1. Le niveau d'information
#
         INFO           =SIMP(statut='f',typ='I',defaut=1,into=(1,2)),
#
# 2. Langue des messages issus de HOMARD
#
         LANGUE =SIMP(statut='f',typ='TXM',defaut="FRANCAIS",    
                      into=("FRANCAIS","FRENCH","ANGLAIS","ENGLISH",),
                      fr="Langue des messages issus de HOMARD.",
                      ang="Language for HOMARD messages." ),
#
# 3. Le nom local du fichier de configuration HOMARD
#
         FICHIER_CONF    =SIMP(statut='o',typ='TXM'),
#
# 4. Le nom local du fichier de données HOMARD
#
         FICHIER_DONN    =SIMP(statut='f',typ='TXM'),
#
# 5. Gestion des éléments autres que des simplexes
#       0 : autres elements refuses (defaut)
#       1 : raffinement sur les simplexes, mais autres acceptes
#       2 : tous
#
         NON_SIMPLEXE   = SIMP(statut='f',typ='I',defaut=0,into=(0,1,2),
                          fr="Type d'éléments acceptés.",
                          ang="Type of authorized elements." ),
#
# 6. Le type de traitement :
#
         TRAITEMENT      =FACT(statut='o',
#
# 6.1. TROIS CHOIX EXCLUSIFS :
#
#      A. ADAPTATION PAR UN INDICATEUR D'ERREUR, AVEC TROIS VARIANTES :
#         . RAFFINEMENT ET DERAFFINEMENT
#         . RAFFINEMENT SEUL
#         . DERAFFINEMENT SEUL
#      B. ADAPTATION UNIFORME, AVEC DEUX VARIANTES :
#         . RAFFINEMENT SEUL
#         . DERAFFINEMENT SEUL
#         . RIEN : LE MAILLAGE EST LE MEME A LA SORTIE ET A L'ENTREE
#      C. INFORMATION SUR UN MAILLAGE
#
           regles=( UN_PARMI('ADAPTATION','UNIFORME','INFORMATION'),),
           ADAPTATION      =SIMP(statut='f',typ='TXM',     
                                 fr="Adaptation libre",
                                 ang="Free adaptation",
                                 into=("RAFFINEMENT","DERAFFINEMENT","RAFF_DERA") ),
           UNIFORME        =SIMP(statut='f',typ='TXM',     
                                 fr="Adaptation uniforme",
                                 ang="Uniforme adaptation",
                                 into=("RAFFINEMENT","DERAFFINEMENT","RIEN") ),
           INFORMATION     =SIMP(statut='f',typ='TXM',
                                 fr="Information sur un maillage",
                                 ang="Information on a mesh",
                                 into=("OUI",) ),
#
# 6.2. LES CONTRAINTES :
#
# 6.2.1. POUR DE L'ADAPTATION LIBRE, IL FAUT :
#      A. LE NUMERO D'ITERATION DU MAILLAGE DE DEPART
#      B. LE NOM MED DU MAILLAGE D'ENTREE
#      C. LE NOM MED DE L'INDICATEUR D'ERREUR
#      D. LE NUMERO D'ITERATION DU MAILLAGE DE DEPART
#      E. LA MISE A JOUR DE SOLUTION
#      F. LE NOM MED DU MAILLAGE DE SORTIE
#      REMARQUE : IL FAUT DES CRITERES, MAIS ON NE SAIT PAS LESQUELS
#
# 6.2.2. POUR DE L'ADAPTATION UNIFORME
#          IL FAUT :
#      A. LE NUMERO D'ITERATION DU MAILLAGE DE DEPART
#      B. LE NOM MED DU MAILLAGE DE SORTIE
#          IL NE FAUT PAS :
#      A. LE NOM MED DE L'INDICATEUR D'ERREUR
#      B. LE NOM DE LA COMPOSANTE DE L'INDICATEUR D'ERREUR
#      C. LES CRITERES
#      REMARQUE : A L'ITERATION 0, OU AUX ITERATIONS SUIVANTES SI MAJ DE SOLUTION,
#                 IL FAUT LE NOM MED DU MAILLAGE D'ENTREE
#
# 6.2.3. POUR DE L'INFORMATION :
#          IL FAUT :
#      A. LE NOM MED DU MAILLAGE D'ENTREE
#          IL NE FAUT PAS :
#      A. LE NOM MED DE L'INDICATEUR D'ERREUR
#      B. LE NOM DE LA COMPOSANTE DE L'INDICATEUR D'ERREUR
#      C. LES CRITERES
#      D. LE NUMERO D'ITERATION DU MAILLAGE DE DEPART
#      E. LA MISE A JOUR DE SOLUTION
#
           b_maillage_initial =BLOC(condition = "( INFORMATION != None ) or ( ADAPTATION != None ) ",
                           fr="Nom MED du maillage en entrée",
                           ang="MED name of the in-mesh",
                           NOM_MED_MAILLAGE_N   =SIMP(statut='o',typ='TXM',),
                           ) ,
#
           b_maillage_initial_uniforme =BLOC(condition = "( UNIFORME != None ) ",
                           fr="Nom MED du maillage en entrée",
                           ang="MED name of the in-mesh",
                           NOM_MED_MAILLAGE_N   =SIMP(statut='f',typ='TXM',),
                           ) ,
#
           b_iteration =BLOC(condition = "( UNIFORME != None ) or ( ADAPTATION != None ) ",
                           fr="Nom MED du maillage en sortie, numero d'iteration",
                           ang="MED name of the out-mesh, iteration rank",
                           NITER                =SIMP(statut='o',typ='I',
                           fr="Numéro d'itération.",
                           ang="Iteration number." ),
                           NOM_MED_MAILLAGE_NP1 =SIMP(statut='o',typ='TXM',
                           fr="Nom MED du maillage en sortie",
                           ang="MED name of the out-mesh" ),
                           ) ,
#
           b_indicateur_d_erreur  =BLOC(condition = "ADAPTATION != None",
                           fr="Indicateur d'erreur",
                           ang="Error indicator",
                           regles=(AU_MOINS_UN('NUME_ORDRE','INST','RESULTAT'),
                                   EXCLUS('NUME_ORDRE','INST'),
                                   EXCLUS('NUME_ORDRE','RESULTAT'),
                                   PRESENT_PRESENT('RESULTAT','NOM_CHAM'),),
                           NOM_MED  =SIMP(statut='o',typ='TXM',
                           fr="Nom MED de l'indicateur d'erreur.",
                           ang="MED name of error indicator.",),
                           COMPOSANTE  =SIMP(statut='o',typ='TXM',
                           fr="Nom de la composante de l'indicateur d'erreur retenue.",
                           ang="Name of the selected component of the error indicator.",),
                           NUME_ORDRE  =SIMP(statut='f',typ='I',
                           fr="Numero d'ordre de l'indicateur.",
                           ang="Rank number of the error indicator.",),
                           INST        =SIMP(statut='f',typ='R',
                           fr="Instant de l'indicateur.",
                           ang="Instant of the error indicator.",),
                           b_precision     =BLOC(condition="(INST != None)",
                             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,
                             fr="Précision sur le choix de l'instant associé",
                             ang="Accuracy over instant choice" ),
                             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                             fr="Critère de précision sur le choix de l'instant associé",
                             ang="Accuracy criterium over instant choice" ),),
                           RESULTAT  =SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                           fr="Concept contenant l'indicateur.",
                           ang="Conceipt wich contains the error indicator.",),
                           NOM_CHAM  =SIMP(statut='f',typ='TXM',
                           fr="Nom du champ dans le résultat de l'indicateur.",
                           ang="Name of the field of the error indicator.",),
                           ) ,
#
           b_critere_de_raffinement =BLOC( condition = "( ADAPTATION == 'RAFF_DERA' ) or ( ADAPTATION == 'RAFFINEMENT' )" ,
                           fr="Critère de raffinement.",
                           ang="Refinement threshold.",
                           regles=(UN_PARMI ( 'CRIT_RAFF_ABS', 'CRIT_RAFF_REL', 'CRIT_RAFF_PE' ),),
                           CRIT_RAFF_ABS   =SIMP(statut='f',typ='R',
                                                 fr="Critère absolu",
                                                 ang="Absolute threshold"  ),
                           CRIT_RAFF_REL   =SIMP(statut='f',typ='R',
                                                 fr="Critère relatif",
                                                 ang="Relative threshold" ),
                           CRIT_RAFF_PE    =SIMP(statut='f',typ='R',
                                                 fr="Pourcentage d'éléments",
                                                 ang="Percentage of elements" ),
                           ) ,
#
           b_critere_de_deraffinement =BLOC ( condition = "( ADAPTATION == 'RAFF_DERA' ) or ( ADAPTATION == 'DERAFFINEMENT' )" ,
                           fr="Critère de déraffinement.",
                           ang="Unrefinement threshold.",
                           regles=(UN_PARMI ( 'CRIT_DERA_ABS', 'CRIT_DERA_REL', 'CRIT_DERA_PE' ),),
                           CRIT_DERA_ABS   =SIMP(statut='f',typ='R' ,
                                                 fr="Critère absolu",
                                                 ang="Absolute threshold" ),
                           CRIT_DERA_REL   =SIMP(statut='f',typ='R',
                                                 fr="Critère relatif",
                                                 ang="Relative threshold" ),
                           CRIT_DERA_PE    =SIMP(statut='f',typ='R',
                                                 fr="Pourcentage d'éléments",
                                                 ang="Percentage of elements" ),
                           ) ,
#
           b_niveau_maximum =BLOC ( condition = " ( ADAPTATION == 'RAFF_DERA' ) or ( ADAPTATION == 'RAFFINEMENT' ) or \
                                                  ( UNIFORME == 'RAFFINEMENT' )" ,
                           NIVE_MAX        =SIMP(statut='f',typ='I',
                                                 fr="Niveau maximum de profondeur de raffinement",
                                                 ang="Maximum level for refinement"),
                           ) ,
#
           b_niveau_minimum =BLOC ( condition = " ( ADAPTATION == 'RAFF_DERA' ) or ( ADAPTATION == 'DERAFFINEMENT' ) or \
                                                  ( UNIFORME == 'DERAFFINEMENT' )" ,
                           NIVE_MIN        =SIMP(statut='f',typ='I',
                                                 fr="Niveau minimum de déraffinement",
                                                 ang="Minimum level for unrefinement" ),
                           ) ,
#
# 6.3. Le suivi de frontiere eventuel :
#
         NOM_MED_MAILLAGE_FRONTIERE =SIMP(statut='f',typ='TXM',
                           fr="Nom MED du maillage de la frontiere à suivre",
                           ang="MED name of the boundary mesh" ),
#
         b_frontiere_1 =BLOC ( condition = "NOM_MED_MAILLAGE_FRONTIERE != None" ,
                           GROUP_MA        =SIMP(statut='f',typ=grma,validators=NoRepeat(),max='**',
                                                 fr="Groupes définissant la frontière",
                                                 ang="Groups which define the boundary" ),
                               ) ,
#
         ),
#
# 7. Mise à jour de champs sur le nouveau maillage
#
         MAJ_CHAM        =FACT(statut='f',max='**',
                           fr="Mise à jour de champs sur le nouveau maillage.",
                           ang="Updating of fields over the new mesh.",
                           regles=(AU_MOINS_UN('NUME_ORDRE','INST','RESULTAT'),
                                   EXCLUS('NUME_ORDRE','INST'),
                                   EXCLUS('NUME_ORDRE','RESULTAT'),
                                   PRESENT_PRESENT('RESULTAT','NOM_CHAM'),),
                           NOM_MED  =SIMP(statut='o',typ='TXM',
                           fr="Nom MED du champ à mettre à jour.",
                           ang="MED name of field.",),
                           NUME_ORDRE  =SIMP(statut='f',typ='I',
                           fr="Numero d'ordre du champ à mettre à jour.",
                           ang="Rank number of field.",),
                           INST        =SIMP(statut='f',typ='R',
                           fr="Instant du champ à mettre à jour.",
                           ang="Instant of field.",),
                           b_precision     =BLOC(condition="(INST != None)",
                             PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3,
                             fr="Précision sur le choix de l'instant associé",
                             ang="Accuracy over instant choice" ),
                             CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU"),
                             fr="Critère de précision sur le choix de l'instant associé",
                             ang="Accuracy criterium over instant choice" ),),
                           RESULTAT  =SIMP(statut='f',typ=(evol_elas,evol_noli,evol_ther),
                           fr="Concept contenant le champ à mettre à jour.",
                           ang="Conceipt wich contains the field.",),
                           NOM_CHAM  =SIMP(statut='f',typ='TXM',
                           fr="Nom du champ dans le résultat du champ à mettre à jour.",
                           ang="Name of the field.",),
         ),
#
# 8. L'ANALYSE DU MAILLAGE
#
         ANALYSE         =FACT(statut='f',
                               fr="Analyse du maillage.",
                               ang="Mesh analysis.",
#
#    5 CHOIX NON EXCLUSIFS, AVEC DEUX VARIANTES (OUI/NON) :
#    A. NOMBRE DES ELEMENTS
#    B. QUALITE DES ELEMENTS
#    C. INTERPENETRATION DES ELEMENTS
#    D. CONNEXITE DU MAILLAGE
#    E. TAILLE DES DIFFERENTS SOUS-DOMAINES
#
           regles=(AU_MOINS_UN('NOMBRE','QUALITE','INTERPENETRATION','CONNEXITE','TAILLE'),),
#
         NOMBRE          =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON"),
                          fr="Nombre de noeuds et éléments du maillage",
                          ang="Number of nodes and elements in the mesh" ),
#
         QUALITE         =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Qualité du maillage",
                          ang="Mesh quality" ),
#
         INTERPENETRATION=SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Controle de la non interpénétration des éléments.",
                          ang="Overlapping checking." ),
#
         CONNEXITE       =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Connexité du maillage.",
                          ang="Mesh connexity." ),
#
         TAILLE          =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON"),
                          fr="Tailles des sous-domaines du maillage.",
                          ang="Sizes of mesh sub-domains." ),
#
         ),
#
)  ;
