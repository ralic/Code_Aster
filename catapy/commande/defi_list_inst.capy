#& MODIF COMMANDE  DATE 28/02/2011   AUTEUR BARGELLI R.BARGELLINI 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2011  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
# RESPONSABLE GENIAUT S.GENIAUT


# bloc utilisé deux fois à l'identique
bloc_unif = BLOC(condition = "SUBD_METHODE == 'UNIFORME'",
                SUBD_COEF_PAS_1=SIMP(statut='f',typ='R',defaut=1.0,val_min=0.0,max=1,
                                     fr="Coefficient multiplicateur de la 1ère subdivision"),
                SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,max=1,
                                     fr="Nombre de subdivision d'un pas de temps"),

                b_subd_unif_manu  =   BLOC(condition="METHODE == 'MANUEL'",
                    regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
                    SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,defaut=3,max=1,
                                     fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
                    SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                                       fr="Pas de temps en dessous duquel on ne subdivise plus"),
                ),

                b_subd_unif_auto  =   BLOC(condition="METHODE == 'AUTO'",
                    SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                                       fr="Pas de temps en dessous duquel on ne subdivise plus"),
                ),
            ) # fin si UNIFORME

DEFI_LIST_INST=OPER(nom="DEFI_LIST_INST",op=  28,sd_prod=list_inst,reentrant='n',
            UIinfo={"groupes":("Fonctions",)},
               fr="Définition de la gestion de la liste d'instants",

# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour la definition a priori de la liste d'instant
# ----------------------------------------------------------------------------------------------------------------------------------

    DEFI_LIST             =FACT(statut='o',max=1,

      METHODE  =SIMP(statut='o',typ='TXM',into=("MANUEL","AUTO",),defaut="MANUEL",max=1,position='global' ),

         b_manuel            =BLOC(condition = "METHODE == 'MANUEL' ",fr="Liste d'instants donnée par l'utilisateur",
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
                                  ),

         b_auto              =BLOC(condition = "(METHODE == 'AUTO') ",fr="a compléter",
           LIST_INST       =SIMP(statut='o',typ=listr8_sdaster),
           PAS_MINI    =SIMP(statut='f',typ='R',val_min=0.0,max=1),
           PAS_MAXI    =SIMP(statut='f',typ='R',max=1),
           NB_PAS_MAXI =SIMP(statut='f',typ='I',max=1),
                                  ),

                      ),
# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour le comportement en cas d'echec (on doit recommencer le meme instant)
# ----------------------------------------------------------------------------------------------------------------------------------

    ECHEC  =FACT(statut='d',max='**',

        EVENEMENT     =SIMP(statut='f',typ='TXM',into=("ERREUR","DELTA_GRANDEUR","DIVE_ITER_PILO"),defaut="ERREUR",max=1 ),

        b_edelta           =BLOC(condition = "EVENEMENT == 'DELTA_GRANDEUR' ",fr=" ",
#      event-driven : on sous-decoupe si l'increment d'une composante d'un champ depasse le seuil
            VALE_REF          =SIMP(statut='o',typ='R',max=1),
            NOM_CHAM          =SIMP(statut='o',typ='TXM',into=("DEPL","VARI_ELGA","SIEF_ELGA",),max=1),
            NOM_CMP           =SIMP(statut='o',typ='TXM',max=1),

            SUBD_METHODE    =SIMP(statut='f',typ='TXM',into =("AUCUNE","UNIFORME"),defaut="UNIFORME",max=1,
                            fr="Méthode de subdivision des pas de temps en cas de diconvergence pour event-driven"),

            b_subd_unif = bloc_unif,

        ), # fin si DELTA_GRANDEUR

        b_subd_erreur  =   BLOC(condition="EVENEMENT == 'ERREUR'",
            SUBD_METHODE    =SIMP(statut='f',typ='TXM',into =("AUCUNE","UNIFORME","EXTRAPOLE"),defaut="UNIFORME",max=1,
                                  fr="Méthode de subdivision des pas de temps en cas de divergence pour erreur"),

            b_subd_unif = bloc_unif,

            b_subd_extr=BLOC(condition = "SUBD_METHODE == 'EXTRAPOLE'",
                SUBD_OPTION    =SIMP(statut='f',typ='TXM', into =("IGNORE_PREMIERES","GARDE_DERNIERES",),
                                     defaut="IGNORE_PREMIERES",
                    fr="Technique d'extrapolation : les 1ere itérations sont ignorées ou les dernières sont gardées"),
                SUBD_ITER_IGNO =SIMP(statut='f',typ='I',defaut=3,val_min=3,max=1,
                                     fr="Les n premières itérations sont ignorées pour l'extrapolation"),
                SUBD_ITER_FIN  =SIMP(statut='f',typ='I',defaut=8,val_min=3,max=1,
                                     fr="Seules les n dernières itérations sont prises pour l'extrapolation"),
                SUBD_PAS       =SIMP(statut='f',typ='I',defaut=4,val_min=2,max=1,
                                     fr="Nombre de subdivision d'un pas de temps en cas ERREUR"),

                b_subd_unif_manu  =   BLOC(condition="METHODE == 'MANUEL'",
                    regles=(AU_MOINS_UN('SUBD_NIVEAU','SUBD_PAS_MINI'),),
                    SUBD_NIVEAU=SIMP(statut='f',typ='I',val_min=2,max=1,
                                     fr="Nombre maximum de niveau de subdivision d'un pas de temps"),
                    SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                                       fr="Pas de temps en dessous duquel on ne subdivise plus"),
                ),

                b_subd_unif_auto  =   BLOC(condition="METHODE == 'AUTO'",
                    SUBD_PAS_MINI=SIMP(statut='f',typ='R',defaut=0.,val_min=0.0,max=1,
                                       fr="Pas de temps en dessous duquel on ne subdivise plus"),
                ),

                SUBD_ITER_PLUS =SIMP(statut='f',typ='I',defaut=50,val_min=20,max=1,
                                     fr="% itération autorisée en plus"),
            ), # fin si EXTRAPOLE
        ), # fin si ERREUR

   ), # fin ECHEC

# ----------------------------------------------------------------------------------------------------------------------------------
# mot-cle pour le comportement en cas de succes (on a bien converge)
# ----------------------------------------------------------------------------------------------------------------------------------

  b_adap  =   BLOC(condition="METHODE == 'AUTO'",

    ADAPTATION  =FACT(statut='d',max='**',

#     1) parametres de l'evenement declencheur
#     ----------------------------------------

      EVENEMENT       =SIMP(statut='f',typ='TXM',into=("SEUIL","TOUT_INST","AUCUN"),defaut="SEUIL",max=1 ),

         b_adap_seuil       =BLOC(condition = "EVENEMENT == 'SEUIL' ",fr="seuil de re-decoupe",

#          FORMULE_SEUIL          =SIMP(statut='f',typ=formule),

#          b_adap_seuil_nf   =   BLOC(condition="FORMULE_SEUIL == None",
#              critere : si on fait NB_INCR_SEUIL fois de suite des increments verifiant le critere
               regles=(PRESENT_PRESENT('NB_INCR_SEUIL','NOM_PARA',),
                       PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),
                       PRESENT_PRESENT('NB_INCR_SEUIL','CRIT_COMP',),),
               NB_INCR_SEUIL     =SIMP(statut='f',typ='I',defaut=2),
               NOM_PARA          =SIMP(statut='f',typ='TXM',into=("NB_ITER_NEWTON",),defaut="NB_ITER_NEWTON"),
               CRIT_COMP         =SIMP(statut='f',typ='TXM',into=("LT","GT","LE","GE"),defaut="LE"),
#                   b_vale_R           =BLOC(condition = "NOM_PARA == 'DP' ",fr="valeur reelle",
#                VALE              =SIMP(statut='o',typ='R'),
#                                           ),
                  b_vale_I           =BLOC(condition = "NOM_PARA == 'NB_ITER_NEWTON' ",fr="valeur entiere",
               VALE_I            =SIMP(statut='f',typ='I'),
                                          ),
#                                    ),
                                ),

#     2) parametre du mode de calcul de dt+
#     ----------------------------------------

      MODE_CALCUL_TPLUS =SIMP(statut='f',typ='TXM',into=("FIXE","DELTA_GRANDEUR","ITER_NEWTON","FORMULE","IMPLEX"),defaut='FIXE',
                              max=1),

         b_mfixe           =BLOC(condition = "MODE_CALCUL_TPLUS == 'FIXE' ",fr="fixe",
#      dans le cas FIXE :(deltaT+) = (deltaT-)x(1+PCENT_AUGM/100)
      PCENT_AUGM                 =SIMP(statut='f',typ='R',defaut=100.,val_min=-100.,max=1),
                               ),
         b_mdelta           =BLOC(condition = "MODE_CALCUL_TPLUS == 'DELTA_GRANDEUR' ",fr=" ",
#      dans le cas DELTA_GRANDEUR : (deltaT+) = (deltaT-)x(VALREF/deltaVAL) : l'acceleration est inversement proportionnelle
#                                                                             a la variation de la grandeur
      VALE_REF          =SIMP(statut='o',typ='R',max=1),
      NOM_CHAM          =SIMP(statut='o',typ='TXM',into=("DEPL","VARI_ELGA","SIEF_ELGA",),max=1),
      NOM_CMP           =SIMP(statut='o',typ='TXM',max=1),
                                  ),
         b_mitnew           =BLOC(condition = "MODE_CALCUL_TPLUS == 'ITER_NEWTON' ",fr=" ",
#      dans le cas ITER_NEWTON : (deltaT+) = (deltaT-) x sqrt(VALREF/N) : l'acceleration est inversement proportionnelle
#                                                                        au nombre d'iter de Newton precedent
      NB_ITER_NEWTON_REF          =SIMP(statut='o',typ='I',max=1),
                                  ),
         b_mformule           =BLOC(condition = "MODE_CALCUL_TPLUS == 'FORMULE' ",fr=" ",
#      dans le cas FORMULE
           regles=UN_PARMI('FORMULE_TPLUS','NOM_SCHEMA'),
      FORMULE_TPLUS     =SIMP(statut='f',typ=formule),
      NOM_SCHEMA        =SIMP(statut='f',typ='TXM',into=("OLIVER",)),
                                   ),

# les schemas pre-definis :
#  abaqus :
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 2
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = 5
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 50.
#  Zebulon 1 :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='DELTA_GRANDEUR'
#      VALE_REF          = valref
#      NOM_CHAM          ='VARI_ELGA'
#      NOM_CMP           ='V1'
#  Zebulon 2 :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='ITER_NEWTON'
#      NB_ITER_NEWTON_REF= nc
#  Tough2 :
#      EVENEMENT       ='SEUIL'
#      NB_INCR_SEUIL     = 1
#      NOM_PARA          ='NB_ITER_NEWTON'
#      CRIT_COMP         ='LE'
#      VALE_I            = n
#      MODE_CALCUL_TPLUS ='FIXE'
#      PCENT_AUGM        = 100.
#  Oliver :
#      EVENEMENT       ='TOUT_INST'
#      MODE_CALCUL_TPLUS ='FORMULE'
#      NOM_SCHEMA        ='OLIVER'

             ),
      ),
#  b_adaplex  =   BLOC(condition = "METHODE == 'AUTO' and MODE_CALCUL_TPLUS == 'IMPLEX'",
#
#    ADAPTATION  =FACT(statut='d',max='**',
#
#     1 parametres de l'evenement declencheur
#     ----------------------------------------
#
#      EVENEMENT       =SIMP(statut='f',typ='TXM',into=("TOUT_INST",),defaut="TOUT_INST",max=1 ),
#
#                           
#     2 parametre du mode de calcul de dt+
#     ----------------------------------------
#
#     MODE_CALCUL_TPLUS =SIMP(statut='f',typ='TXM',into=("IMPLEX",),defaut='IMPLEX',max=1,position='global' ),
#
#             ),
#     ),

# ----------------------------------------------------------------------------------------------------------------------------------

    INFO                  =SIMP(statut='f',typ='I',defaut= 1,into=(1,2) ),

)  ;

