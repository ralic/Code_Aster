#& MODIF COMMANDE  DATE 09/09/2003   AUTEUR DURAND C.DURAND 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2003  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE ASSIRE A.ASSIRE

from Macro.calc_precont_ops import calc_precont_ops


# ===========================================================================
#           CATALOGUE DE LA MACRO "CALC_PRECONT"
#           -----------------------------------------
# USAGE :
# 
#  
# ===========================================================================

CALC_PRECONT=MACRO(nom="CALC_PRECONT",op=calc_precont_ops,sd_prod=evol_noli,
                   fr="imposer la tension definie par le BPEL dans les cables",
                   docu="",reentrant='f',
         reuse =SIMP(statut='f',typ='evol_noli'),
         MODELE           =SIMP(statut='o',typ=modele),
         CHAM_MATER       =SIMP(statut='o',typ=cham_mater),
         CARA_ELEM        =SIMP(statut='o',typ=cara_elem),
         CABLE_BP         =SIMP(statut='o',typ=cabl_precont,validators=NoRepeat(),max='**'),
         CABLE_BP_INACTIF =SIMP(statut='f',typ=cabl_precont,validators=NoRepeat(),max='**'),
         INCREMENT        =FACT(statut='o',
           LIST_INST       =SIMP(statut='o',typ=listr8),
           INST_INIT       =SIMP(statut='f',typ='R'),
           INST_FIN        =SIMP(statut='f',typ='R'),
           PRECISION       =SIMP(statut='f',typ='R',defaut=1.0E-3 ),
           SUBD_PAS        =SIMP(statut='f',typ='I',defaut=1),
           SUBD_PAS_MINI   =SIMP(statut='f',typ='R'),
           COEF_SUBD_PAS_1 =SIMP(statut='f',typ='R',defaut= 1.0E+0),
         ),

         NEWTON          =FACT(statut='d',
            REAC_INCR       =SIMP(statut='f',typ='I',defaut= 1 ),
            PREDICTION      =SIMP(statut='f',typ='TXM',into=("DEPL_CALCULE","TANGENTE","ELASTIQUE","EXTRAPOL") ),
            MATRICE         =SIMP(statut='f',typ='TXM',defaut="TANGENTE",into=("TANGENTE","ELASTIQUE") ),
            PAS_MINI_ELAS   =SIMP(statut='f',typ='R',defaut=0.0E+0),
            REAC_ITER       =SIMP(statut='f',typ='I',defaut=0),
            EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
          ),
         RECH_LINEAIRE   =FACT(statut='f',
           RESI_LINE_RELA  =SIMP(statut='f',typ='R',defaut= 1.0E-1 ),
           ITER_LINE_MAXI  =SIMP(statut='f',typ='I',defaut= 3),
         ),
          CONVERGENCE     =FACT(statut='d',
            RESI_GLOB_MAXI  =SIMP(statut='f',typ='R'),
            RESI_GLOB_RELA  =SIMP(statut='f',typ='R'),
            ITER_GLOB_MAXI  =SIMP(statut='f',typ='I',defaut=10),
            ITER_GLOB_ELAS  =SIMP(statut='f',typ='I',defaut=25),
            ARRET           =SIMP(statut='f',typ='TXM',defaut="OUI"),
            RESI_INTE_RELA  =SIMP(statut='f',typ='R'
                                 ,defaut= 1.0E-6),
            ITER_INTE_MAXI  =SIMP(statut='f',typ='I',defaut= 10 ),
            ITER_INTE_PAS   =SIMP(statut='f',typ='I',defaut= 0 ),
            TYPE_MATR_COMP  =SIMP(statut='f',typ='TXM',defaut="TANG_VIT",into=("TANG_VIT",)),
            RESO_INTE       =SIMP(statut='f',typ='TXM',defaut="IMPLICITE",
                                  into=("RUNGE_KUTTA_2","RUNGE_KUTTA_4","IMPLICITE")),
          ),
          ETAT_INIT       =FACT(statut='f',
            regles=(AU_MOINS_UN('EVOL_NOLI','DEPL','SIGM','VARI','VARI_NON_LOCAL',),
                    EXCLUS('EVOL_NOLI','DEPL',),
                    EXCLUS('EVOL_NOLI','SIGM',),
                    EXCLUS('EVOL_NOLI','VARI',),
                    EXCLUS('EVOL_NOLI','VARI_NON_LOCAL',),
                    EXCLUS('NUME_ORDRE','INST'), ),
            DEPL            =SIMP(statut='f',typ=cham_no_depl_r),
            SIGM            =SIMP(statut='f',typ=(cham_elem_sief_r,carte_sief_r)),
            VARI            =SIMP(statut='f',typ=cham_elem_vari_r),
            VARI_NON_LOCAL  =SIMP(statut='f',typ=cham_no_vanl_r),
            EVOL_NOLI       =SIMP(statut='f',typ=evol_noli),
            NUME_ORDRE      =SIMP(statut='f',typ='I'),
            INST            =SIMP(statut='f',typ='R'),
            PRECISION       =SIMP(statut='f',typ='R',defaut= 1.0E-3 ),
            CRITERE         =SIMP(statut='f',typ='TXM',defaut="RELATIF",into=("RELATIF","ABSOLU") ),
            NUME_DIDI       =SIMP(statut='f',typ='I'),
            INST_ETAT_INIT  =SIMP(statut='f',typ='R'),
          ),
          SOLVEUR         =FACT(statut='d',
            METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
            b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
              RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
            ),
            b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
              RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
            ),
            b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                    fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
              NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
              STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON","DECOUPE") ),
            ),
            b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
              PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
              NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
              RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("SANS","RCMK") ),
              RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
              NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
            ),
            SYME            =SIMP(statut='f',typ='TXM',defaut="NON",into=("OUI","NON") ),
          ),
            SOLV_NON_LOCAL  =FACT(statut='f',
              METHODE         =SIMP(statut='f',typ='TXM',defaut="MULT_FRONT",into=("MULT_FRONT","LDLT","GCPC") ),
              b_mult_front    =BLOC(condition = "METHODE == 'MULT_FRONT' ",fr="Paramètres de la méthode multi frontale",
                RENUM           =SIMP(statut='f',typ='TXM',defaut="METIS",into=("MD","MDA","METIS") ),
              ),
              b_ldlt         =BLOC(condition = "METHODE == 'LDLT' ",fr="Paramètres de la méthode LDLT",
                RENUM           =SIMP(statut='f',typ='TXM',defaut="RCMK",into=("RCMK","SANS") ),
              ),
              b_ldlt_mult    =BLOC(condition = "METHODE == 'LDLT' or METHODE == 'MULT_FRONT' ",
                                     fr="Paramètres relatifs à la non inversibilité de la matrice à factorise",
                NPREC           =SIMP(statut='f',typ='I',defaut= 8 ),
                STOP_SINGULIER  =SIMP(statut='f',typ='TXM',defaut="OUI",into=("OUI","NON") ),
              ),
              b_gcpc         =BLOC(condition = "METHODE == 'GCPC' ", fr="Paramètres de la méthode du gradient conjugué",
                PRE_COND        =SIMP(statut='f',typ='TXM',into=("LDLT_INC",),defaut="LDLT_INC" ),
                NIVE_REMPLISSAGE=SIMP(statut='f',typ='I',defaut= 0 ),
                RESI_RELA       =SIMP(statut='f',typ='R',defaut= 1.E-6 ),
                NMAX_ITER       =SIMP(statut='f',typ='I',defaut= 0 ),
              ),
              EPS             =SIMP(statut='f',typ='R',defaut= 0.E+0 ),
            ),
            LAGR_NON_LOCAL  =FACT(statut='f',
              ITER_DUAL_MAXI  =SIMP(statut='f',typ='I',defaut= 50),
              RESI_DUAL_ABSO  =SIMP(statut='o',typ='R'),
              RESI_PRIM_ABSO  =SIMP(statut='o',typ='R'),
              R               =SIMP(statut='f',typ='R',defaut= 1000.),
              ITER_PRIM_MAXI  =SIMP(statut='f',typ='I',defaut= 10),
            ),
          PARM_THETA      =SIMP(statut='f',typ='R'
                               ,defaut= 1. ),
          INFO            =SIMP(statut='f',typ='I',into=(1,2) ),
          TITRE           =SIMP(statut='f',typ='TXM',max='**' ),

          EXCIT           =FACT(statut='o',max='**',
            CHARGE          =SIMP(statut='o',typ=char_meca),
          ),

         COMP_INCR       =C_COMP_INCR(),
  )  ;
