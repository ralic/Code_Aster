#& MODIF COMMANDE  DATE 27/11/2006   AUTEUR GNICOLAS G.NICOLAS 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2004  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY  
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY  
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR     
# (AT YOUR OPTION) ANY LATER VERSION.                                                  
#                                                                       
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT   
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF            
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU      
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.                              
#                                                                       
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE     
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,         
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.        
# ======================================================================
# RESPONSABLE GNICOLAS G.NICOLAS

from Macro.macr_fiabilite_ops import macr_fiabilite_ops

#
#====
# 1. Le retour : une liste de rééls.
#====
#
def macr_fiabilite_prod ( self , **args ):
  return listr8_sdaster
#
#====
# 2. L'entete
#====
#
MACR_FIABILITE = MACRO ( nom="MACR_FIABILITE",op=macr_fiabilite_ops,
                         docu="U7.03.31",UIinfo={"groupe":("Post traitements",)},
                         sd_prod=macr_fiabilite_prod,
                         fr="Calcule les probabiltés de dépassement de seuil (mécanique de fiabilité).",
                         ang="Fiability mechanics.",
#
#====
# 3. Le niveau d'information
#====
#
   INFO           = SIMP(statut="f",typ="I",defaut=1,into=(1,2)),
#
#====
# 4. Nom et Version du logiciel de fiabilité
#====
#
   LOGICIEL = SIMP(statut="f",typ="TXM",defaut="MEFISTO",
                   into=("MEFISTO",),
                   fr="Nom du logiciel de fiabilité.",
                   ang="Fiability software name."),
#
   VERSION = SIMP(statut="f",typ="TXM",defaut="V3_2",
                  into=("V3_2", "V3_N"),
                  fr="Version du logiciel de fiabilité.",
                  ang="Fiability software release."),
#
#====
# 5. Les entrees-sorties du calcul ASTER déterministe
#====
#
# 5.1. ==> Le jeu de commandes déterministe
#
   UNITE_ESCL = SIMP(statut="o",typ="I",
                     fr="Unité logique associée aux commandes du calcul ASTER déterministe.",
                     ang="Logical unit for the commands of the ASTER deterministic calculation."),
#
# 5.2. ==> Le destin des messages produits par ASTER
#
   MESS_ASTER = SIMP(statut="f",typ="TXM",defaut="DERNIER",
                        into=("AUCUN", "DERNIER", "TOUS"),
                        fr="Quels messages ASTER récupérer.",
                        ang="Which ASTER messages must be kept."),
#
#====
# 6. Options
#====
# 6.1. ==> Générales
#
# 6.1.1. ==> La valeur du seuil
#
   SEUIL = SIMP(statut="o",typ="R",max=1,
                fr="Le seuil de défaillance.",
                ang="Failure threshold."),
#
# 6.1.2. ==> Le type du seuil : on a deux cas de figure selon que
#            la défaillance a lieu au dessus d'un seuil maximum ou
#            en dessous d'un seuil minimum
#
   SEUIL_TYPE = SIMP(statut="o",typ="TXM",max=1,
                     into=("MINIMUM","MAXIMUM"),
                     fr="Que faut-il ne pas dépasser : un maximum ou un minimum.",
                     ang="What is the failure threshold : maximum or minimum."),
#
# 6.2. ==> Pour MEFISTO
#
### en attente de résolution de AL 2004-006 (1/2)   b_mefisto=BLOC( condition = "LOGICIEL=='MEFISTO'",
#
# 6.2.1. ==> Pilotage de la recherche du point de conception
#
     RECH_PT_CONCEPT = SIMP(statut="f",typ="TXM",defaut="OUI",
                            into=("OUI","NON"),
                            fr="Pour trouver le point de conception.",
                            ang="To find the design point."),
#
     b_rech_pt_concept=BLOC( condition = "RECH_PT_CONCEPT=='OUI'",
#
       EPSILON_U = SIMP(statut="f",typ="R",defaut=1.0E-2,
                        fr="Précision du test d'arret sur les points itératifs dans l'espace standard.",
                        ang="Precision of stop test for iterative points in standard space."),
#
       EPSILON_G = SIMP(statut="f",typ="R",defaut=1.0E-2,
                        fr="Précision du test d'arret sur la proximité de la surface d'état limite.",
                        ang="Precision of stop test for limit state surface."),
#
       TAU       = SIMP(statut="f",typ="R",defaut=5.0E-1,
                        fr="Paramètre de la méthode de minimisation.",
                        ang="Parameter for the minimization method."),
#
       OMEGA     = SIMP(statut="f",typ="R",defaut=1.0E-4,
                        fr="Paramètre de la méthode de minimisation.",
                        ang="Parameter for the minimization method."),
#
       ITER_MAX  = SIMP(statut="f",typ="I",defaut=50,
                        fr="Nombre maximum d'itérations.",
                        ang="Maximum number of iterations."),
     ),
#
# 6.2.2. ==> Méthode(s) employée(s) pour la probabilité de défaillance
#
     METHODE_FORM = SIMP(statut="f",typ="TXM",defaut="OUI",
                         into=("OUI","NON"),
                         fr="Recherche de la probabilité de défaillance avec la méthode FORM.",
                         ang="Research of failure probability with FORM method."),
#
     METHODE_SORM = SIMP(statut="f",typ="TXM",defaut="NON",
                         into=("OUI","NON"),
                         fr="Recherche de la probabilité de défaillance avec la méthode SORM.",
                         ang="Research of failure probability with SORM method."),
#
     TIRAGE_IMPORTANCE = SIMP(statut="f",typ="TXM",defaut="NON",
                              into=("OUI","NON"),
                              fr="Recherche de la probabilité de défaillance avec le tirage d'importance.",
                              ang="Research of failure probability with ."),
#
     b_tirage_importance=BLOC( condition = "TIRAGE_IMPORTANCE=='OUI'",
#
       NB_SIMULATION = SIMP(statut="f",typ="I",defaut=3,
                            fr="Nombre de simulations pour le tirage d'importance.",
                            ang="Number of simulation for."),
#
     ),
#
# 6.2.3. ==> Création d'une surface de réponse polynomiale
#
     POLYNOME_TAYLOR   = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),),
     HGRAD             = SIMP(statut="f",typ="R",defaut=1.0E-2,
                              fr="Pas incrémental pour le calcul des gradients.",
                              ang="Step for calculation of gradients."),
     HHESS             = SIMP(statut="f",typ="R",defaut=1.0E-2,
                              fr="Pas incrémental pour le calcul des dérivées secondes.",
                              ang="Step for calculation of second derivatives."),
#
# 6.2.4. ==> Recherche d'un plan d'expérience
#
     PLAN_EXPERIENCE   = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                              fr="Construction d'un plan d'expérience.",
                              ang="Construction of an experiment plan."),
#
     b_plan_experience=BLOC( condition = "PLAN_EXPERIENCE=='OUI'",
#
       ALPHA         = SIMP(statut="f",typ="R",defaut=2.0E-1,
                            fr="Plan d'expérience : maille du plan de type composite centré.",
                            ang="Experiment plane : mesh centered composite."),
#
       BETA          = SIMP(statut="f",typ="R",defaut=4.0E-1,
                            fr="Plan d'expérience : maille du plan de type factoriel.",
                            ang="Experiment plane : mesh factor."),
#
     ),
#
# 6.2.5. ==> Les tests
# 6.2.5.1. ==> Test de la sphere
#
     T_SPHERE = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                     fr="Test de la sphère.",
                     ang="Sphere test."),
#
     b_test_de_la_sphere=BLOC( condition = "T_SPHERE=='OUI'",
#
       METHODE_TEST = SIMP(statut="f",typ="TXM",defaut="GAUSSIENNE",
                           into=("GAUSSIENNE","PARAMETRIQUE","REJECTION"),
                           fr="Type de méthode.",
                           ang="Method."),
#
       NB_POINT     = SIMP(statut="f",typ="I",max=1,defaut=60,
                           fr="Nombre de points de la sphere.",
                           ang="Number of points over the sphere.")
     ),
#
# 6.2.5.2. ==> Test du maximum fort
#
     T_MAXIMUM_FORT = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                           fr="Test du maximum fort.",
                           ang="Strong maximum test."),
#
     b_test_du_maximum_fort=BLOC( condition = "T_MAXIMUM_FORT=='OUI'",
#
       COS_LIM = SIMP(statut="f",typ="R",max=1,defaut=1.0,
                      fr="Cosinus de l'angle d'exclusion.",
                      ang="Cosine of angle of exclusion."),
#
       DPROB   = SIMP(statut="f",typ="R",max=1,defaut=4.3E-1,
                      fr="Fraction d'iso-densité de probabilité de défaillance.",
                      ang="Fraction.")
#
     ),
#
# 6.2.5.3. ==> Test du hessien
#
     T_HESSIEN = SIMP(statut="f",typ="TXM",defaut="NON",into=("OUI","NON"),
                      fr="Test du hessien.",
                      ang="Hessian test."),
#
# 6.2.6. ==> Les correlations entre les variables
#
     MATRICE = SIMP(statut="f",typ="R",max="**",
                    fr="Matrice de corrélation entre les variables.",
                    ang="Correlation matrix."), 
#
### en attente de résolution de AL 2004-006 (2/2)   ),
#
#====
# 7. Definition des paramètres
#====
#
   VARIABLE = FACT(statut="o",min=1,max="**",
#
# 7.1. ==> Nom de la variable
#
       NOM = SIMP(statut="o",typ="TXM",
                  fr="Nom de la variable, identique au nom de concept PARA_SENSI.",
                  ang="Name of the variable, identical to the name of the PARA_SENSI conceipt."),
#
# 7.2. ==> Loi de distribution
#
       LOI = SIMP(statut="o",typ="TXM",
                  into=("UNIFORME","NORMALE","LOGNORMALE","NORMALE_TRONQUEE"),
                  fr="Choix de la loi",
                  ang="Law."),
#
# 7.2.1. ==> Loi normale
#
       b_normale=BLOC(condition="LOI=='NORMALE'",
#
         VALE_MOY   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur moyenne.",
                               ang="Mean value."),
#
         ECART_TYPE = SIMP(statut="o",typ="R",max=1,
                               fr="Ecart type.",
                               ang="Standard deviation."),
#
       ),
#
# 7.2.2. ==> Loi lognormale
#
       b_lognormale=BLOC(condition="LOI=='LOGNORMALE'",
#
         VALE_MIN       = SIMP(statut="o",typ="R",max=1,
                                   fr="Valeur minimale.",
                                   ang="Minimal value."),
#
         VALE_MOY       = SIMP(statut="f",typ="R",max=1,
                                   fr="Valeur moyenne dans l'espace de la loi normale.",
                                   ang="Mean value in the space of the normal law."),
#
         ECART_TYPE     = SIMP(statut="f",typ="R",max=1,
                                   fr="Ecart type dans l'espace de la loi normale.",
                                   ang="Standard deviation in the space of the normal law."),
#
         VALE_MOY_PHY   = SIMP(statut="f",typ="R",max=1,
                                   fr="Valeur moyenne dans l'espace physique.",
                                   ang="Mean value in the physical space."),
#
         ECART_TYPE_PHY = SIMP(statut="f",typ="R",max=1,
                                   fr="Ecart type dans l'espace physique.",
                                   ang="Standard deviation in the physical space."),
#
         regles=(AU_MOINS_UN("VALE_MOY"  ,"VALE_MOY_PHY"),
                 AU_MOINS_UN("ECART_TYPE","ECART_TYPE_PHY"),
                 EXCLUS  ("VALE_MOY"  ,"VALE_MOY_PHY"),
                 EXCLUS  ("VALE_MOY"  ,"ECART_TYPE_PHY"),
                 EXCLUS  ("ECART_TYPE","VALE_MOY_PHY"),
                 EXCLUS  ("ECART_TYPE","ECART_TYPE_PHY")),
#
       ),
#
# 7.2.3. ==> Loi uniforme
#
       b_uniforme=BLOC(condition="LOI=='UNIFORME'",
#
         VALE_MIN = SIMP(statut="o",typ="R",max=1,
                             fr="Valeur minimale.",
                             ang="Minimal value."),
#
         VALE_MAX = SIMP(statut="o",typ="R",max=1,
                             fr="Valeur maximale.",
                             ang="Maximal value."),
#
       ),
#
# 7.2.4. ==> Loi normale tronquée
#
       b_normale_tronquee=BLOC(condition="LOI=='NORMALE_TRONQUEE'",
#
         VALE_MOY   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur moyenne de la loi normale complète.",
                               ang="Mean value for the entire normal law."),
#
         ECART_TYPE = SIMP(statut="o",typ="R",max=1,
                               fr="Ecart type de la loi normale complète.",
                               ang="Standard deviation for the entire normal law."),
#
         VALE_MIN   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur minimale.",
                               ang="Minimal value."),
#
         VALE_MAX   = SIMP(statut="o",typ="R",max=1,
                               fr="Valeur maximale.",
                               ang="Maximal value."),
#
       ),
#
# 7.3. ==> Paramètres de calcul
# 7.3.1. ==> Soit on cherche le point de conception, soit on le connait deja
#
       regles=(EXCLUS("POINT_INI","POINT_CONCEPT"),
               EXCLUS("POINT_REF","POINT_CONCEPT"),),
#
# 7.3.2. ==> Quand on cherche le point de conception, on peut préciser le départ de l'algorithme.
#            Si on ne le fait pas, le programme prendra la valeur moyenne.
#
       POINT_INI = SIMP(statut="f",typ="R",max=1,
                          fr="Point de démarrage de l'algorithme itératif.",
                          ang="Initial point for iterative process."),
#
# 7.3.3. ==> Quand on cherche le point de conception, on peut préciser un point de référence pour normaliser.
#            Si on ne le fait pas, le programme prendra la valeur moyenne.
#
       POINT_REF = SIMP(statut="f",typ="R",max=1,
                          fr="Point de référence de l'algorithme itératif.",
                          ang="Reference point for iterative process."),
#
# 7.3.4. ==> Quand on cherche uniquement la probabilité de défaillance, il faut donner le point de conception
#
       POINT_CONCEPT = SIMP(statut="f",typ="R",max=1,
                              fr="Point de conception.",
                              ang="Design point."),
#
# 7.4. ==> Mode d'obtention du gradient par rapport à ce paramètre
#
       GRADIENT = SIMP(statut="o",typ="TXM",max=1,
                           into=("OUI","NON"),
                           fr="ASTER calcule directement le gradient.",
                       ang="ASTER computes the gradient for this parameter."),

       b_gradient=BLOC(condition="GRADIENT=='NON'",
         INCREMENT = SIMP(statut="o",typ="R",max=1,
                             fr="Incrément dans la direction.",
                         ang="Direction increment."),
       ),

   ),
#
);
