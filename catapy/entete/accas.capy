#& MODIF ENTETE  DATE 31/01/2005   AUTEUR LEBOUVIE F.LEBOUVIER 
# -*- coding: iso-8859-1 -*-
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================

import Accas
from Accas import *
from Accas import _F
import string
import Numeric
from math import sin,cos,tan,asin,acos,atan2,atan,sinh,cosh,tanh,exp,log,log10
from math import sqrt,pi
import ops

try:
  import aster
except:
  pass

#
__version__="$Name:  $"
__Id__="$Id: cata_aster_v6.py,v 1.12 2001/01/16 15:55:05 iliade Exp $"
#
JdC = JDC_CATA(code='ASTER',
               execmodul=None,
               regles = (AU_MOINS_UN('DEBUT','POURSUITE'),
                         AU_MOINS_UN('FIN'),
                         A_CLASSER(('DEBUT','POURSUITE'),'FIN')))
# Type le plus general
class entier   (ASSD):
   def __init__(self,valeur=None,**args):
      ASSD.__init__(self,**args)
      self.valeur=valeur

# Type geometriques
class no  (GEOM):pass
class grno(GEOM):pass
class ma  (GEOM):pass
class grma(GEOM):pass



# Autres

class cabl_precont    (ASSD):pass
class cara_elem       (ASSD):pass
class cham_mater      (ASSD):pass
class char_acou       (ASSD):pass
class char_cine_acou  (ASSD):pass
class char_cine_meca  (ASSD):pass
class char_cine_ther  (ASSD):pass
class char_meca       (ASSD):pass
class char_ther       (ASSD):pass
class compor_sdaster  (ASSD):pass
class courbe_sdaster  (ASSD):pass
class fiss_xfem       (ASSD):pass
class fond_fiss       (ASSD):pass
class interf_dyna_clas(ASSD):pass
class interspfact     (ASSD):pass
class listis_sdaster  (ASSD):pass
class macr_elem_dyna  (ASSD):pass
class macr_elem_stat  (ASSD):pass
class mater_sdaster   (ASSD):pass
class melasflu_sdaster(ASSD):pass
class modele_sdaster  (ASSD):pass
class modele_gene     (ASSD):pass
class nume_ddl_sdaster(ASSD):pass
class nume_ddl_gene   (ASSD):pass
class obstacle_sdaster(ASSD):pass
class sd_feti_sdaster (ASSD):pass
class spectre_sdaster (ASSD):pass
class surface_sdaster (ASSD):pass
class tran_gene       (ASSD):pass
class type_flui_stru  (ASSD):pass


# liste :
#--------------------------------
class listr8_sdaster   (ASSD):
  def Valeurs(self) :
    """
    Retourne la liste des valeurs : [val1, ..., valN]
    """
    vale=string.ljust(self.get_name(),19)+'.VALE'
    return list(aster.getvectjev(vale))


# post-traitement :
#--------------------------------
class post_comp_cham_el :
  def __init__(self,valeurs,maille=None,point=None,sous_point=None) :
    self.valeurs=valeurs
    self.maille=maille
    self.point=point
    self.sous_point=sous_point

class post_comp_cham_no :
  def __init__(self,valeurs,noeud=None) :
    self.valeurs=valeurs
    self.noeud=noeud

# maillage :
#--------------------------------
class maillage_sdaster(ASSD):
  def LIST_GROUP_NO(self) :
    """ retourne la liste des groupes de noeuds sous la forme :
        [ (gno1, nb noeuds  gno1), ...] """
    nommail=self.get_name()
    dic_gpno=aster.getcolljev(nommail.ljust(8)+".GROUPENO")
    return [(gpno.strip(),len(dic_gpno[gpno])) for gpno in dic_gpno]
  def LIST_GROUP_MA(self) :
    """ retourne la liste des groupes de mailles sous la forme :
        [ (gma1, nb mailles gma1, dime max des mailles gma1), ...] """
    nommail=self.get_name()
    nommail=nommail.ljust(8)
    ngpma=[]
    ltyma =aster.getvectjev("&CATA.TM.NOMTM")
    catama=aster.getcolljev("&CATA.TM.TMDIM")
    dic_gpma=aster.getcolljev(nommail+".GROUPEMA")
    dimama=[catama[ltyma[ma-1]][0] for ma in aster.getvectjev(nommail+".TYPMAIL")]
    for grp in dic_gpma.keys():
        dim=max([dimama[ma-1] for ma in dic_gpma[grp]])
        ngpma.append((grp.strip(),len(dic_gpma[grp]),dim))
    return ngpma


class squelette     (maillage_sdaster):pass


# cham_gd_sdaster (carte_sdaster,cham_no_sdaster,cham_elem_sdaster)
#--------------------------------

class cham_gd_sdaster(ASSD):pass

# cham_gd_sdaster/carte_sdaster :
#--------------------------------
class carte_sdaster  (cham_gd_sdaster):pass
class carte_dbel_r   (carte_sdaster):pass
class carte_depl_c   (carte_sdaster):pass
class carte_depl_f   (carte_sdaster):pass
class carte_depl_r   (carte_sdaster):pass
class carte_durt_r   (carte_sdaster):pass
class carte_ener_r   (carte_sdaster):pass
class carte_epsi_r   (carte_sdaster):pass
class carte_erreur   (carte_sdaster):pass
class carte_flux_r   (carte_sdaster):pass
class carte_g_depl_r (carte_sdaster):pass
class carte_geom_r   (carte_sdaster):pass
class carte_hydr_r   (carte_sdaster):pass
class carte_inst_r   (carte_sdaster):pass
class carte_inte_r   (carte_sdaster):pass
class carte_irra_r   (carte_sdaster):pass
class carte_neut_f   (carte_sdaster):pass
class carte_neut_r   (carte_sdaster):pass
class carte_pres_r   (carte_sdaster):pass
class carte_sief_r   (carte_sdaster):pass
class carte_sour_r   (carte_sdaster):pass
class carte_temp_f   (carte_sdaster):pass
class carte_temp_r   (carte_sdaster):pass
class carte_var2_r   (carte_sdaster):pass
class carte_vnor_c   (carte_sdaster):pass
class carte_corr_r   (carte_sdaster):pass


# cham_gd_sdaster/cham_elem_sdaster :
#--------------------------------
class cham_elem_sdaster(cham_gd_sdaster):

  def EXTR_COMP(self,comp,lgma,topo=0) :
    """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de mailles lgma avec eventuellement l'info de la 
        topologie si topo>0. Si lgma est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo  :
          - self.maille  : numero de mailles
          - self.point   : numero du point dans la maille
          - self.sous_point : numero du sous point dans la maille """
    
  
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    nchams=ncham[0:7]+'S'
    ncmp=comp+(8-len(comp))*' '
    
    aster.prepcompcham(ncham,nchams,ncmp,"EL      ",topo,lgma)
    
    valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))
    
    if (topo>0) :
      maille=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.M'))
      point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.P'))
      sous_point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.SP'))
    else :
      maille=None
      point=None
      sous_point=None
    
    aster.prepcompcham("__DETR__",nchams,ncmp,"EL      ",topo,lgma)
    
    return post_comp_cham_el(valeurs,maille,point,sous_point)
    
class cham_elem_crit_r(cham_elem_sdaster):pass
class cham_elem_dbel_r(cham_elem_sdaster):pass
class cham_elem_depl_c(cham_elem_sdaster):pass
class cham_elem_depl_f(cham_elem_sdaster):pass
class cham_elem_depl_r(cham_elem_sdaster):pass
class cham_elem_dommag(cham_elem_sdaster):pass
class cham_elem_durt_r(cham_elem_sdaster):pass
class cham_elem_ener_r(cham_elem_sdaster):pass
class cham_elem_epsi_c(cham_elem_sdaster):pass
class cham_elem_epsi_r(cham_elem_sdaster):pass
class cham_elem_erreur(cham_elem_sdaster):pass
class cham_elem_facy_r(cham_elem_sdaster):pass
class cham_elem_flux_r(cham_elem_sdaster):pass
class cham_elem_g_depl(cham_elem_sdaster):pass
class cham_elem_geom_r(cham_elem_sdaster):pass
class cham_elem_hydr_r(cham_elem_sdaster):pass
class cham_elem_inst_r(cham_elem_sdaster):pass
class cham_elem_inte_r(cham_elem_sdaster):pass
class cham_elem_irra_r(cham_elem_sdaster):pass
class cham_elem_neut_f(cham_elem_sdaster):pass
class cham_elem_neut_r(cham_elem_sdaster):pass
class cham_elem_pres_r(cham_elem_sdaster):pass
class cham_elem_sief_c(cham_elem_sdaster):pass
class cham_elem_sief_r(cham_elem_sdaster):pass
class cham_elem_sour_r(cham_elem_sdaster):pass
class cham_elem_spma_r(cham_elem_sdaster):pass
class cham_elem_temp_f(cham_elem_sdaster):pass
class cham_elem_temp_r(cham_elem_sdaster):pass
class cham_elem_vari_r(cham_elem_sdaster):pass
class cham_elem_vnor_c(cham_elem_sdaster):pass


# cham_gd/cham_no :
#--------------------------------
class cham_no_sdaster(cham_gd_sdaster):  

  def EXTR_COMP(self,comp,lgno,topo=0) :
    """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de noeuds lgno avec eventuellement l'info de la 
        topologie si topo>0. Si lgno est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo (i.e. self.topo = 1) :
          - self.noeud  : numero de noeud """
    
  
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    nchams=ncham[0:7]+'S'
    ncmp=comp+(8-len(comp))*' '
    
    aster.prepcompcham(ncham,nchams,ncmp,"NO      ",topo,lgno)
    
    valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))
    
    if (topo>0) :
      noeud=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.N'))
    else :
      noeud=None
    
    aster.prepcompcham("__DETR__",nchams,ncmp,"NO      ",topo,lgno)
    
    return post_comp_cham_no(valeurs,noeud)

class cham_no_dbel_r   (cham_no_sdaster):pass
class cham_no_depl_c   (cham_no_sdaster):pass
class cham_no_depl_f   (cham_no_sdaster):pass
class cham_no_depl_r   (cham_no_sdaster):pass
class cham_no_durt_r   (cham_no_sdaster):pass
class cham_no_ener_r   (cham_no_sdaster):pass
class cham_no_epsi_r   (cham_no_sdaster):pass
class cham_no_erreur   (cham_no_sdaster):pass
class cham_no_facy_r   (cham_no_sdaster):pass
class cham_no_flux_r   (cham_no_sdaster):pass
class cham_no_g_depl_r (cham_no_sdaster):pass
class cham_no_geom_r   (cham_no_sdaster):pass
class cham_no_hydr_r   (cham_no_sdaster):pass
class cham_no_inst_r   (cham_no_sdaster):pass
class cham_no_inte_r   (cham_no_sdaster):pass
class cham_no_irra_r   (cham_no_sdaster):pass
class cham_no_neut_f   (cham_no_sdaster):pass
class cham_no_neut_r   (cham_no_sdaster):pass
class cham_no_pres_c   (cham_no_sdaster):pass
class cham_no_pres_r   (cham_no_sdaster):pass
class cham_no_sief_r   (cham_no_sdaster):pass
class cham_no_sour_r   (cham_no_sdaster):pass
class cham_no_spma_r   (cham_no_sdaster):pass
class cham_no_temp_c   (cham_no_sdaster):pass
class cham_no_temp_f   (cham_no_sdaster):pass
class cham_no_temp_r   (cham_no_sdaster):pass
class cham_no_vanl_r   (cham_no_sdaster):pass
class cham_no_var2_r   (cham_no_sdaster):pass
class cham_no_vnor_c   (cham_no_sdaster):pass


# resultat_sdaster : (evol_sdaster,mode_stat,mode_meca)
#--------------------------------------

class resultat_sdaster(ASSD):
  def LIST_CHAMPS (self) :
    return aster.GetResu(self.get_name(), "CHAMPS")
  def LIST_NOM_CMP (self) :
    return aster.GetResu(self.get_name(), "COMPOSANTES")
  def LIST_VARI_ACCES (self) :
    return aster.GetResu(self.get_name(), "VARI_ACCES")
  def LIST_PARA (self) :
    return aster.GetResu(self.get_name(), "PARAMETRES")

class acou_harmo    (resultat_sdaster):pass
class base_modale   (resultat_sdaster):pass
class comb_fourier  (resultat_sdaster):pass
class dyna_harmo    (resultat_sdaster):pass
class dyna_trans    (resultat_sdaster):pass
class fourier_elas  (resultat_sdaster):pass
class harm_gene     (resultat_sdaster):pass
class mode_acou     (resultat_sdaster):pass
class mode_cycl     (resultat_sdaster):pass
class mode_flamb    (resultat_sdaster):pass
class mode_gene     (resultat_sdaster):pass
class mult_elas     (resultat_sdaster):pass
class theta_geom    (resultat_sdaster):pass

# resultat_sdaster/evol_sdaster :
#--------------------------------
class evol_sdaster(resultat_sdaster):pass
class evol_char(evol_sdaster):pass
class evol_elas(evol_sdaster):pass
class evol_noli(evol_sdaster):pass
class evol_ther(evol_sdaster):pass
class evol_varc(evol_sdaster):pass

# resultat_sdaster/mode_stat :
#--------------------------------
class mode_stat(resultat_sdaster):pass
class mode_stat_depl(mode_stat):pass
class mode_stat_acce(mode_stat):pass
class mode_stat_forc(mode_stat):pass


# resultat_sdaster/mode_meca :
#--------------------------------
class mode_meca(resultat_sdaster):pass
class mode_meca_c(mode_meca):pass


# types 'fonction' :
#--------------------------------
class fonction_class(ASSD):
   def Valeurs(self):pass
   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la fonction ;
      le type jeveux (FONCTION, FONCT_C, NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel.
      """
      TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
      prol=aster.getvectjev(string.ljust(self.get_name(),19)+'.PROL')
      dico={
         'INTERPOL'    : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'    : prol[2][0:16],
         'NOM_RESU'    : prol[3][0:16],
         'PROL_DROITE' : TypeProl[prol[4][0]],
         'PROL_GAUCHE' : TypeProl[prol[4][1]],
      }
      return dico
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction"""
      from Utilitai.Graph import Graph
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
            Lab=[self.Parametres()['NOM_PARA'],self.Parametres()['NOM_RESU']])
      gr.Trace(FORMAT=FORMAT,**kargs)
class fonction_sdaster(fonction_class):
   def Valeurs(self) :
      """
      Retourne deux listes de valeurs : abscisses et ordonnees
      """
      if hasattr(self,'etape') and self.etape.nom=='DEFI_FONCTION' :
        lbl=list(self.etape['VALE'])
        dim=len(lbl)
        lx=[lbl[i] for i in range(0,dim,2)]
        ly=[lbl[i] for i in range(1,dim,2)]
        return [lx,ly]
      else :
        vale=string.ljust(self.get_name(),19)+'.VALE'
        lbl=list(aster.getvectjev(vale))
        dim=len(lbl)/2
        lx=lbl[0:dim]
        ly=lbl[dim:2*dim]
        return [lx,ly]
   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]
   def Ordo(self):
      """Retourne la liste des ordonnées"""
      return self.Valeurs()[1]
   def __call__(self,val):
      lx,ly=self.Valeurs()
      n=len(lx)
      if val in lx : return ly[lx.index(val)]
      lx.append(val)
      lx.sort()
      indic=lx.index(val)
      if indic==0   :
         if self.etape['PROL_GAUCHE']=='CONSTANT':return ly[0]
      if indic==n :
         if self.etape['PROL_DROITE']=='CONSTANT':return ly[n-1]
      return (ly[indic-1]+(ly[indic]-ly[indic-1])*(val-lx[indic-1])/(lx[indic+1]-lx[indic-1]))
class para_sensi(fonction_sdaster):
   def Parametres(self):pass
class fonction_c(fonction_class):
   def Valeurs(self) :
      """
      Retourne trois listes de valeurs : abscisses, parties reelles et imaginaires.
      """
      if self.etape.nom=='DEFI_FONCTION' :
        lbl=list(self.etape['VALE_C'])
        dim=len(lbl)
        lx=[lbl[i] for i in range(0,dim,3)]
        lr=[lbl[i] for i in range(1,dim,3)]
        li=[lbl[i] for i in range(2,dim,3)]
        return [lx,lr,li]
      else :
        vale=string.ljust(self.get_name(),19)+'.VALE'
        lbl=list(aster.getvectjev(vale))
        dim=len(lbl)/3
        lx=lbl[0:dim]
        lr=[]
        li=[]
        for i in range(dim):
           lr.append(lbl[dim+2*i])
           li.append(lbl[dim+2*i+1])
        return [lx,lr,li]
   def Absc(self):
      """Retourne la liste des abscisses"""
      return self.Valeurs()[0]
   def Ordo(self):
      """Retourne la liste des parties réelles des ordonnées"""
      return self.Valeurs()[1]
   def OrdoImg(self):
      """Retourne la liste des parties imaginaires des ordonnées"""
      return self.Valeurs()[2]
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une fonction complexe"""
      from Utilitai.Graph import Graph
      gr=Graph()
      gr.AjoutCourbe(Val=self.Valeurs(),
       Lab=[self.Parametres()['NOM_PARA'],self.Parametres()['NOM_RESU'],'IMAG'])
      gr.Trace(FORMAT=FORMAT,**kargs)
class nappe_sdaster(fonction_class):
   def Valeurs(self):
      """
      Retourne la liste des valeurs du parametre,
      et une liste de couples (abscisses,ordonnees) de chaque fonction.
      """
      nsd=string.ljust(self.get_name(),19)
      dicv=aster.getcolljev(nsd+'.VALE')
      # les cles de dicv sont 1,...,N (indice du parametre)
      lpar=aster.getvectjev(nsd+'.PARA')
      lval=[]
      for k in range(len(dicv)):
         lbl=dicv[k+1]
         dim=len(lbl)/2
         lval.append([lbl[0:dim],lbl[dim:2*dim]])
      return [lpar,lval]
   def Parametres(self):
      """
      Retourne un dictionnaire contenant les parametres de la nappe,
      le type jeveux (NAPPE) n'est pas retourne,
      le dictionnaire peut ainsi etre fourni a CALC_FONC_INTERP tel quel,
      et une liste de dictionnaire des parametres de chaque fonction.
      """
      TypeProl={'E':'EXCLU', 'L':'LINEAIRE', 'C':'CONSTANT' }
      prol=aster.getvectjev(string.ljust(self.get_name(),19)+'.PROL')
      dico={
         'INTERPOL'      : [prol[1][0:3],prol[1][4:7]],
         'NOM_PARA'      : prol[2][0:16],
         'NOM_RESU'      : prol[3][0:16],
         'PROL_DROITE'   : TypeProl[prol[4][0]],
         'PROL_GAUCHE'   : TypeProl[prol[4][1]],
         'NOM_PARA_FONC' : prol[5][0:4],
      }
      lparf=[]
      nbf=(len(prol)-6)/2
      for i in range(nbf):
         dicf={
            'INTERPOL_FONC'    : [prol[6+i*2][0:3],prol[6+i*2][4:7]],
            'PROL_DROITE_FONC' : TypeProl[prol[7+i*2][0]],
            'PROL_GAUCHE_FONC' : TypeProl[prol[7+i*2][1]],
         }
         lparf.append(dicf)
      return [dico,lparf]
   def Trace(self,FORMAT='TABLEAU',**kargs):
      """Tracé d'une nappe"""
      from Utilitai.Graph import Graph
      gr=Graph()
      lv=self.Valeurs()[1]
      dp=self.Parametres()[0]
      for lx,ly in lv:
         gr.AjoutCourbe(Val=[lx,ly], Lab=[dp['NOM_PARA_FONC'],dp['NOM_RESU']])
      gr.Trace(FORMAT=FORMAT,**kargs)

# matr_asse :
#--------------------------------
class matr_asse(ASSD):pass

class matr_asse_gene(matr_asse):pass
class matr_asse_gene_r(matr_asse_gene):pass
class matr_asse_gene_c(matr_asse_gene):pass

class matr_asse_gd(matr_asse):pass
class matr_asse_depl_c(matr_asse_gd):pass
class matr_asse_depl_r(matr_asse_gd):pass
class matr_asse_pres_c(matr_asse_gd):pass
class matr_asse_pres_r(matr_asse_gd):pass
class matr_asse_temp_c(matr_asse_gd):pass
class matr_asse_temp_r(matr_asse_gd):pass

# matr_elem :
#--------------------------------
class matr_elem(ASSD):pass
class matr_elem_depl_c(matr_elem):pass
class matr_elem_depl_r(matr_elem):pass
class matr_elem_pres_c(matr_elem):pass
class matr_elem_temp_r(matr_elem):pass




# table :
#--------------------------------
class table_sdaster(ASSD):
  def __getitem__(self,key):
      requete=string.ljust(key[0],24)
      tblp=string.ljust(self.get_name(),19)+'.TBLP'
      tabnom=list(aster.getvectjev(tblp))
      for i in range(len(tabnom)) :
         if tabnom[i]==requete: break
      resu=aster.getvectjev(tabnom[i+2])
      exist=aster.getvectjev(tabnom[i+3])
      if key[1]>len(resu) or exist[key[1]-1]==0:
         raise KeyError
      else:
         return resu[key[1]-1]
  def Nonefy(self,l1,l2) :
      if l2==0 : return None
      else     : return l1
  def EXTR_TABLE(self) :
      """Produit un objet Table à partir du contenu d'une table Aster
      """
      from Utilitai.Table import Table
      tblp=string.ljust(self.get_name(),19)+'.TBLP'
      tabnom=list(aster.getvectjev(tblp))
      nparam=len(tabnom)/4
      lparam=[tabnom[4*i:4*i+4] for i in range(nparam)]
      dval={}
      # liste des paramètres et des types
      lpar=[]
      ltyp=[]
      for i in lparam :
         value=list(aster.getvectjev(i[2]))
         exist=aster.getvectjev(i[3])
         dval[string.strip(i[0])]=map(self.Nonefy,value,exist)
         lpar.append(string.strip(i[0]))
         ltyp.append(string.strip(i[1]))
      n=len(dval[lpar[0]])
      # contenu : liste de dict
      lisdic=[]
      for i in range(n) :
        d={}
        for p in lpar : d[p]=dval[p][i]
        lisdic.append(d)
      # titre
      titj=aster.getvectjev(self.get_name().ljust(19)+'.TITR')
      if titj<>None:
         titr='\n'.join(titj)
      else:
         titr=''
      return Table(lisdic, lpar, ltyp, titr)

class table_jeveux(table_sdaster):
   """Classe permettant d'accéder à une table jeveux qui n'a pas d'ASSD associée,
   c'est le cas des concepts résultats (table, evol_xxxx) dérivés."""
   def __init__(self,nom_jeveux):
      self.nom=nom_jeveux

class tabl_aire_int   (table_sdaster):pass
class tabl_calc_g_loca(table_sdaster):pass
class tabl_calc_g_th  (table_sdaster):pass
class tabl_cara_geom  (table_sdaster):pass
class tabl_char_limite(table_sdaster):pass
class tabl_ener_elas  (table_sdaster):pass
class tabl_ener_pot   (table_sdaster):pass
class tabl_ener_cin   (table_sdaster):pass
class tabl_trav_ext   (table_sdaster):pass
class tabl_ener_totale(table_sdaster):pass
class tabl_indic_ener (table_sdaster):pass
class tabl_indic_seuil(table_sdaster):pass
class tabl_intsp      (table_sdaster):pass
class tabl_mass_iner  (table_sdaster):pass
class tabl_post_alea  (table_sdaster):pass
class tabl_post_beta  (table_sdaster):pass
class tabl_post_dyna  (table_sdaster):pass
class tabl_post_f_alea(table_sdaster):pass
class tabl_post_fatig (table_sdaster):pass
class tabl_post_gouj2e(table_sdaster):pass
class tabl_post_k     (table_sdaster):pass
class tabl_post_rccm  (table_sdaster):pass
class tabl_post_rele  (table_sdaster):pass
class tabl_post_simpli(table_sdaster):pass
class tabl_post_usur  (table_sdaster):pass
class tabl_reca_weib  (table_sdaster):pass
class tabl_rice_tracey(table_sdaster):pass
class tabl_texture    (table_sdaster):pass
class tabl_trc        (table_sdaster):pass
class tabl_weibull    (table_sdaster):pass


# vect_asse :
#--------------------------------
class vect_asse(ASSD):pass
class vect_asse_gene(vect_asse):pass


# vect_elem :
#--------------------------------
class vect_elem(ASSD):pass
class vect_elem_depl_r(vect_elem):pass
class vect_elem_pres_c(vect_elem):pass
class vect_elem_pres_r(vect_elem):pass
class vect_elem_temp_r(vect_elem):pass

