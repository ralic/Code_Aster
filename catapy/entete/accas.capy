#& MODIF ENTETE  DATE 30/03/2004   AUTEUR CIBHHLV L.VIVAN 
#            CONFIGURATION MANAGEMENT OF EDF VERSION
# ======================================================================
# COPYRIGHT (C) 1991 - 2001  EDF R&D                  WWW.CODE-ASTER.ORG
# THIS PROGRAM IS FREE SOFTWARE; YOU CAN REDISTRIBUTE IT AND/OR MODIFY
# IT UNDER THE TERMS OF THE GNU GENERAL PUBLIC LICENSE AS PUBLISHED BY
# THE FREE SOFTWARE FOUNDATION; EITHER VERSION 2 OF THE LICENSE, OR
# (AT YOUR OPTION) ANY LATER VERSION.
#
# THIS PROGRAM IS DISTRIBUTED IN THE HOPE THAT IT WILL BE USEFUL, BUT
# WITHOUT ANY WARRANTY; WITHOUT EVEN THE IMPLIED WARRANTY OF
# MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE. SEE THE GNU
# GENERAL PUBLIC LICENSE FOR MORE DETAILS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF THE GNU GENERAL PUBLIC LICENSE
# ALONG WITH THIS PROGRAM; IF NOT, WRITE TO EDF R&D CODE_ASTER,
#    1 AVENUE DU GENERAL DE GAULLE, 92141 CLAMART CEDEX, FRANCE.
# ======================================================================
import Accas
from Accas import *
from Accas import _F
import string
import Numeric

import ops

try:
  import aster
except:
  pass

#
__version__="$Name:  $"
__Id__="$Id: cata_aster_v6.py,v 1.12 2001/01/16 15:55:05 iliade Exp $"
#
JdC = JDC_CATA(code='ASTER',
               execmodul=None,
               regles = (AU_MOINS_UN('DEBUT','POURSUITE'),
                         AU_MOINS_UN('FIN'),
                         A_CLASSER(('DEBUT','POURSUITE'),'FIN')))
# Type le plus general
class entier  (ASSD):pass
class reel    (ASSD):pass
class complexe(ASSD):pass
class chaine  (ASSD):pass


# Type geometriques
class no  (GEOM):pass
class grno(GEOM):pass
class ma  (GEOM):pass
class grma(GEOM):pass



# Autres

class cabl_precont    (ASSD):pass
class cara_elem       (ASSD):pass
class cara_pout       (ASSD):pass
class cham_mater      (ASSD):pass
class char_acou       (ASSD):pass
class char_cine_acou  (ASSD):pass
class char_cine_meca  (ASSD):pass
class char_cine_ther  (ASSD):pass
class char_meca       (ASSD):pass
class char_ther       (ASSD):pass
class courbe          (ASSD):pass
class fiss_xfem       (ASSD):pass
class fond_fiss       (ASSD):pass
class interf_dyna_clas(ASSD):pass
class interspfact     (ASSD):pass
class listis          (ASSD):pass
class liste           (ASSD):pass
class macr_elem_dyna  (ASSD):pass
class macr_elem_stat  (ASSD):pass
class mater           (ASSD):pass
class melasflu        (ASSD):pass
class modele          (ASSD):pass
class modele_gene     (ASSD):pass
class nume_ddl        (ASSD):pass
class nume_ddl_gene   (ASSD):pass
class obstacle        (ASSD):pass
class spectre         (ASSD):pass
class surface         (ASSD):pass
class tran_gene       (ASSD):pass
class type_flui_stru  (ASSD):pass
class valeur          (ASSD):pass


# liste :
#--------------------------------
class listr8   (ASSD):
  def LIST_VALEURS(self) :
    """ retourne la liste des valeurs [ val1, ...] """
    vale=string.ljust(self.get_name(),19)+'.VALE'
    return list(aster.getvectjev(vale))


# post-traitement :
#--------------------------------
class post_comp_cham_el :
  def __init__(self,valeurs,maille=None,point=None,sous_point=None) :
    self.valeurs=valeurs
    self.maille=maille
    self.point=point
    self.sous_point=sous_point

class post_comp_cham_no :
  def __init__(self,valeurs,noeud=None) :
    self.valeurs=valeurs
    self.noeud=noeud

# maillage :
#--------------------------------
class maillage(ASSD):
  def LIST_GROUP_NO(self) :
    """ retourne la liste des groupes de noeuds sous la forme :
        [ (gno1, nb noeuds  gno1), ...] """
    return aster.GetMaillage(self.get_name(), "GROUP_NO")
  def LIST_GROUP_MA(self) :
    """ retourne la liste des groupes de mailles sous la forme :
        [ (gma1, nb mailles gma1, dime max des mailles gma1), ...] """
    return aster.GetMaillage(self.get_name(), "GROUP_MA")


class squelette     (maillage):pass


# cham_gd (carte,cham_no,cham_elem)
#--------------------------------

class cham_gd(ASSD):pass

# cham_gd/carte :
#--------------------------------
class carte(cham_gd):pass
class carte_dbel_r   (carte):pass
class carte_depl_c   (carte):pass
class carte_depl_f   (carte):pass
class carte_depl_r   (carte):pass
class carte_durt_r   (carte):pass
class carte_ener_r   (carte):pass
class carte_epsi_r   (carte):pass
class carte_erreur   (carte):pass
class carte_flux_r   (carte):pass
class carte_g_depl_r (carte):pass
class carte_geom_r   (carte):pass
class carte_hydr_r   (carte):pass
class carte_inst_r   (carte):pass
class carte_inte_r   (carte):pass
class carte_irra_r   (carte):pass
class carte_neut_f   (carte):pass
class carte_neut_r   (carte):pass
class carte_pres_r   (carte):pass
class carte_sief_r   (carte):pass
class carte_sour_r   (carte):pass
class carte_temp_f   (carte):pass
class carte_temp_r   (carte):pass
class carte_var2_r   (carte):pass
class carte_vnor_c   (carte):pass
class carte_corr_r   (carte):pass


# cham_gd/cham_elem :
#--------------------------------
class cham_elem(cham_gd):

  def EXTR_COMP(self,comp,lgma,topo=0) :
    """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de mailles lgma avec eventuellement l'info de la 
        topologie si topo>0. Si lgma est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo  :
          - self.maille  : numero de mailles
          - self.point   : numero du point dans la maille
          - self.sous_point : numero du sous point dans la maille """
    
  
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    nchams=ncham[0:7]+'S'
    ncmp=comp+(8-len(comp))*' '
    
    aster.prepcompcham(ncham,nchams,ncmp,"EL      ",topo,lgma)
    
    valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))
    
    if (topo>0) :
      maille=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.M'))
      point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.P'))
      sous_point=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.SP'))
    else :
      maille=None
      point=None
      sous_point=None
    
    aster.prepcompcham("__DETR__",nchams,ncmp,"EL      ",topo,lgma)
    
    return post_comp_cham_el(valeurs,maille,point,sous_point)
    
class cham_elem_crit_r(cham_elem):pass
class cham_elem_dbel_r(cham_elem):pass
class cham_elem_depl_c(cham_elem):pass
class cham_elem_depl_f(cham_elem):pass
class cham_elem_depl_r(cham_elem):pass
class cham_elem_dommag(cham_elem):pass
class cham_elem_durt_r(cham_elem):pass
class cham_elem_ener_r(cham_elem):pass
class cham_elem_epsi_c(cham_elem):pass
class cham_elem_epsi_r(cham_elem):pass
class cham_elem_erreur(cham_elem):pass
class cham_elem_facy_r(cham_elem):pass
class cham_elem_flux_r(cham_elem):pass
class cham_elem_g_depl(cham_elem):pass
class cham_elem_geom_r(cham_elem):pass
class cham_elem_hydr_r(cham_elem):pass
class cham_elem_inst_r(cham_elem):pass
class cham_elem_inte_r(cham_elem):pass
class cham_elem_irra_r(cham_elem):pass
class cham_elem_neut_f(cham_elem):pass
class cham_elem_neut_r(cham_elem):pass
class cham_elem_pres_r(cham_elem):pass
class cham_elem_sief_c(cham_elem):pass
class cham_elem_sief_r(cham_elem):pass
class cham_elem_sour_r(cham_elem):pass
class cham_elem_spma_r(cham_elem):pass
class cham_elem_temp_f(cham_elem):pass
class cham_elem_temp_r(cham_elem):pass
class cham_elem_vari_r(cham_elem):pass
class cham_elem_vnor_c(cham_elem):pass


# cham_gd/cham_no :
#--------------------------------
class cham_no(cham_gd):  

  def EXTR_COMP(self,comp,lgno,topo=0) :
    """ retourne les valeurs de la composante comp du champ sur la liste
        de groupes de noeuds lgno avec eventuellement l'info de la 
        topologie si topo>0. Si lgno est une liste vide, c'est equivalent
        a un TOUT='OUI' dans les commandes aster
        Attributs retourne
          - self.valeurs : Numeric.array contenant les valeurs
        Si on a demande la topo (i.e. self.topo = 1) :
          - self.noeud  : numero de noeud """
    
  
    ncham=self.get_name()
    ncham=ncham+(8-len(ncham))*' '
    nchams=ncham[0:7]+'S'
    ncmp=comp+(8-len(comp))*' '
    
    aster.prepcompcham(ncham,nchams,ncmp,"NO      ",topo,lgno)
    
    valeurs=Numeric.array(aster.getvectjev(nchams+(19-len(ncham))*' '+'.V'))
    
    if (topo>0) :
      noeud=(aster.getvectjev(nchams+(19-len(ncham))*' '+'.N'))
    else :
      noeud=None
    
    aster.prepcompcham("__DETR__",nchams,ncmp,"NO      ",topo,lgno)
    
    return post_comp_cham_no(valeurs,noeud)

class cham_no_dbel_r   (cham_no):pass
class cham_no_depl_c   (cham_no):pass
class cham_no_depl_f   (cham_no):pass
class cham_no_depl_r   (cham_no):pass
class cham_no_durt_r   (cham_no):pass
class cham_no_ener_r   (cham_no):pass
class cham_no_epsi_r   (cham_no):pass
class cham_no_erreur   (cham_no):pass
class cham_no_facy_r   (cham_no):pass
class cham_no_flux_r   (cham_no):pass
class cham_no_g_depl_r (cham_no):pass
class cham_no_geom_r   (cham_no):pass
class cham_no_hydr_r   (cham_no):pass
class cham_no_inst_r   (cham_no):pass
class cham_no_inte_r   (cham_no):pass
class cham_no_irra_r   (cham_no):pass
class cham_no_neut_f   (cham_no):pass
class cham_no_neut_r   (cham_no):pass
class cham_no_pres_c   (cham_no):pass
class cham_no_pres_r   (cham_no):pass
class cham_no_sief_r   (cham_no):pass
class cham_no_sour_r   (cham_no):pass
class cham_no_spma_r   (cham_no):pass
class cham_no_temp_c   (cham_no):pass
class cham_no_temp_f   (cham_no):pass
class cham_no_temp_r   (cham_no):pass
class cham_no_vanl_r   (cham_no):pass
class cham_no_var2_r   (cham_no):pass
class cham_no_vnor_c   (cham_no):pass


# resultat : (evol,mode_stat,mode_meca)
#--------------------------------

class resultat(ASSD):
  def LIST_CHAMPS (self) :
    return aster.GetResu(self.get_name(), "CHAMPS")
  def LIST_NOM_CMP (self) :
    return aster.GetResu(self.get_name(), "COMPOSANTES")
  def LIST_VARI_ACCES (self) :
    return aster.GetResu(self.get_name(), "VARI_ACCES")
  def LIST_PARA (self) :
    return aster.GetResu(self.get_name(), "PARAMETRES")

class acou_harmo    (resultat):pass
class base_modale     (resultat):pass
class comb_fourier  (resultat):pass
class dyna_harmo    (resultat):pass
class dyna_trans    (resultat):pass
class fourier_elas  (resultat):pass
class harm_gene     (resultat):pass
class mode_acou     (resultat):pass
class mode_cycl     (resultat):pass
class mode_flamb    (resultat):pass
class mode_gene     (resultat):pass
class mult_elas     (resultat):pass
class theta_geom    (resultat):pass

# resultat/evol :
#--------------------------------
class evol(resultat):pass
class evol_char(evol):pass
class evol_elas(evol):pass
class evol_noli(evol):pass
class evol_ther(evol):pass
class evol_varc(evol):pass

# resultat/mode_stat :
#--------------------------------
class mode_stat(resultat):pass
class mode_stat_depl(mode_stat):pass
class mode_stat_acce(mode_stat):pass
class mode_stat_forc(mode_stat):pass


# resultat/mode_meca :
#--------------------------------
class mode_meca(resultat):pass
class mode_meca_c(mode_meca):pass


# fonction :
#--------------------------------
class fonction(ASSD):
  def LIST_VALEURS(self) :
    """ retourne la liste des valeurs [ val1, ...] """
    vale=string.ljust(self.get_name(),19)+'.VALE'
    lbl=list(aster.getvectjev(vale))
    lbr=[]
    for i in range(len(lbl)/2):
        lbr.append(lbl[i])
        lbr.append(lbl[len(lbl)/2+i])
    return lbr
class para_sensi(fonction):pass
class fonction_c(fonction):
  def LIST_VALEURS(self) :
    """ retourne la liste des valeurs [ val1, ...] """
    vale=string.ljust(self.get_name(),19)+'.VALE'
    lbl=list(aster.getvectjev(vale))
    lbr=[]
    for i in range(len(lbl)/3):
        lbr.append(lbl[i])
        lbr.append(lbl[len(lbl)/3+i*2])
        lbr.append(lbl[len(lbl)/3+i*2+1])
    return lbr
class nappe(fonction):pass


# matr_asse :
#--------------------------------
class matr_asse(ASSD):pass

class matr_asse_gene(matr_asse):pass
class matr_asse_gene_r(matr_asse_gene):pass
class matr_asse_gene_c(matr_asse_gene):pass

class matr_asse_gd(matr_asse):pass
class matr_asse_depl_c(matr_asse_gd):pass
class matr_asse_depl_r(matr_asse_gd):pass
class matr_asse_pres_c(matr_asse_gd):pass
class matr_asse_pres_r(matr_asse_gd):pass
class matr_asse_temp_c(matr_asse_gd):pass
class matr_asse_temp_r(matr_asse_gd):pass

# matr_elem :
#--------------------------------
class matr_elem(ASSD):pass
class matr_elem_depl_c(matr_elem):pass
class matr_elem_depl_r(matr_elem):pass
class matr_elem_pres_c(matr_elem):pass
class matr_elem_temp_r(matr_elem):pass




# table :
#--------------------------------

class table(ASSD):
  def __getitem__(self,key):
      requete=string.ljust(key[0],24)
      tblp=string.ljust(self.get_name(),19)+'.TBLP'
      tabnom=list(aster.getvectjev(tblp))
      for i in range(len(tabnom)) :
         if tabnom[i]==requete: break
      resu=aster.getvectjev(tabnom[i+2])
      if key[1]>len(resu) : raise KeyError
      else                : return resu[key[1]-1]

class tabl_aire_int   (table):pass
class tabl_calc_g_loca(table):pass
class tabl_calc_g_th  (table):pass
class tabl_cara_geom  (table):pass
class tabl_char_limite(table):pass
class tabl_ener_elas  (table):pass
class tabl_ener_pot   (table):pass
class tabl_ener_cin   (table):pass
class tabl_trav_ext   (table):pass
class tabl_ener_totale(table):pass
class tabl_indic_ener (table):pass
class tabl_indic_seuil(table):pass
class tabl_intsp      (table):pass
class tabl_mass_iner  (table):pass
class tabl_post_alea  (table):pass
class tabl_post_beta  (table):pass
class tabl_post_dyna  (table):pass
class tabl_post_f_alea(table):pass
class tabl_post_fatig (table):pass
class tabl_post_gouj2e(table):pass
class tabl_post_k     (table):pass
class tabl_post_rccm  (table):pass
class tabl_post_rele  (table):pass
class tabl_post_simpli(table):pass
class tabl_post_usur  (table):pass
class tabl_reca_weib  (table):pass
class tabl_rice_tracey(table):pass
class tabl_texture    (table):pass
class tabl_trc        (table):pass
class tabl_weibull    (table):pass


# vect_asse :
#--------------------------------
class vect_asse(ASSD):pass
class vect_asse_gene(vect_asse):pass


# vect_elem :
#--------------------------------
class vect_elem(ASSD):pass
class vect_elem_depl_r(vect_elem):pass
class vect_elem_pres_c(vect_elem):pass
class vect_elem_pres_r(vect_elem):pass
class vect_elem_temp_r(vect_elem):pass
